### js数据类型判断

1. typeof 

   typeof返回一个表示数据类型的字符串，返回结果包括：number、string、boolean、object、undefined、function。typeof可以对基本类型number、string 、boolean、undefined做出准确的判断。null除外，typeof null===“object”  历史原因

2. instanceof

   当我们需要知道某个对象的具体类型时,可以用运算符 instanceof，instanceof操作符判断左操作数对象的原型链上是否有右边这个构造函数的prototype属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值。

   ```js
   /* 
   虽然 instanceof 能够判断出 [] 是Array的实例，但它认为 [] 也是Object的实例， 我们来分析一下[]、Array、Object 三者之间的关系: 从instanceof 能够判断出 [].__proto__ 指向 Array.prototype， 而 Array.prototype.__proto__ 又指向了Object.prototype，Object.prototype.__proto__ 指向了null,标志着原型链的结束。因此，[]、Array、Object就形成了如下图所示的一条原型链：
   从原型链可以看出，[] 的 __proto__  直接指向Array.prototype, 间接指向Object.prototype, 所以按照 instanceof 的判断规则，[] 就是Object的实例。
   */
   [] instanceof Array; //true
   [] instanceof Object; //true
   new Date() instanceof Date;//true
   new Date() instanceof Object;//true
   function Person(){};
   new Person() instanceof Person;//true
   new Person() instanceof Object;//true
   
   ```

   

3. constructor

   constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。

```js
var f = new F();
f.constructor === F;// true

//但是 constructor 属性易变，不可信赖，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor会丢失。
function F() {}
F.prototype = {
	_name: 'Eric',
};
var f = new F();
f.constructor === F; // false

//因此，为了规范，在重写对象原型时一般都需要重新给constructor赋值，以保证实例对象的类型不被改写。
function F() {}
F.prototype = {
    constructor: F, 
   _name: 'Eric',
};
var f = new F();
f.constructor === F; // true 
```



4.Object.prototype.toString 

```js
//toString是Object原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString运行时this指向的对象类型, 返回的类型格式为[object,xxx],xxx是具体的数据类型
Object.prototype.toString.call('') ;   // [object String]
Object.prototype.toString.call(1) ;    // [object Number]
Object.prototype.toString.call(true) ; // [object Boolean]
Object.prototype.toString.call(undefined) ; // [object Undefined]
Object.prototype.toString.call(null) ; // [object Null]
Object.prototype.toString.call(new Function()) ; // [object Function]
Object.prototype.toString.call(new Date()) ; // [object Date]
Object.prototype.toString.call([]) ; // [object Array]
Object.prototype.toString.call(new RegExp()) ; // [object RegExp]
Object.prototype.toString.call(new Error()) ; // [object Error]
Object.prototype.toString.call(document) ; // [object HTMLDocument]
Object.prototype.toString.call(window) ; //[object Window]
```





### xhr和fetch区别

都是异步请求网络数据的方法，xhr通过`new XMLHttpRequest()`创建一个 XHR 对象；fetch是原生js方法，基于promise对象处理异步请求

fetch工作原理：

1. 使用`fetch()`函数创建请求：传入要请求的 URL，以及可选的配置参数，例如请求方法、请求头等。
2. 处理响应：`fetch()`返回一个 Promise，您可以使用`.then()`链式调用来处理响应数据，例如使用`.json()`方法解析 JSON 数据或`.text()`方法获取文本数据。
3. 错误处理：您可以使用`.catch()`方法来捕获任何请求或响应的错误。
4. 使用`async/await`：如果需要，您还可以使用`async/await`来更清晰地处理异步操作。

```js
    const formDate = new FormData()
    formDate.append("name","1111")
    async function getData(){
        const response = await fetch("http://123.207.32.32:1888/02_param/postform",{
            method:"post",
            // headers:{
            //     "Content-type":"application/json"
            // },
            body:formDate
        })
        const res = await response.json()
        console.log(res)
    }
    getData()
```





### new 一个函数发生了什么

构造调用：

创造一个全新的对象实例
这个对象会被执行 [[Prototype]] 连接，将这个新对象的\__proto__链接到这个构造函数 .prototype 所指向的对象
这个新对象会绑定到函数调用的 this
如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象





### 作用域

全局作用域，函数作用域



### 闭包

闭包是指有权访问另外一个函数作用域中的变量的函数

闭包是一种特殊的对象，它由两部分组成：执行上下文（代号 A），以及在该执行上下文中创建的函数 （代号 B），当 B 执行时，如果访问了 A 中变量对象的值，那么闭包就会产生，且在 Chrome 中使用这个执行上下文 A 的函数名代指闭包



闭包本质：当前环境中存在指向父级作用域的引用

- **如何产生闭包**
  - 返回函数
  - 函数当做参数传递

- **闭包的应用场景**
  - 封装变量：用闭包定义能访问私有函数和私有变量的公有函数。
  - 模块



### this ，bind，call，apply 



### 柯里化/反柯里化

柯里化：将接受多个参数的函数转换成一系列只接受单个参数的函数的过程。柯里化函数的返回值仍然是一个函数，该函数接受一个参数，并返回一个新的函数，直到所有参数都被处理完毕，最终返回最终结果

```js
function add(a) {
  return function(b) {
    return a + b;
  }
}
const addFive = add(5);
console.log(addFive(2)); // 输出 7
```

反柯里化：将柯里化函数转换成接受多个参数的函数的过程。反柯里化函数的返回值是一个函数，该函数接受一个对象作为参数，并调用该对象的原本方法并传递参数。

- 可读性：反柯里化可以使得函数的调用方式变得更加简单，只需要调用一个函数并传递一个对象作为参数即可。
- 可复用性：反柯里化可以使得函数更加可复用，因为它可以将一个预设 this 对象的函数转换成接受 this 对象的函数，从而可以在不同的对象上复用该函数。

```js
// 一个简单的反柯里化函数 bind，该函数将预设 this 对象的函数转换成接受 this 对象的函数：
function bind(fn, obj) {
  return function(...args) {
    return fn.apply(obj, args);
  }
}
const obj = { x: 1, y: 2 };
function sum() {
  return this.x + this.y;
}
const boundSum = bind(sum, obj);
console.log(boundSum()); // 输出 3
```



### History API

`History` 接口，允许操作浏览器的 `session history`，比如在当前`tab`下浏览的所有页面或者当前页面的会话记录

History不继承任何方法；

**1、 back()**

返回历史记录会话的上一个页面，同浏览器的返回，同 history.go(-1)

**2、forward()**

前进到历史会话记录的下一个页面，同浏览器的前进，同 history.go(1)

**3、go()**

从session history里面加载页面，取决于当前页面的相对位置，比如 go(-1) 是返回上一页，go(1)是前进到下一个页面。
如果你直接一个超过当前总length的返回，比如初始页面，没有前一个页面，也没有后一个页面，这个时候 go(-1) 和 go(1),都不会有任何作用；
如果你不指定任何参数或者go(0),将会重新加载当前页面；

**4、pushState(StateObj, title, url)**

**允许你在不重新加载页面的情况下添加新的历史记录**，往浏览器历史堆栈添加新的记录，把提供的状态数据放到当前的会话栈里面，如果有参数的话，一般第二个是title，第三个是URL。这个数据被DOM当做透明数据；你可以传任何可以序列号的数据。这个方法会引起会话记录length的增长。

```js
// 点击这些链接时，URL会被更改，但页面不会重新加载。相反，会调用 loadPage函数来加载相应的内容。
document.getElementById('articles-link').addEventListener('click', function() {
  history.pushState({ page: 'articles' }, '', '/articles');
  loadPage('articles');
});

document.getElementById('author-link').addEventListener('click', function() {
  history.pushState({ page: 'author' }, '', '/author');
  loadPage('author');
});
```



**5、replaceState(StateObj, title, url)**

把提供的状态数据更新到当前的会话栈里面最近的入口，如果有参数的话，一般第二个是title，第三个是URL。
这个数据被DOM当做透明数据；你可以传任何可以序列号的数据。这个方法不会引起会话记录length的增长。



**当浏览器前进，返回，刷新时会触发popState,  在这个方法中监听路由变化**

```js
// 这两个Api都会操作浏览器的历史栈，而不会引起页面的刷新
history.pushState(data, title, url) //向浏览器历史栈中增加一条记录。
history.replaceState(data, title, url) //替换历史栈中的当前记录。
```



**popState** 

`popstate` 是一个浏览器事件，当激活历史记录条目（例如，用户点击浏览器的前进或后退按钮）时触发。你可以使用此事件来响应URL的变化并加载相应的页面内容。

popState可以监听浏览器的前进，后退，刷新，history.back()，history.forward()

```js
window.addEventListener('popstate', function(event) {
  loadPage(event.state.page);
});
```





## Vue相关知识

### 设计模式

### **发布者-订阅者模式** 

主要实现三个对象：Observer（观察者），Watcher（订阅者，观察者），Dep（发布者，订阅收集器）。

1、Observer: 数据的观察者，**让数据对象的读写操作（数据劫持）**都处于自己的监管之下

2、Watcher: 数据的订阅者，数据的变化会通知到Watcher，然后由Watcher进行相应的操作，例如更新视图

3、Dep: Observer与Watcher的纽带，当数据变化时，会被Observer观察到，然后由Dep通知到Watcher

![img](D:\typora-img\v2-84c49a649691b5e89d014dfcdf7b105e_1440w.webp)

### Vue初始化流程

```js
// 位置 src/core/instance/index.js
import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'
import { warn } from '../util/index'

function Vue(options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  // new Vue的时候就执行到了这个_init函数
  this._init(options)
}
initMixin(Vue) // initMixin内部关键就是定义和挂载_init方法：Vue.prototype._init = function() {...} 
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue


/*  src/core/instance/init.js  */
 Vue.prototype._init = function (options) {
    let vm = this;
    // 每个vue都会有一个uid
    vm._uid = uid++
    // 把一些全局的api方法混入到当前实例的$options上面
    vm.$options = mergeOptions(vm.constructor.options, options)
    //生命周期钩子beforeCreate
    callHook(vm, 'beforeCreate')
    //初始化状态，props，methods，data，computed，watch
    initState(vm)
    //初始化成功后调用created钩子
    callHook(vm, 'created')
    if (vm.$options.el) {
        //开始挂载
        vm.$mount(vm.$options.el)
    }
}

```

打开 **$mount** 看看它做了什么

点开源码 **src/platforms/web/entry-runtime-with-compiler.js**

把一些多余的 代码简化一下。

```js
const mount = Vue.prototype.$mount
// 这里重写了mount
Vue.prototype.$mount = function (el) {
		//根据用户传入的 el 属性获取节点
        el = el && document.querySelector(el);
        let vm = this;
        //把节点放在 vm.$el 上方便后面使用
        vm.$el = el;
        let options = vm.$options;
        let template
        /**
         * 编译权重：
         * 优先看有没有render函数，如果有直接用
         * 如果没有render函数就看有没有template模板
         * 如果都没有就直接获取el的outerHTML作为渲染模板
         */
        if (!options.render) {
            if (!options.template) {
                template = el.outerHTML
            } else {
                template = vm.$options.template
            }
        }
        if (template) {
            //用 template 生成 render 函数
            let render = compileToFunctions(template)
            options.render = render
        }
        // 开始渲染页面。
        return mount(this, el) // 这个mount是 web/runtime/index中定义的$mount, 内部调用了mountComponent进行模板挂载
    }

/* 上面代码主要实现了 vue 渲染过程中很重要的一步，得到 render 函数。
如果我们使用的 template 进行编写HTML代码，vue 内部会把模板编译成 vue 可识别的 render 函数，如果有写 render 则可以省去编译过程。
（ 直接写 render 函数对 vue 编译效率会更好 ）
*/
```

源码 **src/core/instance/lifecycle.js** 找到 **mountComponent** 方法

```js
export function mountComponent(vm, el) {
	//渲染之前调用 beforeMount 生命周期
    callHook(vm, 'beforeMount')
    //创建一个更新渲染函数 （ 用来得到 Vnode 渲染真实 dom ）
    let updateComponent = () => {
        vm.update(vm._render())
    }
    //生成一个渲染 watcher 每次页面依赖的数据更新后会调用 updateComponent 进行渲染
    new Watcher(vm, updateComponent, () => {},{
        before () {
            callHook(vm, 'beforeUpdate')
        }
      },true)
    //渲染真实 dom 结束后调用 mounted 生命周期
    callHook(vm, 'mounted')
}
```

这里就是开始准备挂载真实 dom 了，创建了渲染 watcher ，渲染 watcher 内部调用了 updateComponent 方法。

继续往下看打开 **Watcher** 所在位置 **src/core/observer/watcher.js**

#### watcher模板渲染

```js
export class Watcher {
    constructor(vm,expOrFn,cb,options) {
        this.vm = vm
        this.expOrFn = expOrFn
        this.deps = [];
        this.set = {}
        this.id = id++
        if (typeof expOrFn === 'function') {
            this.getters = expOrFn
        } 
        this.value = this.get();
    }
    addDep(dep) {
        let id = dep.id
        //去重防止 dep 添加 watch 多次
        if (!this.set[id]) {
            // watcher 添加 dep
            this.deps.push(dep)
            //重点！给 dep 添加 watch
            dep.addSub(this)
            this.set[id] = true;
        }
    }
    get() {
        //标记 渲染target
        pushTarget(this)
        // 重点，这里会去访问我们给属性重写的 get 方法，添加 watcher 依赖
         this.getters.call(this.vm, this.vm);
        //弹出target防止data上每个属性都产生依赖，只有页面上使用的变量需要依赖
        popTarget()
        return value
    }
   	upDate() {
        this.get(this)
   }
}


const targetStack = []
// 渲染阶段，访问页面上的属性变量时，给对应的 Dep 添加 watcher
export function pushTarget(watcher) {
    targetStack.push(watcher)
    Dep.target = watcher
}
// 访问结束后删除
export function popTarget() {
    targetStack.pop()
    Dep.target = targetStack[targetStack.length - 1]
}
```

vue 初次渲染时 watcher 内部调用了 updateComponent 方法 （ 数据添加依赖我们后面说 ）

**updateComponent 整个渲染周期最关键的几行。**

```js
let updateComponent = () => {
     //获取到虚拟 dom 调用 update 进行渲染 
     vm.update(vm._render())
}
```

我们进入 **vm._render** 函数

打开 **src/core/instance/render.js**

```js
Vue.prototype._render = function () {
     let vm = this
     // 拿到 render 函数
     let render = vm.$options.render;
     // 调用 render 函数得到 Vnode
     return render.call(vm)
}
```

调用 render 函数得到 Vnode

接着我们进入 **vm.update** 函数

找到 **vm.update** 函数位置 **src/core/instance/lifecycle.js**

```js
Vue.prototype.update = function (vnode) {
     let vm = this
     // 获取到上一次的 Vnode 用于 diff 对比
     const prevVnode = vm._vnode
     if (!prevVnode) {
     	 //首次渲染走这里
         vm.$el = patch(vm.$el, vnode)
     } else {
     	 //数据更新驱动视图更新走这里
         vm.$el = patch(prevVnode, vnode)
     }
     //保留 Vnode
     vm._vnode = vnode
}
```

进入 **patch** 方法 **src/core/vdom/patch.js**

```js
 return function patch(el, vnode, hydrating, removeOnly) {
  	//首次渲染使用 Vnode 创建真实 dom
    createElm(vnode, false, el)
    return vnode.elm
  }
 function createElm (
    vnode, //虚拟dom
    insertedVnodeQueue,
    parentElm, //父节点
  ) {
     // 查看元素 tag 是不是组件，如果是组件就创建组件
    if (createComponent(vnode, insertedVnodeQueue, parentElm)) {
      return
    }
    const data = vnode.data //得到 data 数据
    const children = vnode.children //得到子元素
    const tag = vnode.tag //获取标签名
    vnode.elm = document.createElement(tag)
    if (isDef(tag)) {
   	  //如果有子节点递归渲染子节点
      createChildren(vnode, children, insertedVnodeQueue)
   	  //给父元素插入子元素
      parentElm.appendChild(elm)
    } else if (isTrue(vnode.isComment)) {
      //创建注释节点
      vnode.elm = document.createComment(vnode.text)
      //给父元素插入注释节点
      parentElm.appendChild(elm)
    } else {
      //创建文本节点
      vnode.elm = document.createTextNode(vnode.text)
      //给父元素插入文本节点
      parentElm.appendChild(elm)
    }
  }
function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (let i = 0; i < children.length; ++i) {
      	//渲染子节点
        createElm(children[i], insertedVnodeQueue, vnode.elm)
      }
    }
  }
```

以上就是 new Vue 的整个流程。

![img](D:\typora-img\915803-20191124153601697-1162884488.png)

### 模板编译

1.模板编译就是将template里的代码通过正则匹配，转化为ast

2.将ast转换为render函数

3.vue编译代码分为weex和web







### 双向绑定原理

**Object.defineProperty(obj, prop, descriptor)**
其中：
**obj**
要在其上定义属性的对象。
**prop**
要定义或修改的属性的名称。
**descriptor**
将被定义或修改的属性描述符。

其实，简单点来说，就是通过此方法来定义一个值。
调用，使用到了 get 方法，
赋值，使用到了 set 方法。

vue 双向绑定内部核心就是利用了两个类， Dep 类和 watcher 类

每个在页面上使用了的属性、数组、对象都会有一个 Dep 类，访问属性的时候 get 方法会收集对应的 watcher

同样渲染 watcher 也会收集对应的 Dep

vue 内部实现双向绑定过程：**简单来说就是初始化 data 的时候会调用 observe 方法给data 里的属性重写 get 方法和 set 方法，到渲染真实 dom 的时，渲染 watcher 会去访问页面上使用的属性变量，给属性的 Dep 都加上渲染函数，每次修改数据时通知渲染 watcher 更新视图**



#### initState

依次初始化props, methods, data, computed, watch

```js
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}

function initData (vm: Component) {
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  // 判断是否为对象 Object.prototype.toString.call(obj) === '[object Object]'
  ...
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    ...
      proxy(vm, `_data`, key) //把 vm._data.xxx 的访问代理到 vm.xxx 上
    ...
  }
  // observe data
  observe(data, true /* asRootData */) // 为data添加观察者，这样修改就能触发更新
```





#### Observer数据观测

1.在vue入口调用了initMixin方法，该方法主要实现了往vue原型上挂载了_init方法
2.在vue实例化时调用_init方法，在_init方法内又初始化了**initState** 方法，该方法主要对options对象的data数据进行初始观测
3.下面接着分析Observer

1.observer的实现主要是对传入的data 进行代理，将data代理到vue实例的_data上
2.对data的key进行遍历，将每个key通过Object.definedProperty挂载到vm实例上

打开 **src/core/observer/index.js**

**observer核心逻辑**

![img](D:\typora-img\19227237-8fbe7dd34d8bcb06.png)

```js
/*
1.在Observer实例化时会调用walk函数
2.在walk函数内，主要主要对obj的可以进行遍历，调用defineReactive方法
3.defineReactive 函数实现对数据观测，在get中实现对数据依赖的收集，在set中通过收集的依赖取触发通知
*/

export function observe(data) {
	// 不是对象或者数组直接 return
    if (typeof data !== 'object' || data == null) {
        return
    }
    // 这里的 data 就是创建 vue 传入的 data 属性
    return new Observer(data)
}

// 代码位置 vue\src\core\observer\index.js
export class Observer {
  value: any; 
  dep: Dep;
  vmCount: number; // 关联的vue实例个数

  constructor (value: any) {
    this.value = value
    this.dep = new Dep() // 每个ob对象也有一个dep对象
    this.vmCount = 0
      // def是defineProperty方法的封装
      // 为数据对象设置一个__ob__属性，并赋值为当前Observer实例， 标记对象是否已被观察
    def(value, '__ob__', this)
      // 数组特殊处理 重写数组的各种原型链方法，在调用这些方法时触发dep.notify()
    if (Array.isArray(value)) {
      if (hasProto) { // 判断对象的__proto__属性是否可用
        protoAugment(value, arrayMethods) // 扩充原型链
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      this.observeArray(value) // value是数组，对数组每个元素继续执行observe
    } else {
      this.walk(value) // value是对象时才建立观察
    }
  }

  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}

export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean // 是否浅层观察，一般都是深层观察
) {
    // 为每个属性生成唯一dep对象
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  const getter = property && property.get
  const setter = property && property.set
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }
 // 递归调用observe，处理value还是对象的情况，深度监听子对象中的属性
  let childOb = !shallow && observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      /*
      Dep.target: 依赖收集标识，模板挂载时实例化一个watcher,会调用getter给Dep.target赋值为当前实例的this
      渲染的期间给每个放在页面上的变量添加 watcher，非渲染阶段没有Dep.target 所以正常访问不会进行依赖收集
      */
      if (Dep.target) {
        dep.depend()
          // childOb存在表示当前的 val 还是一个对象或者数组
        if (childOb) {
          childOb.dep.depend() // 对这个对象进行依赖收集
          if (Array.isArray(value)) {
            dependArray(value) // 数组元素依赖收集
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow && observe(newVal) // 新值是对象，对新值设置观察
      dep.notify()
    }
  })
}

 // 当数组被触摸时，收集对数组元素的依赖关系，因为数组元素无法使用defineProperty方法
  function dependArray(value) {
    for (let e, i = 0, l = value.length; i < l; i++) {
      e = value[i]
      if (e && e.__ob__) { // 有__ob__属性表示是一个ob对象
        e.__ob__.dep.depend() // 为数组元素的__ob__对象进行收集依赖
      }
      // 数组嵌套则递归收集依赖
      if (Array.isArray(e)) {
        dependArray(e)
      }
    }

```

#### Dep依赖收集

3.1. 在vue数据get获取中，谁读取了该数据，就把它收集起来，所以dep是一个集合，在数据set时，通过遍历dep去触发每个dep的notify方法通过视图更新
3.2. dep的主要功能是只作为收集，那在收集了依赖后，如何使视图更新呢
3.3. 所以需要定义一个新的Watcher类，该类是会实现对视图的更新
3.4. dep每收集的一个依赖实际就是一个Watcher

在dep类中subs就是收集Watcher的一个集合
addSub 为添加依赖的方法
notify 为依赖通知的方法
depend 该方法为主要的方法，在Observer的get中将会调用该方法进行收集 （该方法中的Dep.target是一个判断依赖收集标识，Dep.target将会在模板挂载时，实例化一个Watcher,在Watcher实例化时会调用getter,会给Dep.target赋值为当前实例的this,因此在对数获取触发get时，Dep.target是存在的，所以Watcher就不收集了）

Dep 类的实现**src/core/observer/dep.js**

```js
export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array<Watcher>;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

  depend () {
    if (Dep.target) {
      Dep.target.addDep(this) // 依赖收集，调用watcher的addDep， addDep内会调用dep.addSub(watcher) 把watcher放到subs内进行依赖收集
    }
  }

  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    if (process.env.NODE_ENV !== 'production' && !config.async) {
      // subs aren't sorted in scheduler if not running async
      // we need to sort them now to make sure they fire in correct
      // order
      subs.sort((a, b) => a.id - b.id)
    }
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update() // 触发更新，调用watcher的update方法
    }
  }
}


```



#### **watcher** 完整代码

4.1. Watcher的功能主要是接到Dep的通知，然后调用update方法更新视图

4.2. 在update方法中会触发回调，回调函数实际就是已生成render函数

4.3. 在调用render函数是，函数里的值就会获取到已经更改后值，所以就会生成新的vnode
4.4. 新的vnode生成后，就是patch的过程，用新的vnode与旧的vnode进行比对，最终将比对后的vnode转换为实际的dom添加到模板挂载节点上
4.5.新的模板挂载后，将旧的模板删除，这样视图就更新完成

代码分析：

1.在Watcher实例构造函数执行时，会触发get
2.触发了get后就会该Watcher实例进行收集
3.update为接到Dep通知时触发的方法
4.update内会调用run方法
5.在run方法内会调用cb回调方法
6.cb回到方法实际就是模板编译时render方法

```js
// 代码位置 vue\src\core\observer\watcher.js
export default class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  deep: boolean;
  user: boolean;
  lazy: boolean;
  sync: boolean;
  dirty: boolean;
  active: boolean;
  deps: Array<Dep>;
  newDeps: Array<Dep>;
  depIds: SimpleSet;
  newDepIds: SimpleSet;
  before: ?Function;
  getter: Function;
  value: any;

  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this)
    // options
    if (options) {
      this.deep = !!options.deep
      this.user = !!options.user
      this.lazy = !!options.lazy
      this.sync = !!options.sync
      this.before = options.before
    } else {
      this.deep = this.user = this.lazy = this.sync = false
    }
    this.cb = cb
    this.id = ++uid // uid for batching
    this.active = true
    this.dirty = this.lazy // for lazy watchers
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString()
      : ''
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = noop
        process.env.NODE_ENV !== 'production' && warn(
          `Failed watching path: "${expOrFn}" ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get()
  }

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  get () {
    pushTarget(this)
    let value
    const vm = this.vm
    try {
      value = this.getter.call(vm, vm)
    } catch (e) {
      if (this.user) {
        handleError(e, vm, `getter for watcher "${this.expression}"`)
      } else {
        throw e
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value)
      }
      popTarget()
      this.cleanupDeps()
    }
    return value
  }

  /* Observer内get依赖收集时判断: if(dep.target) dep.depend()
  	Dep.target在模板挂载时实例化一个Watcher，所以dep.depend本质是调用Dep.target.addDep(this) 也就是下面这个方法
  */
  addDep (dep: Dep) {
    const id = dep.id
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      if (!this.depIds.has(id)) {
        dep.addSub(this)  // 把watcher放到了dep的subs数组内
      }
    }
  }

  /**
   * Clean up for dependency collection.
   */
  cleanupDeps () {
    let i = this.deps.length
    while (i--) {
      const dep = this.deps[i]
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this)
      }
    }
    let tmp = this.depIds
    this.depIds = this.newDepIds
    this.newDepIds = tmp
    this.newDepIds.clear()
    tmp = this.deps
    this.deps = this.newDeps
    this.newDeps = tmp
    this.newDeps.length = 0
  }

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      queueWatcher(this)
    }
  }

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
  run () {
    if (this.active) {
      const value = this.get()
      if (
        value !== this.value ||
        isObject(value) ||
        this.deep
      ) {
        // set new value
        const oldValue = this.value
        this.value = value
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher "${this.expression}"`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue) // cb就是模板编译时render方法
        }
      }
    }
  }

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
  evaluate () {
    this.value = this.get()
    this.dirty = false
  }

  /**
   * Depend on all deps collected by this watcher.
   */
  depend () {
    let i = this.deps.length
    while (i--) {
      this.deps[i].depend()
    }
  }

  /**
   * Remove self from all dependencies' subscriber list.
   */
  teardown () {
    if (this.active) {
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this)
      }
      let i = this.deps.length
      while (i--) {
        this.deps[i].removeSub(this)
      }
      this.active = false
    }
  }
}
```



### watch三类监听

1.模板渲染watcher

2.用户自定义watcher (自己传入的watch监听函数)

3.计算属性watcher



### watch监听实现

打开**src/core/instance/state.js**找到**initWatch**

调用链：createWatcher ==> $watch ==> new Watcher创建了一个watcher类，watch的回调函数最后传给new Watcher中的cb

```js
function initWatch(vm) {
	//获取到传入的 watch
    let watch = vm.$options.watch
    //遍历 watch 列表
    for (let key in watch) {
        const handler = watch[key];
        //可以传入数组
        if (Array.isArray(handler)) {
            for (let i = 0; i < handler.length; i++) {
              createWatcher(vm, key, handler[i])
            }
        } else {
        	//创建 watch
            createWatcher(vm, key, handler)
        }
    }
}
function createWatcher(vm, expOrFn, handler, options) {
		// handler 如果是对象取出里面的 handler 函数
        if (typeof handler === "object") {
            options = handler
            handler = handler.handler
        }
        //如果监听的方法是 methods 里的方法直接取出来
        if (typeof handler === 'string') {
            handler = vm[handler]
        }
      return vm.$watch(expOrFn, handler, options)
}
Vue.prototype.$watch = function (expOrFn, cb, options) {
        let vm = this;
        options = options || {};
        //标识这个是用户 watch
        options.user = true;
        //使用 Watcher 类来创建渲染 Watcher
        const watcher = new Watcher(vm, expOrFn, cb, options);
}
```

#### 监听watcher类实现

核心也是利用 watcher 和 dep 两个类来实现的。

区别就是这次 watcher 保留的是用户传入的 watch 回调函数，依赖发生更新时调用函数，传入新值和旧值`if (this.user) { this.cb.call(this.vm, newValue, oldValue) }`

```js
export class Watcher {
    constructor(vm,expOrFn,cb,options) {
        this.vm = vm
        this.expOrFn = expOrFn //监听的属性 如：a.b.c
        this.cb = cb // watch 回调
        if (options) {
            this.user = !!options.user //这是个 watch
            this.deep = !!options.deep //深度监听
        }
        this.deps = [];
        this.set = {}
        this.id = id++
        function parsePath(path) {
		    path = path.split('.')
		    return function (obj) {
		        path.forEach((key) => {
		            obj = obj[key] // 获取对象的深层属性值，直到获取到最后的值 如a.b.c
		        })
		        return obj
		    }
		}
        if (typeof expOrFn === 'function') {
            this.getters = expOrFn
        } else {
        	// 返回一个遍历监听属性的方法，赋值给getter
            this.getters = parsePath(this.expOrFn)
        }
        //留住 value
        this.value = this.get();
    }
    get() {
    	//深度访问对象内部每一个值
    	function traverse(val) {
		    let isA = Array.isArray(val);
		    if (!isA) {
		        let key = Object.keys(val);
		        let i = key.length
		        while (i--) {
		            traverse(val[key])
		        }
		    }
		}
        //标记target 
        pushTarget(this)
        //访问监听的属性 如a.b.c 此时触发dep.depend，添加watcher收集依赖
        let value = this.getters.call(this.vm, this.vm);
        if (this.deep) {
            traverse(value)
        }
        // 移除target
        popTarget()
        return value
    }
    run() {
        let newValue = this.get()
        //取出旧值
        const oldValue = this.value
        //留住新值
        this.value = newValue
        //用户自己传入的watch
        if (this.user) {
        	//这里的 cb 就是传入的 watch 回调函数
             this.cb.call(this.vm, newValue, oldValue)
        }
    }
    addDep(dep) {
        let id = dep.id
        //去重防止dep添加watch多次
        if (!this.set[id]) {
            //watcher添加dep
            this.deps.push(dep)
            //给dep添加watch
            dep.addSub(this)
            this.set[id] = true;
        }
    }
    update() {
        this.run()
    }
}
```



### computed实现

打开**src/core/instance/state.js**找到**initComputed**

```js
function initComputed(vm) {
	//获取传入的 computed
    let computed = vm.$options.computed;
    //创建一个 watchers 空对象
    const watchers = vm._computedWatchers = Object.create(null)
    //遍历 computed
    for (const key in computed) {
    	//拿到计算属性方法
        const userDef = computed[key];
        // 创建 Watcher lazy:true 默认不执行 ，看是否需要重新计算，computed 是有缓存的
        watchers[key] = new Watcher(vm, userDef, ()=>{}, {lazy:true});
        //监听 computed 方法
        defineComputed(vm, key, userDef)
    }
}
let sharedPropertyDefinition = {}
function defineComputed(target, key, userDef) {
    if (typeof userDef === 'function') {
    	//传入的是方法走这里
        sharedPropertyDefinition.get = createComputedGetter(key)
        sharedPropertyDefinition.set = ()=>{}
    } else {
    	//也可以传入一个对象，有 set 方法
        sharedPropertyDefinition.get = createComputedGetter(key)
        sharedPropertyDefinition.set = userDef.set
    }
    //包装计算属性的方法名，给 vm 上添加 computed 方法
    Object.defineProperty(target, key, sharedPropertyDefinition)
}
function createComputedGetter(key) {
	//重点！模板上访问计算属性才走这里
    return function () {
    	// 取出创建的 computedWatchers
        let watch = this._computedWatchers[key];
        // dirty = lazy 默认是 true
        if (watch.dirty) {
            //渲染的时候会进入这里
            watch.evaluate()
        }
        //此时渲染还未结束 Dep.target = 渲染 watcher，computed 函数内部的变量收集渲染 watcher
        if (Dep.target) {
            watch.depend()
        }
        //计算好的参数返回给用户
        return watch.value
    }
}
```

#### 计算属性watcher类实现

重点：计算属性方法内部变量的 Dep 上会有两个 watcher 分别是是计算属性 wathcer 和渲染 watcher，计算属性 watcher 的作用只需要控制是否需要重新计算，跟着调用依赖的渲染 watcher 重新计算属性

```js
/*
核心流程：
1.初始化时lazy=true 未执行任何操作，渲染时，当模板访问计算属性时调用computed.get的方法(createComputedGetter返回的函数)，因为dirty=true， 会调用watch.evaluate()
2.evaluate内调用get(),再设置dirty=false
3.get内添加计算属性watcher, 调用用户传入的computed方法，获得返回值，过程中会进行计算属性Watcher依赖收集
4.渲染过程中，渲染watcher一直存在，所以会继续调用watch.depend()
调用链:watch.depend() --> deps[i].depend() --> Dep.target.addDep(dep) --> dep.addSub(watcher) 
目的：给计算属性的dep再添加渲染watcher

触发：触发更新，dep有2个watcher, 先调计算属性watcher把dirty改成true,接着调渲染watcher, 会调用computed.get触发evaluate()重新计算属性值进行返回
*/

export class Watcher {
    constructor(vm,expOrFn,cb,options) {
        this.vm = vm
        this.expOrFn = expOrFn //传入的 computed 方法
        this.cb = cb
        if (options) {
            this.lazy = !!options.lazy // true 默认不执行 这是一个 computed
        }
        this.dirty = this.lazy// computed 看是否需要从新求值
        this.deps = [];
        this.set = {}
        this.id = id++
        if (typeof expOrFn === 'function') {
            this.getters = expOrFn
        }
        //留住value
        this.value = this.lazy? undefined : this.get();
    }
    get() {
        //标记 computed target
        pushTarget(this)
        // 调用 computed 函数得到计算的值
        let value = this.getters.call(this.vm, this.vm);
        //弹出 target 防止data上每个属性都产生依赖，只有页面上使用的变量需要依赖
        popTarget()
        return value
    }
    run() {
        let newValue = this.get()
    }
    addDep(dep) {
        let id = dep.id
        //去重防止dep添加watch多次
        if (!this.set[id]) {
            //watcher添加dep
            this.deps.push(dep)
            //给dep添加watch
            dep.addSub(this)
            this.set[id] = true;
        }
    }
    update() {
    	//修改属性计算属性依赖的变量重置 dirty 
        if (this.lazy) {
            this.dirty = true
        }
    }
    evaluate() {
    	//当走到这里时，页面正在渲染中 Dep.target 已经有一个渲染 watcher 了
        this.value = this.get();
        //修改了计算属性里面脏值
        this.dirty = false
    }
    depend () {
    	//给 computed 函数内部的属性添加渲染 watcher
        let i = this.deps.length
        while (i--) {
            // 此时的Dep.target是渲染Watcher，调用dep.depend() --> Dep.target.addDep(this) 
            this.deps[i].depend() 
        }
    }
}
```









### MVVM和MVC

MVVM (model-view-ViewModel)，`MVVM` 是一种设计思想。`Model` 层代表数据模型，也可以在 `Model` 中定义数据修改和操作的业务逻辑；`View` 代表UI 组件，它负责将数据模型转化成 UI 展现出来；`ViewModel` 是一个同步 `View` 和 `Model` 的对象。

ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。


`MVC` 和 `MVVM` 其实区别并不大，都是一种设计思想。主要就是 `MVC` 中`Controller` 演变成 `MVVM` 中的 `viewModel`。`MVVM` 主要解决了 `MVC` 中大量的 `DOM` 操作使页面渲染性能降低，加载速度变慢，影响用户体验。



### 介绍VUE的响应式系统

Vue 为 MVVM 框架，当数据模型 data 变化时，页面视图会得到响应更新，其原理对 data 的 getter/setter 方法进行拦截（Object.defineProperty 或者Proxy），利用发布订阅的设计模式，在 getter 方法中进行订阅，在 setter 方法中发布通知，让所有订阅者完成响应。

在响应式系统中，Vue 会为数据模型 data 的每一个属性新建一个订阅中心作为发布者，而监听器 watch、计算属性 computed、视图渲染 template/render三个角色同时作为订阅者，对于监听器 watch，会直接订阅观察监听的属性，对于计算属性 computed 和视图渲染 template/render，如果内部执行获取了 data 的某个属性，就会执行该属性的 getter 方法，然后自动完成对该属性的订阅，当属性被修改时，就会执行该属性的 setter 方法，从而完成该属性的发布通知，通知所有订阅者进行更新。



### Vue如何创建自定义指令







###  Vue 如何实现按需加载配合 webpack 设置？

webpack 中提供了 require.ensure() 来实现按需加载。

以前引入路由是通过 import 这样的方式引入，现在改为 const 定义的方式进行引入。

页面不按需加载引入方式：

````js
import home from '../../common/home.vue'
````



页面按需加载引入方式：

```js
const home = r => require.ensure( [], () => r (require('../../common/home.vue')))
```



### Vue生命周期





### computed和watch区别

相同点：

计算属性 computed 和监听器 watch 都可以观察属性的变化从而做出响应。
不同点：

计算属性 computed 更多是作为缓存功能的观察者，它可以将一个或者多个 data 的属性进行复杂的计算生成一个新的值，提供给渲染函数使用，当依赖的属性变化时，computed 不会立即重新计算生成新的值，而是先标记为当前数据，当下次 computed 被获取时候，才会进行重新计算并返回。也就是说：computed 只有当依赖的数据变化时才会计算，会缓存数据。

监听器 watch 并不具备缓存性，监听器 watch 提供一个监听函数，当监听的属性发生变化时，会立即执行该函数。watch 更适用于数据变化时的异步操作。





### Vuex



### Vue-Router

**原理：两种匹配模式**

1.`Hash`模式是基于锚点，通过锚点值作为路由地址，**监听浏览器hashChange事件**，触发不同组件的切换显示， **hash改变不会触发浏览器请求**。

2.`history`模式基于html5的History API,  **2个核心方法：history.pushState() | history.replaceState(),**

页面跳转是通过`history.pushState( ) `方法来修改地址栏中的地址，实现组件的切换，而且还会把地址保存的历史记录中（也就是可以单击浏览器中后退按钮，实现后退等操作），但是它并不会向服务器发送请求。但是刷新页面就会报404， **需要服务端支持**

为什么需要服务端支持：

在单页应用中，如访问/login这个地址时如刷新了页面，会真实向服务器发送/login请求，服务器没有该资源就会报404错误

服务端如何支持：

Node服务端：安装connect-history-api-fallback 模块，**所有url都返回index.html这个页面**

nginx反向代理：

```txt
 location / {
            root   html;
            index  index.html index.htm;
			try_files $uri $uri/ /index.html; // 没找到资源就返回Index.html
        }

```

**简单源码逻辑：**

```js
// 1. 实现install方法  Vue.use(Router) 中会调用Router.install
let _Vue = null;
export default class VueRouter {
 // VueRouter的静态方法，在Vue.use中被调用
  static install(Vue) {
    //首先判断插件是否已经被安装，如果已经被安装，就不需要重复安装。   
    //1、判断当前插件是否已经被安装:  
    if (VueRouter.install.installed) {
      //条件成立，表明插件已经被安装，什么都不要做。
      return;
    }
    VueRouter.install.installed = true;
    //2、把Vue构造函数记录到全局变量中。
    _Vue = Vue;

    //3、核心步骤：在beforeCreate回调函数上上进行router的获取和初始化，把创建Vue实例时候传入的router对象注入到Vue实例上。
    _Vue.mixin({
        // 混入的同名钩子函数会合并为数组，都会被调用，混入的钩子优先于组件自身钩子函数执行
      beforeCreate() {
        //在创建Vue实例的时候
        // 也就是new Vue()的时候，才会有$options这个属性，
        //组件中是没有$options这个属性的。
        if (this.$options.router) {
          _Vue.prototype.$router = this.$options.router
          this._routerRoot = this
          this._router = this.$options.router
          this._router.init(this) // VueRouter初始化 初始化中监听hash或history
          this._router.initComponent(this) // 注册router-view, router-link 两个组件
          // 关键2：注册响应式属性_route 当路由改变时，执行rerender
          // 在Vue的实例上创建一个响应式的属性`_route`.
          Vue.util.defineReactive(this, "_route", this._router.history.current);
        }
      }
    })
  }
    // 2.VueRouter构造函数,该该构造方法中会初始化options ,data,routeMapt这几个属性。
  constructor(options) {
    this.options = options;
    this.routeMap = {};
    this.data = _Vue.observable({
      current: "/",
    }); 
      // 关键：创建路由映射表
    this.matcher = createMatcher(options.routes || [], this)
     
     // 根据mode 采用不同的路由方式
     let mode = options.mode || 'hash'
     this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false
     if (this.fallback) mode = 'hash'
     this.mode = mode
     switch (mode) {
         case 'history':
             this.history = new HTML5History(this, options.base)
             break;
         case 'hash':
             this.history = new HashHistory(this, options.base, this.fallback)
             break;
         case 'abstract': // 略
     }
  }
  // 注册路由变化的事件(初始化事件监听器，监听路由地址的变化)
  // init中会调用构造函数根据mode创建的hashHistory或HTMLHistory
  init(Vue) {
    const history = this.history;
    const setUpListener = () => {
      history.setUpListener();
    };
    history.transitionTo(
      history.getCurrentLocation(),
      //如果直接history.setUpListener
      // 这样的话setUpListener里面的this会有问题。
      setUpListener
    )
    //调用父类的中的listen方法，改变_route的值 route响应式更新关键
    history.listen((route) => {
      Vue._route = route;
    });
  }
    
 // 4.实现initComponent 该方法用来创建<router-link> <router-view>两个全局组件
 initComponents(Vue) {
   Vue.component("router-link", {
      props: {
        to: String,
      },
      // template: '<a :href="to"><slot></slot></a>',
      render(h) {
        return h(
          "a",
          {
            attrs: {
              href: this.to,
            },
            on: {
              click: this.clickHandler, // a标签点击事件
            },
          },
          [this.$slots.default]
        );
      },
      methods: {
        clickHandler(e) {
          history.pushState({}, "", this.to);
          this.$router.data.current = this.to;
          // a标签默认行为阻止， 阻止向服务器发送器。 
          e.preventDefault();
        },
      },
    });
     
     // router-view组件
     Vue.component("router-view", {
		  render(h) {
            //获取当前匹配的路由规则对象
            const route = this.$route;
            let depth = 0;
            //记录当前组件为RouterView
            this.routerView = true;
            let parent = this.$parent;
            while (parent) {
              if (parent.routerView) {
                depth++;
              }
              parent = parent.$parent;
            }
            //获取路由记录对象.
            // 如果是子路由，例如：子路由/about/users
            //子路由是有两部分内容，matched[0]:是父组件内容，matched[1]是子组件内容
            const record = route.matched[depth];
            if (!record) {
              return h();
            }
            //获取记录中对应的组件
            const component = record.component;
            return h(component);
          }
    });
  }
}


// createMatcher实现 作用是创建路由映射表，然后使用闭包的方法让 addRoutes 和 match 函数能够使用路由映射表的几个对象，最后返回一个 Matcher 对象。
function createMatcher(routes, router) {
    // 创建路由映射表
    const {pathList, pathMap, nameMap} = createRouteMap(routes)
    
    // 闭包方式让addRoutes，可以使用pathList,pathMap,NameMap这几个对象
    function addRoutes(routes) {
        createRouteMap(routes, pathList, pathMap, nameMap)
    }
    // match这个方法的作用就是根据路径，创建出路由规则对象，而所谓的路由规则对象其实就是包含了路径以及对应的路由记录的信息(这里有可能包含了父路由以及子路由记录，这块内容存储到一个数组中)。
    function match(path) {
        const record = pathMap[path];
        if (record) {
          //根据路由地址，创建route路由规则对象
          return createRoute(record, path);
        }
        return createRoute(null, path);
    }
    
    function redirect(record, location) {...}
    
    function alias(record, location, matchAs) {...}
    
    function _createRoute(record, location, redirectedFrom) {...}
    
    // 返回的matcher对象， 包含match方法和addRoutes方法
    return {
        match,
        addRoutes
    }
}

// 简化版！ 3.该方法把构造函数中传入进来的options参数中的路由规则，转换成键值对的形式存储到routeMap中。 键就是路由的地址，值就是对应的组件
function createRouteMap() { 
    this.options.routes.forEach((route) => {
      this.routeMap[route.path] = route.component;
    });
  }

export default function createRoute(record, path) {
  const matched = [];
  while (record) {
    matched.unshift(record);
    record = record.parent;
  }
  return {
    path,
    matched,
  }
}


                                               
 /*============== History和HashHistory ========================*/
                                               
import createRoute from "../util/route";
export default class History {
  // router路由对象ViewRouter
  constructor(router) {
    this.router = router;
    this.current = createRoute(null, "/");
    //这个回调函数是在hashhistory中赋值，作用是更改vue实例上的_route，_route的值发生变化，视图会进行刷新操作
    this.cb = null;
  }
    
  listen(cb) {
    this.cb = cb;
  }
  transitionTo(path, onComplete) {
    this.current = this.router.matcher.match(path);
    this.cb && this.cb(this.current);
    //该回调函数在调用transitionTo方法的时候，会传递过来。
    onComplete && onComplete();
  }
}

import History from "./base";
export default class HashHistory extends History {
  constructor(router) {
    //将路由对象传递给父类的构造函数
    super(router);
    //确保 首次 访问地址加上 #/  （//由于没有添加this,为普通方法）
    ensureSlash();
  }
  // 获取当前的路由地址 （# 后面的部分）所以这里需要去除#
  getCurrentLocation() {
    return window.location.hash.slice(1);
  }
  // 监听hashchange事件
  //也就是监听路由地址的变化
  setUpListener() {
    window.addEventListener("hashchange", () => {
      //当路由地址发生变化后，跳转到新的路由地址。
      this.transitionTo(this.getCurrentLocation());
    });
  }
}

function ensureSlash() {
  //判断当前是否有hash
  // 如果单击的是链接，肯定会有hash
  if (window.location.hash) {
    return;
  }
  
  window.location.hash = "/";
}


```



#### 简化流程

```txt
页面渲染
1、Vue.use(Router) 注册
2、注册时调用 install 方法混入生命周期，定义 router 和 route 属性，注册 router-view 和 router-link 组件
3、生成 router 实例，根据配置数组(传入的routes)生成路由配置记录表，根据不同模式生成监控路由变化的History对象
4、生成 vue 实例，将 router 实例挂载到 vue 实例上面，挂载的时候 router 会执行最开始混入的生命周期函数
5、初始化结束，显示默认页面
路由点击更新
1、 router-link 绑定 click 方法，触发 history.push 或 history.replace ，从而触发 history.transitionTo 方法
2、transitionTo 用于处理路由转换，其中包含了 updateRoute 用于更新 _route
3、在 beforeCreate 中有劫持 _route 的方法，当 _route 变化后，触发 router-view 的变化
地址变化路由更新
1、HashHistory 和 HTML5History 会分别监控 hashchange 和 popstate 来对路由变化作对用的处理
2、HashHistory 和 HTML5History 捕获到变化后会对应执行 push 或 replace 方法，从而调用 transitionTo
3、然后更新 _route 触发 router-view 的变化
```





动态路由，动态参数

几种导航钩子

vue-router中使用active-class的方法，碰到过什么问题



**keep-alive** 

组件缓存





### scss

是一个css的预编译语言	

使用步骤：
先装 css-loader、node-loader、sass-loader 等加载器模块；
在 build 目录找到 webpack.base.config.js，在 extends 属性中加一个拓展 .scss；
在同一个文件，配置一个 module 属性；
然后在组件的 style 标签加上 lang 属性 ，例如：lang=”scss” 





### key的作用

答案1：当有相同标签名的元素切换时，为避免渲染问题，需要通过 key 特性设置唯一的值，来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。
答案2：key 是给每一个 vnode 的唯一 id，可以依靠 key，更准确，更快的拿到 oldVnode 中对应的 vnode 节点





### SSR(服务端渲染)

原理很简单，就是服务端直接渲染出 HTML 字符串模板，浏览器可以直接解析该字符串模版显示页面，因此首屏的内容不再依赖 Javascript 的渲染（CSR - 客户端渲染）

SSR 的核心优势：

1. 首屏加载时间：因为是 HTML 直出，浏览器可以直接解析该字符串模版显示页面。
2. SEO 友好：正是因为服务端渲染输出到浏览器的是完备的 html 字符串，使得搜索引擎 能抓取到真实的内容，利于 SEO。

SSR 需要注意的问题：

1. 虽然 SSR 能快速呈现页面，但是在 UI 框架（比如 React）加载成功之前，页面是没法进行 UI 交互的。
2. TTFB (Time To First Byte)，即第一字节时间会变长，因为 SSR 相对于 CSR 需要在服务端渲染出更对的 HTML 片段，因此加载时间会变长。
3. 更多的服务器端负载。由于 SSR 需要依赖 Node.js 服务渲染页面，显然会比仅仅提供静态文件的 CSR 应用需要占用更多服务器 CPU 资源。以 React 为例，它的 `renderToString()` 方法是同步 CPU 绑定调用，这就意味着在它完成之前，服务器是无法处理其他请求的。因此在高并发场景，需要准备相应的服务器负载，并且做好缓存策略。

**Vue SSR原理图**

1、对于同构开发，我们依然使用`webpack`打包，我们要解决两个问题：服务端首屏渲染和客户端激活

2、这里需要生成一个服务器`bundle`文件用于服务端首屏渲染和一个客户端`bundle`文件用于客户端激活

![img](D:\typora-img\60c5a0e9a65d575053e26236969cac74.png)







### Serverless

它是云计算发展过程中出现的**一种计算资源的抽象**，依赖第三方服务，开发者可以更加专注的开发自己的业务代码，而无需关心底层资源的分配、扩容和部署。

特点：

1. 开发者只需要专注于业务，无需关心底层资源的分配、扩容和部署
2. 按需使用和收费
3. 自动扩缩容



### **Serverless + SSR**

结合 Serverless 和 SSR 的特点，我们可以发现他们简直是天作之合。借助 Serverless，前端团队无需关注 SSR 服务器的部署、运维和扩容，可以极大地减少部署运维成本，更好的聚焦业务开发，提高开发效率。

同时也无需关心 SSR 服务器的性能问题，理论上 Serverless 是可以无限扩容的（当然云厂商对于一般用户是有扩容上限的）。





### Vue模板渲染原理

Vue 中的模板 template 无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的 HTML 语法，所以需要将 template 转化成一个 JavaScript 函数，这样浏览器就可以执行这一个函数并渲染出对应的 HTML 元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。

模板编译又分三个阶段，解析parse，优化 optimize，生成 generate，最终生成可执行函数 render。

解析parse阶段：使用大量的正则表达式对 template 字符串进行解析，将标签、指令、属性等转化为抽象语法树 AST。
优化 optimize阶段：遍历 AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行 diff 比较时，直接跳过这一些静态节点，优化 runtime 的性能。
生成 generate阶段：将最终的 AST 转化为 render 函数字符串。



### template预编译是什么

对于 Vue 组件来说，模板编译只会在组件实例化的时候编译一次，生成渲染函数之后在也不会进行编译。因此，编译对组件的 runtime 是一种性能损耗。

而模板编译的目的仅仅是将 template 转化为 render function，这个过程，正好可以在项目构建的过程中完成，这样可以让实际组件在 runtime 时直接跳过模板渲染，进而提升性能，这个在项目构建的编译 template 的过程，就是预编译。



### template和jsx区别

对于 runtime 来说，只需要保证组件存在 render 函数即可，而我们有了预编译之后，我们只需要保证构建过程中生成 render 函数就可以。

在 webpack 中，我们使用 vue-loader 编译 .vue 文件，内部依赖的 vue-template-compiler 模块，在 webpack 构建过程中，将 template 预编译成 render 函数。

与 React 类似，在添加了 jsx 的语法糖解析器 babel-plugin-transform-vue-jsx 之后，就可以直接手写 render 函数。

所以，template 和 jsx 的都是 render 的一种表现形式，不同的是：

JSX 相对于 template 而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞，但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。





### 响应式布局和自适应布局





### 设计模式