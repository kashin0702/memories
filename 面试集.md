### js数据类型判断

1. typeof 

   typeof返回一个表示数据类型的字符串，返回结果包括：number、string、boolean、object、undefined、function。typeof可以对基本类型number、string 、boolean、undefined做出准确的判断。null除外，typeof null===“object”  历史原因

2. instanceof

   当我们需要知道某个对象的具体类型时,可以用运算符 instanceof，instanceof操作符判断左操作数对象的原型链上是否有右边这个构造函数的prototype属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值。

   ```js
   /* 
   虽然 instanceof 能够判断出 [] 是Array的实例，但它认为 [] 也是Object的实例， 我们来分析一下[]、Array、Object 三者之间的关系: 从instanceof 能够判断出 [].__proto__ 指向 Array.prototype， 而 Array.prototype.__proto__ 又指向了Object.prototype，Object.prototype.__proto__ 指向了null,标志着原型链的结束。因此，[]、Array、Object就形成了如下图所示的一条原型链：
   从原型链可以看出，[] 的 __proto__  直接指向Array.prototype, 间接指向Object.prototype, 所以按照 instanceof 的判断规则，[] 就是Object的实例。
   */
   [] instanceof Array; //true
   [] instanceof Object; //true
   new Date() instanceof Date;//true
   new Date() instanceof Object;//true
   function Person(){};
   new Person() instanceof Person;//true
   new Person() instanceof Object;//true
   
   ```

   

3. constructor

   constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。

```js
var f = new F();
f.constructor === F;// true

//但是 constructor 属性易变，不可信赖，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor会丢失。
function F() {}
F.prototype = {
	_name: 'Eric',
};
var f = new F();
f.constructor === F; // false

//因此，为了规范，在重写对象原型时一般都需要重新给constructor赋值，以保证实例对象的类型不被改写。
function F() {}
F.prototype = {
    constructor: F, 
   _name: 'Eric',
};
var f = new F();
f.constructor === F; // true 
```



4.Object.prototype.toString 

```js
//toString是Object原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString运行时this指向的对象类型, 返回的类型格式为[object,xxx],xxx是具体的数据类型
Object.prototype.toString.call('') ;   // [object String]
Object.prototype.toString.call(1) ;    // [object Number]
Object.prototype.toString.call(true) ; // [object Boolean]
Object.prototype.toString.call(undefined) ; // [object Undefined]
Object.prototype.toString.call(null) ; // [object Null]
Object.prototype.toString.call(new Function()) ; // [object Function]
Object.prototype.toString.call(new Date()) ; // [object Date]
Object.prototype.toString.call([]) ; // [object Array]
Object.prototype.toString.call(new RegExp()) ; // [object RegExp]
Object.prototype.toString.call(new Error()) ; // [object Error]
Object.prototype.toString.call(document) ; // [object HTMLDocument]
Object.prototype.toString.call(window) ; //[object Window]
```





### xhr和fetch区别

都是异步请求网络数据的方法，xhr通过`new XMLHttpRequest()`创建一个 XHR 对象；fetch是原生js方法，基于promise对象处理异步请求

fetch工作原理：

1. 使用`fetch()`函数创建请求：传入要请求的 URL，以及可选的配置参数，例如请求方法、请求头等。
2. 处理响应：`fetch()`返回一个 Promise，您可以使用`.then()`链式调用来处理响应数据，例如使用`.json()`方法解析 JSON 数据或`.text()`方法获取文本数据。
3. 错误处理：您可以使用`.catch()`方法来捕获任何请求或响应的错误。
4. 使用`async/await`：如果需要，您还可以使用`async/await`来更清晰地处理异步操作。

```js
    const formDate = new FormData()
    formDate.append("name","1111")
    async function getData(){
        const response = await fetch("http://123.207.32.32:1888/02_param/postform",{
            method:"post",
            // headers:{
            //     "Content-type":"application/json"
            // },
            body:formDate
        })
        const res = await response.json()
        console.log(res)
    }
    getData()
```





### new 一个函数发生了什么

构造调用：

创造一个全新的对象实例
这个对象会被执行 [[Prototype]] 连接，将这个新对象的\__proto__链接到这个构造函数 .prototype 所指向的对象
这个新对象会绑定到函数调用的 this
如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象





### 作用域

全局作用域，函数作用域



### 闭包

闭包是指有权访问另外一个函数作用域中的变量的函数

闭包是一种特殊的对象，它由两部分组成：执行上下文（代号 A），以及在该执行上下文中创建的函数 （代号 B），当 B 执行时，如果访问了 A 中变量对象的值，那么闭包就会产生，且在 Chrome 中使用这个执行上下文 A 的函数名代指闭包



闭包本质：当前环境中存在指向父级作用域的引用

- **如何产生闭包**
  - 返回函数
  - 函数当做参数传递

- **闭包的应用场景**
  - 封装变量：用闭包定义能访问私有函数和私有变量的公有函数。
  - 模块



### this ，bind，call，apply 



### 柯里化/反柯里化

柯里化：将接受多个参数的函数转换成一系列只接受单个参数的函数的过程。柯里化函数的返回值仍然是一个函数，该函数接受一个参数，并返回一个新的函数，直到所有参数都被处理完毕，最终返回最终结果

```js
function add(a) {
  return function(b) {
    return a + b;
  }
}
const addFive = add(5);
console.log(addFive(2)); // 输出 7
```

反柯里化：将柯里化函数转换成接受多个参数的函数的过程。反柯里化函数的返回值是一个函数，该函数接受一个对象作为参数，并调用该对象的原本方法并传递参数。

- 可读性：反柯里化可以使得函数的调用方式变得更加简单，只需要调用一个函数并传递一个对象作为参数即可。
- 可复用性：反柯里化可以使得函数更加可复用，因为它可以将一个预设 this 对象的函数转换成接受 this 对象的函数，从而可以在不同的对象上复用该函数。

```js
// 一个简单的反柯里化函数 bind，该函数将预设 this 对象的函数转换成接受 this 对象的函数：
function bind(fn, obj) {
  return function(...args) {
    return fn.apply(obj, args);
  }
}
const obj = { x: 1, y: 2 };
function sum() {
  return this.x + this.y;
}
const boundSum = bind(sum, obj);
console.log(boundSum()); // 输出 3
```



### History API

`History` 接口，允许操作浏览器的 `session history`，比如在当前`tab`下浏览的所有页面或者当前页面的会话记录

History不继承任何方法；

**1、 back()**

返回历史记录会话的上一个页面，同浏览器的返回，同 history.go(-1)

**2、forward()**

前进到历史会话记录的下一个页面，同浏览器的前进，同 history.go(1)

**3、go()**

从session history里面加载页面，取决于当前页面的相对位置，比如 go(-1) 是返回上一页，go(1)是前进到下一个页面。
如果你直接一个超过当前总length的返回，比如初始页面，没有前一个页面，也没有后一个页面，这个时候 go(-1) 和 go(1),都不会有任何作用；
如果你不指定任何参数或者go(0),将会重新加载当前页面；

**4、pushState(StateObj, title, url)**

**允许你在不重新加载页面的情况下添加新的历史记录**，往浏览器历史堆栈添加新的记录，把提供的状态数据放到当前的会话栈里面，如果有参数的话，一般第二个是title，第三个是URL。这个数据被DOM当做透明数据；你可以传任何可以序列号的数据。这个方法会引起会话记录length的增长。

```js
// 点击这些链接时，URL会被更改，但页面不会重新加载。相反，会调用 loadPage函数来加载相应的内容。
document.getElementById('articles-link').addEventListener('click', function() {
  history.pushState({ page: 'articles' }, '', '/articles');
  loadPage('articles');
});

document.getElementById('author-link').addEventListener('click', function() {
  history.pushState({ page: 'author' }, '', '/author');
  loadPage('author');
});
```



**5、replaceState(StateObj, title, url)**

把提供的状态数据更新到当前的会话栈里面最近的入口，如果有参数的话，一般第二个是title，第三个是URL。
这个数据被DOM当做透明数据；你可以传任何可以序列号的数据。这个方法不会引起会话记录length的增长。



**当浏览器前进，返回，刷新时会触发popState,  在这个方法中监听路由变化**

```js
// 这两个Api都会操作浏览器的历史栈，而不会引起页面的刷新
history.pushState(data, title, url) //向浏览器历史栈中增加一条记录。
history.replaceState(data, title, url) //替换历史栈中的当前记录。
```



**popState** 

`popstate` 是一个浏览器事件，当激活历史记录条目（例如，用户点击浏览器的前进或后退按钮）时触发。你可以使用此事件来响应URL的变化并加载相应的页面内容。

popState可以监听浏览器的前进，后退，刷新，history.back()，history.forward()

```js
window.addEventListener('popstate', function(event) {
  loadPage(event.state.page);
});
```





## Vue相关知识

![img](D:\typora-img\v2-84c49a649691b5e89d014dfcdf7b105e_1440w.webp)

### Vue初始化流程

```js
// 位置 src/core/instance/index.js
import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'
import { warn } from '../util/index'

function Vue(options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  // new Vue的时候就执行到了这个_init函数
  this._init(options)
}
initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
/* 
	vue 的整个构造函数就调用了 **_init** 方法 ， 那么这个 **_init** 方法哪儿来的呢？
	我们看看 _init 函数做了些什么。
*/

/*  src/core/instance/init.js  */
 Vue.prototype._init = function (options) {
    let vm = this;
    // 每个vue都会有一个uid
    vm._uid = uid++
    // 把一些全局的api方法混入到当前实例的$options上面
    vm.$options = mergeOptions(vm.constructor.options, options)
    //生命周期钩子beforeCreate
    callHook(vm, 'beforeCreate')
    //初始化状态，props，methods，data，computed，watch
    initState(vm)
    //初始化成功后调用created钩子
    callHook(vm, 'created')
    if (vm.$options.el) {
        //开始挂载
        vm.$mount(vm.$options.el)
    }
}

```

打开 **$mount** 看看它做了什么

点开源码 **src/platforms/web/entry-runtime-with-compiler.js**

把一些多余的 代码简化一下。

```js
Vue.prototype.$mount = function (el) {
		//根据用户传入的 el 属性获取节点
        el = el && document.querySelector(el);
        let vm = this;
        //把节点放在 vm.$el 上方便后面使用
        vm.$el = el;
        let options = vm.$options;
        let template
        /**
         * 编译权重：
         * 优先看有没有render函数，如果有直接用
         * 如果没有render函数就看有没有template模板
         * 如果都没有就直接获取el的outerHTML作为渲染模板
         */
        if (!options.render) {
            if (!options.template) {
                template = el.outerHTML
            } else {
                template = vm.$options.template
            }
        }
        if (template) {
            //用 template 生成 render 函数
            let render = compileToFunctions(template)
            options.render = render
        }
        //调用 mount 方法开始渲染页面。
        return mount(this, el)
    }

/* 上面代码主要实现了 vue 渲染过程中很重要的一步，得到 render 函数。
如果我们使用的 template 进行编写HTML代码，vue 内部会把模板编译成 vue 可识别的 render 函数，如果有写 render 则可以省去编译过程。
（ 直接写 render 函数对 vue 编译效率会更好 ）

*/
```

源码 **src/core/instance/lifecycle.js** 找到 **mountComponent** 方法

```js
export function mountComponent(vm, el) {
	//渲染之前调用 beforeMount 生命周期
    callHook(vm, 'beforeMount')
    //创建一个更新渲染函数 （ 用来得到 Vnode 渲染真实 dom ）
    let updateComponent = () => {
        vm.update(vm._render())
    }
    //生成一个渲染 watcher 每次页面依赖的数据更新后会调用 updateComponent 进行渲染
    new Watcher(vm, updateComponent, () => {},{
        before () {
            callHook(vm, 'beforeUpdate')
        }
      },true)
    //渲染真实 dom 结束后调用 mounted 生命周期
    callHook(vm, 'mounted')
}
```

这里就是开始准备挂载真实 dom 了，创建了渲染 watcher ，渲染 watcher 内部调用了 updateComponent 方法。

继续往下看打开 **Watcher** 所在位置 **src/core/observer/watcher.js**

```js
export class Watcher {
    constructor(vm,expOrFn,cb,options) {
        if (typeof expOrFn === 'function') {
        	// 保留 updateComponent 方法
            this.getters = expOrFn
        }
        this.get();
    }
    get() {
        pushTarget(this)
        let value
        // 这里调用了 updateComponent 方法
        value = this.getters.call(this.vm, this.vm);
        popTarget()
        return value
    }
}
```

vue 初次渲染时 watcher 内部调用了 updateComponent 方法 （ 数据添加依赖我们后面说 ）

**updateComponent 整个渲染周期最关键的几行。**

```js
let updateComponent = () => {
     //获取到虚拟 dom 调用 update 进行渲染 
     vm.update(vm._render())
}
```

我们进入 **vm._render** 函数

打开 **src/core/instance/render.js**

```js
Vue.prototype._render = function () {
     let vm = this
     // 拿到 render 函数
     let render = vm.$options.render;
     // 调用 render 函数得到 Vnode
     return render.call(vm)
}
```

调用 render 函数得到 Vnode

接着我们进入 **vm.update** 函数

找到 **vm.update** 函数位置 **src/core/instance/lifecycle.js**

```js
Vue.prototype.update = function (vnode) {
     let vm = this
     // 获取到上一次的 Vnode 用于 diff 对比
     const prevVnode = vm._vnode
     if (!prevVnode) {
     	 //首次渲染走这里
         vm.$el = patch(vm.$el, vnode)
     } else {
     	 //数据更新驱动视图更新走这里
         vm.$el = patch(prevVnode, vnode)
     }
     //保留 Vnode
     vm._vnode = vnode
}
```

进入 **patch** 方法 **src/core/vdom/patch.js**

```js
 return function patch(el, vnode, hydrating, removeOnly) {
  	//首次渲染使用 Vnode 创建真实 dom
    createElm(vnode, false, el)
    return vnode.elm
  }
 function createElm (
    vnode, //虚拟dom
    insertedVnodeQueue,
    parentElm, //父节点
  ) {
     // 查看元素 tag 是不是组件，如果是组件就创建组件
    if (createComponent(vnode, insertedVnodeQueue, parentElm)) {
      return
    }
    const data = vnode.data //得到 data 数据
    const children = vnode.children //得到子元素
    const tag = vnode.tag //获取标签名
    vnode.elm = document.createElement(tag)
    if (isDef(tag)) {
   	  //如果有子节点递归渲染子节点
      createChildren(vnode, children, insertedVnodeQueue)
   	  //给父元素插入子元素
      parentElm.appendChild(elm)
    } else if (isTrue(vnode.isComment)) {
      //创建注释节点
      vnode.elm = document.createComment(vnode.text)
      //给父元素插入注释节点
      parentElm.appendChild(elm)
    } else {
      //创建文本节点
      vnode.elm = document.createTextNode(vnode.text)
      //给父元素插入文本节点
      parentElm.appendChild(elm)
    }
  }
function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (let i = 0; i < children.length; ++i) {
      	//渲染子节点
        createElm(children[i], insertedVnodeQueue, vnode.elm)
      }
    }
  }
```

以上就是 new Vue 的整个流程。



![img](D:\typora-img\915803-20191124153601697-1162884488.png)



### 双向绑定原理

**Object.defineProperty(obj, prop, descriptor)**
其中：
**obj**
要在其上定义属性的对象。
**prop**
要定义或修改的属性的名称。
**descriptor**
将被定义或修改的属性描述符。

其实，简单点来说，就是通过此方法来定义一个值。
调用，使用到了 get 方法，
赋值，使用到了 set 方法。

vue 双向绑定内部核心就是利用了两个类， Dep 类和 watcher 类

每个在页面上使用了的属性、数组、对象都会有一个 Dep 类，访问属性的时候 get 方法会收集对应的 watcher

同样渲染 watcher 也会收集对应的 Dep

vue 内部实现双向绑定过程：**简单来说就是初始化 data 的时候会调用 observe 方法给data 里的属性重写 get 方法和 set 方法，到渲染真实 dom 的时，渲染 watcher 会去访问页面上使用的属性变量，给属性的 Dep 都加上渲染函数，每次修改数据时通知渲染 watcher 更新视图**



#### Observer类

1.在vue入口调用了initMixin方法，该方法主要实现了往vue原型上挂载了_init方法
2.在vue实例化时调用_init方法，在_init方法内又初始化了**initState** 方法，该方法主要对options对象的data数据进行初始观测
3.下面接着分析Observer

1.observer的实现主要是对传入的data 进行代理，将data代理到vue实例的_data上
2.对data的key进行遍历，将每个key通过Object.definedProperty挂载到vm实例上

打开 **src/core/observer/index.js**

```js
// 代码位置 vue\src\core\observer\index.js
export class Observer {
  value: any; 
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    def(value, '__ob__', this)
      // 数组特殊处理
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      this.observeArray(value)
    } else {
      this.walk(value)
    }
  }

  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}

export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  const getter = property && property.get
  const setter = property && property.set
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }

  let childOb = !shallow && observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow && observe(newVal)
      dep.notify()
    }
  })
}

/*
根据上述代码可知
1.在Observer实例化时会调用walk函数
2.在walk函数内，主要主要对obj的可以进行遍历，调用defineReactive方法
3.defineReactive 函数实现对数据观测，在get中实现对数据依赖的收集，在set中通过收集的依赖取触发通知
*/
```

#### Dep类

3.1. 在vue数据get获取中，谁读取了该数据，就把它收集起来，所以dep是一个集合，在数据set时，通过遍历dep去触发每个dep的notify方法通过视图更新
3.2. dep的主要功能是只作为收集，那在收集了依赖后，如何使视图更新呢
3.3. 所以需要定义一个新的Watcher类，改类是会实现对视图的更新
3.4. dep每收集的一个依赖实际就是一个Watcher

Dep 类的实现**src/core/observer/dep.js**

```js
export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array<Watcher>;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }

  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    if (process.env.NODE_ENV !== 'production' && !config.async) {
      // subs aren't sorted in scheduler if not running async
      // we need to sort them now to make sure they fire in correct
      // order
      subs.sort((a, b) => a.id - b.id)
    }
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}
/*
在dep类中subs就是收集Watcher的一个集合
addSub 为添加依赖的方法
notify 为依赖通知的方法
depend 该方法为主要的方法，在Observer的get中将会调用该方法进行收集 （该方法中的Dep.target是一个判断依赖收集标识，Dep.target将会在模板挂载时，实例化一个Watcher,在Watcher实例化时会调用getter,会给Dep.target赋值为当前实例的this,因此在对数获取触发get时，Dep.target是存在的，所以Watcher就不收集了）
*/
```

每个属性、对象、数组上都有一个 Dep 类型，Dep 类主要就是收集用于渲染的 watcher



#### **watcher** 类 

4.1. Watcher的功能主要是接到Dep的通知，然后调用update方法更新视图

4.2. 在update方法中会触发回调，回调函数实际就是已生成render函数

4.3. 在调用render函数是，函数里的值就会获取到已经更改后值，所以就会生成新的vnode
4.4. 新的vnode生成后，就是patch的过程，用新的vnode与旧的vnode进行比对，最终将比对后的vnode转换为实际的dom添加到模板挂载节点上
4.5.新的模板挂载后，将旧的模板删除，这样视图就更新完成

```js
// 代码位置 vue\src\core\observer\watcher.js
export default class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  deep: boolean;
  user: boolean;
  lazy: boolean;
  sync: boolean;
  dirty: boolean;
  active: boolean;
  deps: Array<Dep>;
  newDeps: Array<Dep>;
  depIds: SimpleSet;
  newDepIds: SimpleSet;
  before: ?Function;
  getter: Function;
  value: any;

  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this)
    // options
    if (options) {
      this.deep = !!options.deep
      this.user = !!options.user
      this.lazy = !!options.lazy
      this.sync = !!options.sync
      this.before = options.before
    } else {
      this.deep = this.user = this.lazy = this.sync = false
    }
    this.cb = cb
    this.id = ++uid // uid for batching
    this.active = true
    this.dirty = this.lazy // for lazy watchers
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString()
      : ''
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = noop
        process.env.NODE_ENV !== 'production' && warn(
          `Failed watching path: "${expOrFn}" ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get()
  }

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  get () {
    pushTarget(this)
    let value
    const vm = this.vm
    try {
      value = this.getter.call(vm, vm)
    } catch (e) {
      if (this.user) {
        handleError(e, vm, `getter for watcher "${this.expression}"`)
      } else {
        throw e
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value)
      }
      popTarget()
      this.cleanupDeps()
    }
    return value
  }

  /**
   * Add a dependency to this directive.
   */
  addDep (dep: Dep) {
    const id = dep.id
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      if (!this.depIds.has(id)) {
        dep.addSub(this)
      }
    }
  }

  /**
   * Clean up for dependency collection.
   */
  cleanupDeps () {
    let i = this.deps.length
    while (i--) {
      const dep = this.deps[i]
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this)
      }
    }
    let tmp = this.depIds
    this.depIds = this.newDepIds
    this.newDepIds = tmp
    this.newDepIds.clear()
    tmp = this.deps
    this.deps = this.newDeps
    this.newDeps = tmp
    this.newDeps.length = 0
  }

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      queueWatcher(this)
    }
  }

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
  run () {
    if (this.active) {
      const value = this.get()
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        isObject(value) ||
        this.deep
      ) {
        // set new value
        const oldValue = this.value
        this.value = value
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher "${this.expression}"`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
  evaluate () {
    this.value = this.get()
    this.dirty = false
  }

  /**
   * Depend on all deps collected by this watcher.
   */
  depend () {
    let i = this.deps.length
    while (i--) {
      this.deps[i].depend()
    }
  }

  /**
   * Remove self from all dependencies' subscriber list.
   */
  teardown () {
    if (this.active) {
      // remove self from vm's watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this)
      }
      let i = this.deps.length
      while (i--) {
        this.deps[i].removeSub(this)
      }
      this.active = false
    }
  }
}
```

**defineProperty**

```js
function defineProperty(data, key, value) {
    //childDep 这个 dep 只会存在 {} 或 [] 里面
    let childDep = observe(value)
    //这个 dep 会存在每个属性里面
    let dep = new Dep();
    Object.defineProperty(data, key, {
        get() {
            //渲染的期间给每个放在页面上的变量添加 watcher
            //只有渲染阶段才会 Dep.target ，有正常访问 target 是没有的
            if (Dep.target) {
                //给属性 dep 添加 watcher
                dep.depend()
                if (childDep) {
                    //给属性是数组或者是对象的添加 watcher
                    childDep.dep.depend()
                    if (Array.isArray(value)) {
                        //如果是数组递归数组给数组里面的数组添加 watcher
                        dependArray(value)
                    }
                }
            }
            return value
        },
        set(newValue) {
            if(newValue == value)return
            //更新数组或者对象的时候也要创建一个新的 dep 给 childDep
            childDep = observe(newValue)
            value = newValue
            //更新视图
            dep.notify()
        }
    })
}
```





### 监听数组变化





### MVVM和MVC

MVVM (model-view-ViewModel)，`MVVM` 是一种设计思想。`Model` 层代表数据模型，也可以在 `Model` 中定义数据修改和操作的业务逻辑；`View` 代表UI 组件，它负责将数据模型转化成 UI 展现出来；`ViewModel` 是一个同步 `View` 和 `Model` 的对象。

ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。


`MVC` 和 `MVVM` 其实区别并不大，都是一种设计思想。主要就是 `MVC` 中`Controller` 演变成 `MVVM` 中的 `viewModel`。`MVVM` 主要解决了 `MVC` 中大量的 `DOM` 操作使页面渲染性能降低，加载速度变慢，影响用户体验。



### 介绍VUE的响应式系统

Vue 为 MVVM 框架，当数据模型 data 变化时，页面视图会得到响应更新，其原理对 data 的 getter/setter 方法进行拦截（Object.defineProperty 或者Proxy），利用发布订阅的设计模式，在 getter 方法中进行订阅，在 setter 方法中发布通知，让所有订阅者完成响应。

在响应式系统中，Vue 会为数据模型 data 的每一个属性新建一个订阅中心作为发布者，而监听器 watch、计算属性 computed、视图渲染 template/render三个角色同时作为订阅者，对于监听器 watch，会直接订阅观察监听的属性，对于计算属性 computed 和视图渲染 template/render，如果内部执行获取了 data 的某个属性，就会执行该属性的 getter 方法，然后自动完成对该属性的订阅，当属性被修改时，就会执行该属性的 setter 方法，从而完成该属性的发布通知，通知所有订阅者进行更新。



### Vue如何创建自定义指令







###  Vue 如何实现按需加载配合 webpack 设置？

webpack 中提供了 require.ensure() 来实现按需加载。

以前引入路由是通过 import 这样的方式引入，现在改为 const 定义的方式进行引入。

页面不按需加载引入方式：

````js
import home from '../../common/home.vue'
````



页面按需加载引入方式：

```js
const home = r => require.ensure( [], () => r (require('../../common/home.vue')))
```



### Vue生命周期





### computed和watch区别

相同点：

计算属性 computed 和监听器 watch 都可以观察属性的变化从而做出响应。
不同点：

计算属性 computed 更多是作为缓存功能的观察者，它可以将一个或者多个 data 的属性进行复杂的计算生成一个新的值，提供给渲染函数使用，当依赖的属性变化时，computed 不会立即重新计算生成新的值，而是先标记为当前数据，当下次 computed 被获取时候，才会进行重新计算并返回。也就是说：computed 只有当依赖的数据变化时才会计算，会缓存数据。

监听器 watch 并不具备缓存性，监听器 watch 提供一个监听函数，当监听的属性发生变化时，会立即执行该函数。watch 更适用于数据变化时的异步操作。





### Vuex



### Vue-Router

**原理：两种匹配模式**

1.`Hash`模式是基于锚点，通过锚点值作为路由地址，**监听浏览器hashChange事件**，触发不同组件的切换显示， **hash改变不会触发浏览器请求**。

2.`history`模式基于html5的History API,  **2个核心方法：history.pushState() | history.replaceState(),**

页面跳转是通过`history.pushState( ) `方法来修改地址栏中的地址，实现组件的切换，而且还会把地址保存的历史记录中（也就是可以单击浏览器中后退按钮，实现后退等操作），但是它并不会向服务器发送请求。但是刷新页面就会报404， **需要服务端支持**

为什么需要服务端支持：

在单页应用中，如访问/login这个地址时如刷新了页面，会真实向服务器发送/login请求，服务器没有该资源就会报404错误

服务端如何支持：

Node服务端：安装connect-history-api-fallback 模块，**所有url都返回index.html这个页面**

nginx反向代理：

```txt
 location / {
            root   html;
            index  index.html index.htm;
			try_files $uri $uri/ /index.html; // 没找到资源就返回Index.html
        }

```

**简单源码逻辑：**

```js
// 1. 实现install方法  Vue.use(Router) 中会调用Router.install
let _Vue = null;
export default class VueRouter {
 // VueRouter的静态方法，在Vue.use中被调用
  static install(Vue) {
    //首先判断插件是否已经被安装，如果已经被安装，就不需要重复安装。   
    //1、判断当前插件是否已经被安装:  
    if (VueRouter.install.installed) {
      //条件成立，表明插件已经被安装，什么都不要做。
      return;
    }
    VueRouter.install.installed = true;
    //2、把Vue构造函数记录到全局变量中。
    _Vue = Vue;

    //3、核心步骤：在beforeCreate回调函数上上进行router的获取和初始化，把创建Vue实例时候传入的router对象注入到Vue实例上。
    _Vue.mixin({
        // 混入的同名钩子函数会合并为数组，都会被调用，混入的钩子优先于组件自身钩子函数执行
      beforeCreate() {
        //在创建Vue实例的时候
        // 也就是new Vue()的时候，才会有$options这个属性，
        //组件中是没有$options这个属性的。
        if (this.$options.router) {
          _Vue.prototype.$router = this.$options.router
          this._routerRoot = this
          this._router = this.$options.router
          this._router.init(this) // VueRouter初始化 初始化中监听hash或history
          this._router.initComponent(this) // 注册router-view, router-link 两个组件
          // 关键2：注册响应式属性_route 当路由改变时，执行rerender
          // 在Vue的实例上创建一个响应式的属性`_route`.
          Vue.util.defineReactive(this, "_route", this._router.history.current);
        }
      }
    })
  }
    // 2.VueRouter构造函数,该该构造方法中会初始化options ,data,routeMapt这几个属性。
  constructor(options) {
    this.options = options;
    this.routeMap = {};
    this.data = _Vue.observable({
      current: "/",
    }); 
      // 关键：创建路由映射表
    this.matcher = createMatcher(options.routes || [], this)
     
     // 根据mode 采用不同的路由方式
     let mode = options.mode || 'hash'
     this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false
     if (this.fallback) mode = 'hash'
     this.mode = mode
     switch (mode) {
         case 'history':
             this.history = new HTML5History(this, options.base)
             break;
         case 'hash':
             this.history = new HashHistory(this, options.base, this.fallback)
             break;
         case 'abstract': // 略
     }
  }
  // 注册路由变化的事件(初始化事件监听器，监听路由地址的变化)
  // init中会调用构造函数根据mode创建的hashHistory或HTMLHistory
  init(Vue) {
    const history = this.history;
    const setUpListener = () => {
      history.setUpListener();
    };
    history.transitionTo(
      history.getCurrentLocation(),
      //如果直接history.setUpListener
      // 这样的话setUpListener里面的this会有问题。
      setUpListener
    )
    //调用父类的中的listen方法，改变_route的值 route响应式更新关键
    history.listen((route) => {
      Vue._route = route;
    });
  }
    
 // 4.实现initComponent 该方法用来创建<router-link> <router-view>两个全局组件
 initComponents(Vue) {
   Vue.component("router-link", {
      props: {
        to: String,
      },
      // template: '<a :href="to"><slot></slot></a>',
      render(h) {
        return h(
          "a",
          {
            attrs: {
              href: this.to,
            },
            on: {
              click: this.clickHandler, // a标签点击事件
            },
          },
          [this.$slots.default]
        );
      },
      methods: {
        clickHandler(e) {
          history.pushState({}, "", this.to);
          this.$router.data.current = this.to;
          // a标签默认行为阻止， 阻止向服务器发送器。 
          e.preventDefault();
        },
      },
    });
     
     // router-view组件
     Vue.component("router-view", {
		  render(h) {
            //获取当前匹配的路由规则对象
            const route = this.$route;
            let depth = 0;
            //记录当前组件为RouterView
            this.routerView = true;
            let parent = this.$parent;
            while (parent) {
              if (parent.routerView) {
                depth++;
              }
              parent = parent.$parent;
            }
            //获取路由记录对象.
            // 如果是子路由，例如：子路由/about/users
            //子路由是有两部分内容，matched[0]:是父组件内容，matched[1]是子组件内容
            const record = route.matched[depth];
            if (!record) {
              return h();
            }
            //获取记录中对应的组件
            const component = record.component;
            return h(component);
          }
    });
  }
}


// createMatcher实现 作用是创建路由映射表，然后使用闭包的方法让 addRoutes 和 match 函数能够使用路由映射表的几个对象，最后返回一个 Matcher 对象。
function createMatcher(routes, router) {
    // 创建路由映射表
    const {pathList, pathMap, nameMap} = createRouteMap(routes)
    
    // 闭包方式让addRoutes，可以使用pathList,pathMap,NameMap这几个对象
    function addRoutes(routes) {
        createRouteMap(routes, pathList, pathMap, nameMap)
    }
    // match这个方法的作用就是根据路径，创建出路由规则对象，而所谓的路由规则对象其实就是包含了路径以及对应的路由记录的信息(这里有可能包含了父路由以及子路由记录，这块内容存储到一个数组中)。
    function match(path) {
        const record = pathMap[path];
        if (record) {
          //根据路由地址，创建route路由规则对象
          return createRoute(record, path);
        }
        return createRoute(null, path);
    }
    
    function redirect(record, location) {...}
    
    function alias(record, location, matchAs) {...}
    
    function _createRoute(record, location, redirectedFrom) {...}
    
    // 返回的matcher对象， 包含match方法和addRoutes方法
    return {
        match,
        addRoutes
    }
}

// 简化版！ 3.该方法把构造函数中传入进来的options参数中的路由规则，转换成键值对的形式存储到routeMap中。 键就是路由的地址，值就是对应的组件
function createRouteMap() { 
    this.options.routes.forEach((route) => {
      this.routeMap[route.path] = route.component;
    });
  }

export default function createRoute(record, path) {
  const matched = [];
  while (record) {
    matched.unshift(record);
    record = record.parent;
  }
  return {
    path,
    matched,
  }
}


                                               
 /*============== History和HashHistory ========================*/
                                               
import createRoute from "../util/route";
export default class History {
  // router路由对象ViewRouter
  constructor(router) {
    this.router = router;
    this.current = createRoute(null, "/");
    //这个回调函数是在hashhistory中赋值，作用是更改vue实例上的_route，_route的值发生变化，视图会进行刷新操作
    this.cb = null;
  }
    
  listen(cb) {
    this.cb = cb;
  }
  transitionTo(path, onComplete) {
    this.current = this.router.matcher.match(path);
    this.cb && this.cb(this.current);
    //该回调函数在调用transitionTo方法的时候，会传递过来。
    onComplete && onComplete();
  }
}

import History from "./base";
export default class HashHistory extends History {
  constructor(router) {
    //将路由对象传递给父类的构造函数
    super(router);
    //确保 首次 访问地址加上 #/  （//由于没有添加this,为普通方法）
    ensureSlash();
  }
  // 获取当前的路由地址 （# 后面的部分）所以这里需要去除#
  getCurrentLocation() {
    return window.location.hash.slice(1);
  }
  // 监听hashchange事件
  //也就是监听路由地址的变化
  setUpListener() {
    window.addEventListener("hashchange", () => {
      //当路由地址发生变化后，跳转到新的路由地址。
      this.transitionTo(this.getCurrentLocation());
    });
  }
}

function ensureSlash() {
  //判断当前是否有hash
  // 如果单击的是链接，肯定会有hash
  if (window.location.hash) {
    return;
  }
  
  window.location.hash = "/";
}


```



#### 简化流程

```txt
页面渲染
1、Vue.use(Router) 注册
2、注册时调用 install 方法混入生命周期，定义 router 和 route 属性，注册 router-view 和 router-link 组件
3、生成 router 实例，根据配置数组(传入的routes)生成路由配置记录表，根据不同模式生成监控路由变化的History对象
4、生成 vue 实例，将 router 实例挂载到 vue 实例上面，挂载的时候 router 会执行最开始混入的生命周期函数
5、初始化结束，显示默认页面
路由点击更新
1、 router-link 绑定 click 方法，触发 history.push 或 history.replace ，从而触发 history.transitionTo 方法
2、transitionTo 用于处理路由转换，其中包含了 updateRoute 用于更新 _route
3、在 beforeCreate 中有劫持 _route 的方法，当 _route 变化后，触发 router-view 的变化
地址变化路由更新
1、HashHistory 和 HTML5History 会分别监控 hashchange 和 popstate 来对路由变化作对用的处理
2、HashHistory 和 HTML5History 捕获到变化后会对应执行 push 或 replace 方法，从而调用 transitionTo
3、然后更新 _route 触发 router-view 的变化
```





动态路由，动态参数

几种导航钩子

vue-router中使用active-class的方法，碰到过什么问题



**keep-alive** 

组件缓存





### scss

是一个css的预编译语言	

使用步骤：
先装 css-loader、node-loader、sass-loader 等加载器模块；
在 build 目录找到 webpack.base.config.js，在 extends 属性中加一个拓展 .scss；
在同一个文件，配置一个 module 属性；
然后在组件的 style 标签加上 lang 属性 ，例如：lang=”scss” 





### key的作用

答案1：当有相同标签名的元素切换时，为避免渲染问题，需要通过 key 特性设置唯一的值，来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。
答案2：key 是给每一个 vnode 的唯一 id，可以依靠 key，更准确，更快的拿到 oldVnode 中对应的 vnode 节点





### SSR(服务端渲染)

原理很简单，就是服务端直接渲染出 HTML 字符串模板，浏览器可以直接解析该字符串模版显示页面，因此首屏的内容不再依赖 Javascript 的渲染（CSR - 客户端渲染）

SSR 的核心优势：

1. 首屏加载时间：因为是 HTML 直出，浏览器可以直接解析该字符串模版显示页面。
2. SEO 友好：正是因为服务端渲染输出到浏览器的是完备的 html 字符串，使得搜索引擎 能抓取到真实的内容，利于 SEO。

SSR 需要注意的问题：

1. 虽然 SSR 能快速呈现页面，但是在 UI 框架（比如 React）加载成功之前，页面是没法进行 UI 交互的。
2. TTFB (Time To First Byte)，即第一字节时间会变长，因为 SSR 相对于 CSR 需要在服务端渲染出更对的 HTML 片段，因此加载时间会变长。
3. 更多的服务器端负载。由于 SSR 需要依赖 Node.js 服务渲染页面，显然会比仅仅提供静态文件的 CSR 应用需要占用更多服务器 CPU 资源。以 React 为例，它的 `renderToString()` 方法是同步 CPU 绑定调用，这就意味着在它完成之前，服务器是无法处理其他请求的。因此在高并发场景，需要准备相应的服务器负载，并且做好缓存策略。

**Vue SSR原理图**

1、对于同构开发，我们依然使用`webpack`打包，我们要解决两个问题：服务端首屏渲染和客户端激活

2、这里需要生成一个服务器`bundle`文件用于服务端首屏渲染和一个客户端`bundle`文件用于客户端激活

![img](D:\typora-img\60c5a0e9a65d575053e26236969cac74.png)







### Serverless

它是云计算发展过程中出现的**一种计算资源的抽象**，依赖第三方服务，开发者可以更加专注的开发自己的业务代码，而无需关心底层资源的分配、扩容和部署。

特点：

1. 开发者只需要专注于业务，无需关心底层资源的分配、扩容和部署
2. 按需使用和收费
3. 自动扩缩容



### **Serverless + SSR**

结合 Serverless 和 SSR 的特点，我们可以发现他们简直是天作之合。借助 Serverless，前端团队无需关注 SSR 服务器的部署、运维和扩容，可以极大地减少部署运维成本，更好的聚焦业务开发，提高开发效率。

同时也无需关心 SSR 服务器的性能问题，理论上 Serverless 是可以无限扩容的（当然云厂商对于一般用户是有扩容上限的）。





### Vue模板渲染原理

Vue 中的模板 template 无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的 HTML 语法，所以需要将 template 转化成一个 JavaScript 函数，这样浏览器就可以执行这一个函数并渲染出对应的 HTML 元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。

模板编译又分三个阶段，解析parse，优化 optimize，生成 generate，最终生成可执行函数 render。

解析parse阶段：使用大量的正则表达式对 template 字符串进行解析，将标签、指令、属性等转化为抽象语法树 AST。
优化 optimize阶段：遍历 AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行 diff 比较时，直接跳过这一些静态节点，优化 runtime 的性能。
生成 generate阶段：将最终的 AST 转化为 render 函数字符串。



### template预编译是什么

对于 Vue 组件来说，模板编译只会在组件实例化的时候编译一次，生成渲染函数之后在也不会进行编译。因此，编译对组件的 runtime 是一种性能损耗。

而模板编译的目的仅仅是将 template 转化为 render function，这个过程，正好可以在项目构建的过程中完成，这样可以让实际组件在 runtime 时直接跳过模板渲染，进而提升性能，这个在项目构建的编译 template 的过程，就是预编译。



### template和jsx区别

对于 runtime 来说，只需要保证组件存在 render 函数即可，而我们有了预编译之后，我们只需要保证构建过程中生成 render 函数就可以。

在 webpack 中，我们使用 vue-loader 编译 .vue 文件，内部依赖的 vue-template-compiler 模块，在 webpack 构建过程中，将 template 预编译成 render 函数。

与 React 类似，在添加了 jsx 的语法糖解析器 babel-plugin-transform-vue-jsx 之后，就可以直接手写 render 函数。

所以，template 和 jsx 的都是 render 的一种表现形式，不同的是：

JSX 相对于 template 而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞，但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。

