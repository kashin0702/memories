## 描述字符

根据正则表达式语法规则，大部分字符仅能够描述自身，这些字符被称为普通字符，如所有的字母、数字等。

**元字符**就是拥有特动功能的特殊字符，大部分需要加反斜杠进行标识，以便于普通字符进行区别



| .      |    查找单个字符，除了换行和行结束符    |
| ------ | :------------------------------------: |
| \w     |              查找单词字符              |
| \W     |             查找非单词字符             |
| \d     |                查找数字                |
| \D     |             查找非数字字符             |
| \s     |              查找空白字符              |
| \S     |             查找非空白字符             |
| \b     |              匹配单词边界              |
| \B     |             匹配非单词边界             |
| \0     |              查找 NUL字符              |
| \n     |               查找换行符               |
| \f     |               查找换页符               |
| \r     |               查找回车符               |
| \t     |               查找制表符               |
| \v     |             查找垂直制表符             |
| \xxx   |     查找以八进制数 xxxx 规定的字符     |
| \xdd   |     查找以十六进制数 dd 规定的字符     |
| \uxxxx | 查找以十六进制 xxxx规定的 Unicode 字符 |

示例2

在字符范围内可以混用各种字符模式。

```js
var s = "abcdez";  //字符串直接量
var r = /[abce-z]/g;  //字符a、b、c，以及从e~z之间的任意字符
var a = s.match(r);  //返回数组["a","b","c","e","z"]
```

示例3

在中括号内不要有空格，否则会误解为还要匹配空格。

```js
var r = /[0-9]/g;
```

示例4

字符范围可以组合使用，以便设计更灵活的匹配模式。

```js
var s = "abc4 abd6 abe3 abf1 abg7";  //字符串直接量
var r = /ab[c-g][1-7]/g;  //前两个字符为ab，第三个字符为从c到g，第四个字符为1~7的任意数字
var a = s.match(r);  //返回数组["abc4","abd6","abe3","abf1","abg7"]
```

示例5

使用反义字符范围可以匹配很多无法直接描述的字符，达到以少应多的目的。

```js
var r = /[^0123456789]/g;
```



## 选择匹配

选择匹配类似于 JavaScript 的逻辑与运算，使用竖线`|`描述，表示在两个子模式的匹配结果中任选一个。例如：
1) 匹配任意数字或字母

```js
var r = /\w+|\d+/;
```

2) 可以定义多重选择模式。设计方法：在多个子模式之间加入选择操作符。

```js
var r = /(abc)|(efg)|(123)|(456)/;
```

**为了避免歧义，应该为选择操作的多个子模式加上小括号。**

示例：敏感词过滤

```js
var s = '<meta charset="utf-8">';  //待过滤的表单提交信息
var r = /\'|\"|\<|\>/gi;  //过滤敏感字符的正则表达式
function f() {  //替换函数
    ////把敏感字符替换为对应的网页显示的编码格式
    return "&#" + arguments[0].charCodeAt(0) + ";";
}
var a =s.replace(r,f);  //执行过滤替换 replace第二个参数可以传一个函数
document.write(a);  //在网页中显示正常的字符信息
console.log(a); // &#60;meta charset=&#34;utf-8&#34;&#62;
```





## 重复匹配

在正则表达式语法中，定义了一组重复类量词，如表所示。它们定义了重复匹配字符的确数或约数。



| 量词   | 描述                                          |
| ------ | --------------------------------------------- |
| n+     | 匹配任何包含至少一个 n 的字符串               |
| n*     | 匹配任何包含零个或多个 n 的字符串             |
| n?     | 匹配任何包含零个或一个 n 的字符串             |
| n{x}   | 匹配包含 x 个 n 的序列的字符串                |
| n{x,y} | 匹配包含最少 x 个、最多 y 个 n 的序列的字符串 |
| n{x,}  | 匹配包含至少 x 个 n 的序列的字符串            |



示例

```js
var s = "ggle gogle google gooogle goooogle gooooogle goooooogle gooooooogle goooooooogle";
```


1) 如果仅匹配单词 ggle 和 gogle，可以设计：

```js
var r = /go?gle/g;
var a = s.match(r);
```

量词`?`表示前面字符或子表达式为可有可无，等效于：

```js
var r = /go{0,1}gle/g;
var a = s.match(r);
```

2) 如果匹配第 4 个单词 gooogle，可以设计：

```js
var r = /go{3}gle/g;
var a = s.match(r);
```

3) 如果匹配第 4 个到第 6 个之间的单词，可以设计：

```js
var r = /go{3,5}gle/g;
var a = s.match(r);
```


4) 如果匹配所有单词，可以设计：

```js
var r = /go*gle/g;
var a = s.match(r);
```

量词`*`表示前面字符或表达式可以不出现，或者重复出现任意多次。等效于：

```js
var r = /go(0,)gle/g;
var a = s.match(r);
```


5) 如果匹配包含字符“o”的所有词，可以设计：

```js
var r = /go+gle/g;
var a = s.match(r);
```

量词`+`表示前面字符或子表达式至少出现 1 次，最多重复次数不限。等效于：

```js
var r = /go{1,}gle/g;
var a = s.match(r);
```





## 惰性匹配

重复类量词都具有贪婪性，在条件允许的前提下，会匹配尽可能多的字符。

- ?、{n} 和 {n,m} 重复类具有弱贪婪性，表现为贪婪的有限性。
- *、+ 和 {n,} 重复类具有强贪婪性，表现为贪婪的无限性。

示例1

越是排在左侧的重复类量词匹配优先级越高。下面示例显示当多个重复类量词同时满足条件时，会在保证右侧重复类量词最低匹配次数基础上，使最左侧的重复类量词尽可能占有所有字符。

```js
var s = "<html><head><title></title></head><body></body></html>";
var r = /(<.*>)(<.*>)/
var a = s.match(r);
console.log(a[1])；//左侧表达式匹配"<html><head><title></title></head><body></body>"
console.log(a[2]); //右侧表达式匹配“</html>”
```

与贪婪匹配相反，惰性匹配将遵循另一种算法：在满足条件的前提下，尽可能少的匹配字符。定义惰性匹配的方法：在重复类量词后面添加问号?限制词。贪婪匹配体现了最大化匹配原则，惰性匹配则体现最小化匹配原则。

示例2

```js
var s = "<html><head><title></title></head><body></body></html>";
var r = /<.*?>/
var a = s.match(r);  //返回单个元素数组["<html>"]
```

在上面示例中，对于正则表达式 /<.*?>/ 来说，它可以返回匹配字符串 "<>"，但是为了能够确保匹配条件成立，在执行中还是匹配了带有 4 个字符的字符串“html”。惰性取值不能够以违反模式限定的条件而返回，除非没有找到符合条件的字符串，否则必须满足它。

- {n,m}?：尽量匹配 n 次，但是为了满足限定条件也可能最多重复 m 次。
- {n}?：尽量匹配 n 次。
- {n,}?：尽量匹配 n 次，但是为了满足限定条件也可能匹配任意次。
- ??：尽量匹配，但是为了满足限定条件也可能最多匹配 1 次，相当于 {0,1}?。
- +?：尽量匹配 1 次，但是为了满足限定条件也可能匹配任意次，相当于 {1,}?。
- *? ：尽量不匹配，但是为了满足限定条件也可能匹配任意次，相当于 {0,}?。



## 边界量词

边界就是确定匹配模式的位置，如字符串的头部或尾部，具体说明如表所示。

| 量词 | 说明                                     |
| ---- | ---------------------------------------- |
| ^    | 匹配开头，在多行检测中，会匹配一行的开头 |
| $    | 匹配结尾，在多行检测中，会匹配一行的结尾 |

```
var s = "how are you"
```

1) 匹配最后一个单词

```
var r = /\w+$/;
var a = s.match(r);  //返回数组["you"]
```

2) 匹配第一个单词

```
var r = /^\w+/;
var a = s.match(r);  //返回数组["how"]
```

3) 匹配每一个单词

```
var r = /\w+/g;
var a = s.match(r);  //返回数组["how","are","you"]
```



## 声明词量

声明表示条件的意思。声明词量包括正向声明和反向声明两种模式。

#### (?:)

(?:pattern)   非获取匹配，匹配pattern但不获取匹配结果

```js
var reg1 = /industry|industries/
var reg2 = /industr(?:y|ies)/ //比上面更简洁的表达式
```



#### 正向声明 (?=)   (?<=)

指定匹配模式后面的字符必须被匹配，但又不返回这些字符。语法格式如下：

匹配模式 (?= 匹配条件)

声明包含在小括号内，它不是分组，因此作为子表达式。

下面代码定义一个正前向声明的匹配模式。

```js
var s = "one:1;two=2";
var r = /\w*(?==)/;  //使用正前向声明，指定执行匹配必须满足的条件
var a = s.match(r);  //返回数组["two"]
```

在上面示例中，通过`?==`锚定条件，指定只有在 \w* 所能够匹配的字符后面跟随一个等号字符，才能够执行 \w* 匹配。所以，最后匹配的字符串“two”，而不是字符串“one”。

例子2：

**exp1(?=exp2)**：查找 exp2 前面的 exp1。

```js
var reg = /runoob(?=[\d+])/g
var str = '123456runoob123runoob456'// 匹配数字前面的字符串
str.match(reg) // ['runoob', 'runoob']
```

**(?<=exp2)exp1**：查找 exp2 后面的 exp1。

```js
var reg = /(?<=[0-9]+)runoob/g
var str = '12345google123runoob456' // 匹配数字后面的字符串
str.match(reg) // ['runoob']
```





#### 反向声明 (?!)  ( ?<!)

与正向声明匹配相反，指定接下来的字符都不必被匹配。语法格式如下：

匹配模式(?! 匹配条件)


下面代码定义一个反前向声明的匹配模式。

```js
var s = "one:1;two=2";
var r = /\w*(?!=)/;  //使用正前向声明，指定执行匹配不必满足的条件
var a = s.match(r);  //返回数组["one"]
```

在上面示例中，通过`?!=`锚定条件，指定只有在“\w*”所能够匹配的字符后面不跟随一个等号字符，才能够执行 \w*匹配。所以，最后匹配的是字符串“one”，而不是字符串“two”。

例子2

**exp1(?!exp2)**：查找后面不是 exp2 的 exp1。

```js
var reg = /runoob(?![0-9]+)/g
var str = '123runoob-google123runoob456' //匹配runoob,但后面不是数字
str.match(reg) // 匹配123后面的runoob
```

**(?<!exp2)exp1**：查找前面不是 exp2 的 exp1。

```js
var reg = /(?<![0-9]+)runoob/g  
var str = '123runoob-googlerunoob456' // 匹配前面不是数字的runoob
```



#### 反向引用

对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 **\n**访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。

可以使用非捕获元字符 **?:**、**?=** 或 **?!** 来重写捕获，忽略对相关匹配的保存。

例子：查找重复的单词

```js
var str = "Is is the cost of of gasoline going up up";
var patt1 = /\b([a-z]+) \1\b/ig;
document.write(str.match(patt1));  // Is is,of of,up up
```





## 子表达式

使用小括号可以对字符模式进行任意分组，在小括号内的字符串表示子表达式，也称为子模式。子表达式具有独立的匹配功能，保存独立的匹配结果；同时，小括号后的量词将会作用于整个子表达式。

通过分组可以在一个完整的字符模式中定义一个或多个子模式。当正则表达式成功地匹配目标字符串后，也可以从目标字符串中抽出与子模式相匹配的子内容。

示例

在下面代码中，不仅能匹配出每个变量声明，同时还抽出每个变量及其值。

```js
var s = "ab=21, bc=45, cd=43";
var r = /(\w+)=(\d*)/g;
while (a = r.exec(s)) {    
	console.log(a);  //返回类似["ab=21","bc=45","cd=43"]三个数组
}
```

### 子表达式会缓存

**()** 表示捕获分组，**()** 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(**n** 是一个数字，表示第 n 个捕获组的内容)。

```js
let str = '123456runoob123runoob456'
let n = str.match(/([1-9])([a-z]+)/g)  //返回长度2的数组 
console.log(n[0]) // 6runoob 
console.log(n[1]) // 3runoob

```







### 正则加g的区别

不加g 在匹配到1个后就会退出

加g 会匹配全局所有字符串

```js
var reg1 = /[1-9]/g
var reg2 = /[1-9]/
var str = '123'
str.match(reg1) // ['1', '2', '3']
str.match(reg2) // ['1']
```



### .exec()方法

捕获方法    接受字符串参数，返回一个array数组，且拥有index,input2个属性
index表示匹配项在字符串中位置,input表示应用正则表达式的字符串
var text='mom and dad and baby';
var pattern=/mom(and dad(and baby)?)?/gi;    //包含2个捕获数组 'and baby'  'and dad and baby'
var matches=pattern.exec(text);
matches.index    //0             
matches.input    //mom and dad and baby
matches[0]       //mom and dad and baby
matches[1]       //and dad and baby
matches[2]       //and baby

.exec()和字符串的match()方法效果一样,语法反一下
var match=string.match(pattern)