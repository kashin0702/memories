###  主要组成

1. 页面布局：WXML 类似HTML
2. 页面样式：WXSS 几乎就是CSS
3. 页面脚本： JS+WXS (JS以及weixinScript)



### 文件结构

#### App

1. app.js 创建app实例的代码以及一些全局相关内容
2. app.json 全局的一些配置，比如window,tabbar等
3. app.wxss 全局样式

#### page

1. page.js page实例代码，以及page的相关内容
2. page.json 业务单独的配置，比如页面对应的window配置，usingComponents等
3. page.wxml 页面的wxml布局
4. page.wxss 页面的样式

#### components

1. component.js  组件实例代码，以及组件内部的内容
2. component.json 组件内部配置，比如当前组件使用了别的组件

3. component.wxml 组件布局代码
4. component.wxss 组件样式代码



### 遍历数据

**wx:for**   

例子：

js文件内： **所有逻辑都在page实例内实现**

``` js
Page({
    data: {
        person: [
            {name: xxx, age: 20},
            {name: xxx, age: 18}
        ]
    }
})
```

wxml文件内： **遍历的数组对象person也要加{{ }}  ，和vue不同**

``` vue
<view wx:for="{{person}}">{{item.name +' '+ item.age}}</view>
```

给遍历对象的item index 设置别名  **(嵌套循环时可以使用)**

``` html
<view wx:for="{{list}}" wx:for-item="i"  wx:for-index="idx">
	{{i}}
</view>
```

#### tabBar激活样式案例

``` js
Page({
    data: {
        list: [
            {name: 'xxx',isActive: true},
            {name: 'xxx',isActive: false},
            {name: 'xxx',isActive: false}
        ]
    },
    method: {
        handleActive (e) {
            const idx = e.currentTarget.dataset.index //保存传过来的index
            const list = this.data.list
            list.forEach((val,i) => {
                //遍历的索引和穿过来的点击索引值相等，表示点击了该对象，激活该对象的样式 
                i === idx ? val.isActive = true : val.isActive = false 
            })
        }
    }
})
```





### 事件监听

通过事件监听事件改变data值

wxml文件内：  绑定事件关键句 **bindtap**

**两种写法: bindtap或 bind:tap（1.5版本更新） 可读性更高**

``` vue
<view>当前计数:{{counter}}</view>
<button bindtap="btnClick">+</button>
<button bind:tap="btnClick">-</button>
```

js文件page实例内:

``` js
page({
    data:{
        counter: 0
    },
    btnClick(){
        this.data.counter += 1        
        console.log(this.data.counter) //错误写法，小程序不像vue，不会实时刷新页面数据
        
        //正确写法，调用setData()方法
        this.setData({
            counter: this.data.counter + 1   //传入要修改的data值
        })
    }
})
```



### 配置文件

很多开发需求被规定在配置文件中

常见的配置文件：

**project.config.json:**  项目配置文件，比如项目名称，appid等 （很少修改）

**sitemap.json:**  小程序搜索相关 （很少修改）

``` json
{
    "rules":[
        {
        "action": 'allow',   //屏蔽搜索就改成"disallow"
        "page": '*'   //通配符，表示所有页面都会被微信搜索到
        } 
    	]
}
```



**app.json :**  全局配置 （常用）

最常用的几个全局配置：

**pages**     类型：string     页面路径列表

``` json
"pages": [
    'pages/home/home', //默认加载第一行配置
    'pages/category/category'
]
```

**window**  类型：object     全局的默认窗口表现

``` json
"window": { //window的常用配置
    "navigationBarBackgroundColor": '#000000',  //顶部导航背景色，只支持16进制
    "navigationBarTextStyle": 'white',       //顶部导航按钮颜色，仅支持black/white
    "navigationBarTitleText": '我的小程序',  //小程序标题
    "backgroundColor": "#ffffff",         //主页面背景颜色 只支持16进制
    "enablePullDownRefresh": "true",   //是否支持下拉刷新 ,全局都会支持下拉刷新
    "backgroundTextStyle": 'dark' //修改下拉loading的样式，开启下拉刷新才有效,仅支持dark/light
}
```

**tabBar**    类型：object     底部tab栏表现

``` json
"tabBar": {
    
    "selectedColor": '#ffffff',  //文字选中时颜色，和list同级对象
    
    "list": [   //底部导航是一个list数组，每个对象代表一个对应的跳转路由
        {
            "pagePath": 'pages/home/home',  //该图标跳转到的页面路径
            "text": '首页',             //tabBar文本
            "iconPath": 'iconPath',    //图标路径
            "selectedIconPath": 'selectedIconPath'  //激活后的图标路径
        },
        {
            "pagePath": 'pages/home/home',
            "text": '分类',
            "iconPath": 'iconPath',
            "selectedIconPath": 'selectedIconPath'
        }
    ]
}
```



**page.json:**  页面配置 （常用） 页面配置优先级大于全局配置

``` json
"navigationBarTitleText": '分类'     //单独配置页面的标题，需在该页面对应的json文件内配置
```



### 小程序渲染原理

1. 渲染层 宿主环境(微信环境)把wxml转换成对应的js对象
2. 将js对象再次转换成DOM对象，交由渲染层渲染
3. 数据发生变化时，逻辑层提供变化的数据，js对象进行diff算法进行比较
4. 将新内容更新到DOM上，更新UI 实现局部刷新



### App生命周期函数

1. **onLaunch**: 监听小程序初始化 都会返回一个options参数

``` js
App({
    onLaunch: function(options){
    console.log(options) //包含了页面路径，页面参数，场景值等信息
}
})
```

2. **onShow:** 监听小程序启动或切前台  晚于onLaunch触发

``` js
App({
   onShow: function(options){
    console.log(options) //包含了页面路径，页面参数，场景值(scene)等信息
    
    wx.getUserInfo({    //wx自带的获取用户信息方法
        success: res => {  //默认会返回一个res对象，包含了用户信息
            console.log(res)
        }
    })
	} 
})
```

3. **onHide**: 监听小程序切后台

4. **onError**: 错误监听函数

5. **onPageNotFound:** 页面不存在监听函数

6. **onUnhandledRejection:**  未处理的Promise拒绝事件监听函数

7. **onThemeChange:** 监听系统主题变化



### App注册

1. 判断进入时的场景(小程序商城，分享，下拉框等等)

2. 监听生命周期，比如在某个生命周期获取用户信息

3. 因为app实例只有一个并且全局共享，所以可以将一些共享数据放进去

   ``` js
   //app.js内定义全局数据
   globalData: {
       userInfo: null
   }
   
   //home.js文件内获取该对象
   const app = getApp() //该方法获取app()内的示例对象，包括了globalData
   console.log(app.globalData.userInfo)  
   ```



### Page注册

1. 绑定初始化数据
2. 生命周期函数内的回调处理 (发送网络请求等)
3. 监听事件处理程序 (监听wxml内的事件，绑定对应事件处理程序)



### Page生命周期

生命周期

1. onLoad:  页面被加载出来时触发，只调用一次
2. onShow: 页面显示/切入前台 (隐藏后再次进入该页面，会再次调用该函数)
3. onReady: 页面初次渲染完成时 (仅在初次进入时调用，隐藏后再进入不会调用)
4. onHide: 页面被隐藏

页面事件

1. onPageScroll()  监听页面滚动，会传入一个对象，包含scrollTop值
2. onPullDownRefresh() 监听用户下拉刷新
3. onReachBottom()  监听用户上拉触底

``` js
//数据请求例子  page的3大组成  1.data 2.生命周期 3.事件监听
page({
    data: {   //1.页面初始化数据
        list: []
    },
    onLoad(){  //2.生命周期onload
        wx.request({  //小程序自带的网络请求方法request()
            url: 'http://xxxxx.com',
            success: res => {
                this.setData({   //注意要用小程序setData()方法赋值
                    this.data.list: res.data.list  //把请求到的数据赋值给当前新建对象
                })
            }
        })
    },
    onPageScroll(obj){ //3.相关事件监听处理程序 包括了自定义事件和页面事件
        console.log(obj)   //默认返回一个对象，包含scrollTop值，即滚动的距离
    },
    onReachBottom(){
        console.log('页面滚动底部了')
    },
    onPullDownRefresh(){
        console.log('页面发生下拉')  //需要在json文件内开启enablePullDownRefresh:true
    }
})
```

``` html
<!--home.wxml文件，组件同样也能被监听点击-->
<view bintap="viewClick">我是home页</view>
```

``` js
//home.js文件
page({
    viewClick(){
        console.log('home被点击了')
    }
})
```

home.json文件 允许上拉刷新，开启后监听事件onPullDownRefresh才有效

``` json
{ 
    "enablePullDownRefresh": true
}
```



### 常用内置组件

#### picker组件

```html
<!--range：渲染的数组或对象     range-key:当range是obj时，指定key作为显示内容 -->
<picker mode="selector" :range="shopList" range-key="store_name" @change="changeShop">
	<view>{{shopList[index].store_name}}</view>
</picker>
```



#### text组件

用于显示文本，类似span标签，是行内元素

``` html
<!--text的属性-->
<!--1.selectable: false 布尔值 文本是否能被选中,默认false 有2种写法-->
<text selectable="{{true}}">hello world</text>
<text selectable>hello world</text>

<!--2.space:决定文本空格大小 默认nbsp -->
<text space='ensp||emsp||nbsp'></text>

<!--3.decode:false 布尔值 是否解码 默认false -->
<!-- 解码后会显示5 > 3-->
<text decode>5 &gt; 3</text>  
```

#### button组件

默认样式是占满一行的块级元素

``` html
<!--1.button的属性 mini -->
<!-- button默认为独占一行的块级元素，添加mini属性变为行内元素-->
<button size="mini">按钮</button>

<!-- 2.button的样式 type属性 类似bootstrap效果-->
<button type="primary||default||warn">按钮</button>

<!--3.plain:镂空效果 默认false -->
<button plain>按钮</button>

<!--4.disabled:不可用 -->
<button disabled>按钮</button>

<!--5.open-type: 微信开放能力 获得特殊信息的权限，可绑定一些 特殊事件 -->
<button open-type='contact' bindContact='onContact'>客服会话</button>
<button open-type='share'>程序分享</button>
<button open-type='getPhoneNumber' bindgetPhoneNumber='getPhoneNumber'>获取电话</button>
<button open-type='getUserInfo' bindgetUserInfo='getUserInfo'>用户信息</button>

<!--6.hover-class: 点击时的样式 pressed在wxss样式文件内设置-->
<button hover-class='pressed'>按钮</button>
```

``` js
page({
    getPhoneNumber(e){  //传递过来的事件对象
        console.log(e.detail.errMsg)
        console.log(e.detail.iv)
        console.log(e.detail.encryptedData)
    },
    onContact(e){
        console.log(e.detail.path)   //小程序消息指定的路径
        console.log(e.detail.query)  //小程序指定的查询参数
    }
})
```



``` css
//wxss文件
.pressed {
    background-color: red;
    color: white
}
```



#### view组件

块级元素，独占一行，通常作为容器组件(类似div)

``` html
<view hover-class='style1'>我是容器组件div</view>
```



#### image组件

属性

1. src   类型：string    图片资源地址
2. mode 类型：string  图片剪裁缩放的模式 

**保持图片宽高比： mode="widthFix"  (修改宽度时，高度动态调整)|| "heightFix"(修改高度，宽度动态调整)**

1. lazy-load  类型：布尔      图片懒加载
2. binderror    类型:eventhandle     当错误发生时触发，event.detail = {errmsg}
3. bindload   类型eventhandle        当图片载入完毕时触发，event.detai = {height, width}
4. show-menu-by-longpress   布尔    是否开启长按识别小程序码菜单

**image有默认样式，为320*240px**

``` html
<!-- src支持本地地址(相对路径和绝对路径都可以)和远程地址-->
<image src='../../assets/img/xxx.jpg' lazy-load/>
<image src='/assets/img/xxx.jpg'/>
```



#### input组件

常用的几个属性

``` html
<!--1.value:input中的默认值 -->
<input value='哈哈哈'/>

<!--2.type:决定键盘类型(英文字母/数字/身份证) -->
<input type='text||number||idcard' />

<!--3.password:暗文显示-->
<input password />

<!--4.placeholder:占位文字 -->
<input placehoder />

<!--5.input绑定事件 -->
<input bindinput='handleInput'/>
<input bindfocus='handleFocus'/>
<input bindblur='handleBlur' />
```

``` js
page({
    handleInput: function(e){  //默认会传一个事件对象过来,输入的内容保存在e.detail中
        console.log('用户输入内容:',e.detail.value) //此处用逗号 不用加号
    }
})
```



#### scroll-view组件（局部滚动）

scroll-x: 水平滚动 

``` html
<scroll-view class='container' scroll-x>
    <view wx:for="{{10}}" class='item1'>{{item}}</view>
</scroll-view>
```

``` css
.container {
    white-space: nowrap;  //让子元素不换行
}

.item {
    height: 100px;
    width: 100px;
    margin: 10px;
    display: inline-block;  //因为view是块级元素，所以开启行内块级
}
```

scroll-y: 垂直滚动 略

滚动监听常用事件：

1. bindscroll  滚动时触发
2. bindscrolltoupper  滚动到顶部/左边时触发
3. bindscrolltolower 滚动到底部/右边时触发

``` html
<scroll-view class='container' scroll-y bindscroll='onScroll'>
    <view wx:for="{{10}}" class='item1'>{{item}}</view>
</scroll-view>
```

``` js
Page({
    onScroll(e){ //滚动时触发该事件，可拿到事件对象e.detail.scrolltTop等多个属性
        console.log('发生滚动',e)   
    }
})
```



#### swiper组件（轮播图）

``` html
/*swiper 外层容器
  swiper-item 每个轮播项
  swiper存在默认样式
 	1. width:100%
	2. height: 150rpx
*/
<swiper autoplay="{{true}}" interval="{{interval}}" circular="{{true}}"
        indicator-dots="{{true}}">
	<swiper-item><image src="" /></swiper-item>
    <swiper-item><image src="" /></swiper-item>
    <swiper-item><image src="" /></swiper-item>
</swiper>
```



#### icon组件

icon属性：

1. type: 图标的类型
2. color: 图标的颜色
3. size: 图标的大小

``` html
<icon type="success" color="#00ff93" size="60"></icon>
```



#### radio组件

注意：radio需要搭配**radio-group**组件一起使用，才能监听事件，事件会传回事件对象event, 包含了value

```html
<radio-group bindchange="handleChange">
	<radio value="male"/>男性
    <radio value="female"/>女性
</radio-group>
```



#### checkbox组件

和radio一样，需要搭配checkbox-group一起使用

``` html
<checkbox-group bindchange="handleChange">
	<checkbox value="xxx">美国</checkbox>
    <checkbox value="aaa">中国</checkbox>
    <checkbox value="ccc">日本</checkbox>
</checkbox-group>
```



#### rich-text富文本组件

``` html
<!--用于显示后台返回的富文本内容 搭配nodes属性绑定富文本数据-->
<rich-text nodes="{{res.data}}"></rich-text>
```

**富文本内容替换webp格式图片**

``` js
//iphone不兼容webp格式，前端处理方法
this.setData({								//正则查询所有webp格式替换成jpg
    goodsContent: res.data.goods_introduce.replace(/\.webp/g,'jpg')
})
```





#### 组件的公共属性

id, class, style  

hidden(布尔值)组件是否显示，默认显示， 

bind* /  catch*  监听组件事件



### wxss知识点

#### wxss写法

wxss和css一样也支持3种样式写法： 1.内联样式 2.页内样式 3.全局样式

1.内联样式和css一样，键值对形式，用 ; 号分隔

``` html
<view style='color: red; font-size: 12px;'></view>
```

2.页内样式：在page.wxml对应的 page.wxss内写  

3.全局样式：在app.wxss内写

优先级：内联>页内>全局

#### rpx：相对单位

在375px (iphone6)宽度设备上，rpx的值刚好是px的一半，rpx在改变窗口大小时会进行自适应调整

iphone5    1rpx = 0.42px

iphone6    1rpx = 0.5px

iphone6P  1rpx = 0.552px



### 官方样式库WeUI.wxss

地址:https://github.com/tencet/weui.wxss

下载后导入（导入dist文件夹）到本地项目中，直接复制项目中的wxml,wxss代码即可



### mastache语法细节

``` html
<!--实现空格-->
<view>{{firstName}} {{lastName}}</view>
<view>{{firstName + ' ' + lastName}}</view>
<view>{{age > 18 ? '成年' : '未成年'}}</view>

<!--绑定样式也使用大括号，在js中定义isActive进行绑定 此处绑定了一个btn样式和一个动态样式-->
<button class='btn {{isActive ? "active" :""}}'>
    
</button>
```



### wx:if / wx:elif / wx:else 条件判断

3个条件都是等于true时进行渲染

``` html
<view wx:if='{{score >= 90}}'>优秀</view>
<view wx:elif='{{score >= 80}}'>良好</view>
<view wx:else>其他</view>
```

#### wx:if和hidden区别

wx:if   对DOM进行操作，在DOM树内删除该元素

hidden   对元素设置了display:none样式 使其隐藏



### wx:for 列表渲染

渲染数组 所有遍历的对象都必须放在{{}}中，否则会被当成字符串处理

``` html
<!--直接遍历数字 -->
<view wx:for='{{10}}'>{{item}}</view>
<!--遍历数组 插入[]-->
<view wx:for='{{["aaa","bbb","ccc"]}}'>item</view>
```

#### block标签

主要用来包裹组件，只接受控制属性(wx:for wx:if)，不会进行任何渲染，仅需要包裹组件时使用，比view性能好

#### 绑定key的作用 

wx:key=""    此处不需要{{}}

**提高页面性能，**如在遍历的对象中插入数据时，可以避免页面重新对每个节点进行更新，直接进行插入操作

key的原理是对每一个数据绑定一个id ，当发生数据变化时先判断id是否有改变，没改变则直接进行插入操作

![image-20210301103340261](C:\Users\yoki\Desktop\绑定key的作用.png)



### template模板 import / include

早期小程序不支持自定义组件时，使用template模板代替 (现在使用较少)

**循环导入概念:** a导入了b, c再导入a, c不能显示b的内容 会报错 

import和include区别：

import**导入的是template模板**，导入后需要用is关键词绑定该模板才能显示, **import不能循环引入**

include**不能导入template，导入除了template,wxs以外的定义好的文件，include可以循环引入**

``` html
<!--1.定义模板  template标签必须有name属性，template标签的内容不会渲染-->
<template name='contentItem'>
	<button>{{btnText}}</button>
    <view>{{content}}</view>
</template>

<!--2.使用模板  使用is绑定模板 使用data绑定数据-->
<template is='contentItem' data='{{btnText: "按钮", content: "你好"}}'></template>
<template is='contentItem' data='{{btnText: "警告", content: "大家好"}}'></template>

<!--3.import 在别的wxml文件内导入这个模板  使用<import src=''>标签导入
	   新建一个template.wxml文件保存模板 绝对路径和相对路径都可以导入-->
<import src='/wxml/template.wxml'/>
<import src='../../wxml/template.wxml'/>
<!--is绑定后显示该模板-->
<template is='CompoName' /> 

<!--4.include: 引入 在页面中使用定义好的wxml文件-->
<!--header.wxml-->
<view>
	<view>我是头部</view>
    <view>导航</view>
</view>
<!--直接使用定义好的header.wxml-->
<include src='/wxml/header.wxml'/>
<!--在底部使用定义好的footer.wxml-->
<include src='/wxml/footer.wxml'/>
```



### WXS模块

为什么要使用wxs语言：

在wxml中不能直接调用page/component中定义的函数，但某些情况希望使用函数来处理wxml中的数据

（类似Vue中的过滤器），这时需要使用WXS

WXS的限制：

1. wxs的运行环境和其他JS代码时隔离的，WXS不能调用其他js文件中定义的函数，也不能调用小程序提供的API
2. wxs函数不能作为组件的事件回调

wxs使用方法:

``` html
<!--1.直接在wxml内使用,写在<wxs>标签内 必须写上module属性-->
<wxs module='info'>
	var name = 'david'
    var func = function(sum1,sum2){
    	return sum1 + sum2
    }
   <!--2.不能忘记导出-->
	module.export = {
    	name: name,
    	func: func
    }    
</wxs>

<view>{{info.name}}</view>
<view>{{info.func(20,30)}}</view>
```

``` js
//2.单独写在wxs文件内
var name = 'david'
var func = function(sum1,sum2){
    	return sum1 + sum2
    }

module.export = { //记得导出
    name: name,
    func: func
   }  
```

``` html
<!--在对应wxml文件内导入wxs文件-->
<wxs src='./wxs/info.wxs' module='info'></wxs>
<view>{{info.name}}</view>
<view>{{info.func(20,30)}}</view>
```



### 组件通用事件

button组件：tap等

小程序内的事件不能直接传参

``` html
<!--错误，不能直接传参，只能通过自定义属性传参-->
<button bindtap="increment(1)">+</button> 
<!--正确写法，通过自定义属性传参-->
<button bindtap="increment" data-num="{{1}}">+</button>
```



input组件: input/blur/focus等

scroll-view组件： scrolltoupper/scrolltolower等

组件通用事件:

touchstart  手指触摸开始时触发

touchmove 手指触摸后移动时触发

touchcancel 手指触摸后被打断，如来电，弹窗

touchend 手指触摸动作结束

tap 手指触摸后马上离开

longpress 手指长按超过350ms，若指定了该事件，则不会触发tap事件

``` html
<!--监听手指触摸-->
<view bind:touchstart="handleStart"
      bind:touchend="handleEnd"
      bind:longpress="handlePress">
    我是盒子</view>

```



### 事件对象(event)

当某个事件触发时会产生一个事件对象，并且会传入回调函数中

事件对象的常用属性:

type 事件类型

timeStamp 页面打开到触发事件所用的毫秒数

target   触发事件的组件的一些属性值集合

currentTarget  当前组件的一些属性值集合

detail 额外信息  (点击事件时，会返回点击时的坐标x,y)

touches  触摸事件，当前停留在屏幕中的触摸点信息的数组

changedTouches   触摸事件，当前变化的触摸点信息的数组



### 事件的参数传递

#### dataset 和 detail

1. data-xxx 传参 保存在事件对象的**event.target.dataset**中
2. 子传父 this.triggerEvent('fn',{参数})   参数保存在事件对象**event.detail**属性中

``` js
Page({
    data: {
        titles: ['热门','流行','时尚']
    },
    handleClick(event){
        const index = event.target.dataset.index  //传递过来的参数保存在了dataset中
        const item = event.target.dataset.item
        console.log(index,item)
    }
})


```

``` html
<view wx:for="{{titles}}" 
      wx:key="index" 
      bindtap="handleClick"
      <!--使用自定义属性：data-传递数据-->
      data-index="{{index}}"
      data-item="{{item}}">
	{{item}}
</view>
```



### 事件冒泡和捕获

**事件捕获:  capture-bind:tap**  当点击最里层组件时，事件会从最外层捕获到最里层

**事件冒泡:  bindtap**   从最里层冒泡到最外层

对当前组件使用catch会阻止事件的下一步传递

``` html
<!--catch:阻止事件进一步传递-->
<!--capture:事件捕获，从最外层捕获到最里层-->
<view capture-bind:tap="handleCapture1" bindtap="handleBind1">
	<view capture-bind:tap="handleCapture2" bindtap="handleBind2">
        <!--这里对最里层使用了catchtap,此时事件不再冒泡-->
    	<view capture-bind:tap="handleCapture3" catchtap="handleCatch"></view>
    </view>
</view>
```



### 自定义组件

创建：在根目录新建components文件夹保存自定义组件，再右键“新建component" 

会自动创建对应的json/wxml/wxss/js 4个文件 其中json文件内的 **"component": true**是自定义组件可用的关键配置，不能删除

局部注册:  在想用的page对应的json文件内注册组件, 使用key/value形式注册，value值是组件路径，可使用绝对路径和相对路径

#### Component构造器内部属性

``` js
Component({
    data:{ //定义组件内部数据
        
    }，
    properties: { //定义外部调用组件时传过来的数据
    	
	},
    methods: {  //定义组件内部方法
          
    },
    options: { //定义组件的一些额外配置,如启用多插槽、父子组件样式是否通用
        multipleSlots: true,
        styleIsolation: 'share'||'apply-shared'||'isolated(默认)'
    },
    externalClasses: [ //定义外部调用组件时传过来的额外样式，注意是数组
        
    ],
    observers: { 	//监听properties/data中数据的改变
        counter: function(newValue){  //监听data中counter的改变，这里只会传入一个newValue
            
        }
    },
    //------------组件中监听生命周期函数-------------
    //1.监听页面生命周期
    pageLifeTimes: {
		show() {
            console.log('监听页面显示时')
        },
        hide(){
            console.log('监听页面隐藏时')
        }
    },
   	//2.监听组件本身生命周期
    lifeTimes：{
        created() {
            console.log('监听组件被创建')
        },
        attached(){
           console.log('组件被添加到页面') 
        } ,
        ready(){
          	console.log('组件被渲染出来')  
        },
        detached(){
            console.log('组件被移除时')  //如触发wx:if="{{false}}"
        }
    }
})
```



**全局注册：**

**app.json文件内注册，这样全局都可以使用该组件了**

``` json
{
    "usingComponents": {
        "my-cpn": "/components/my-cpn/my-cpn" 
	}
}
```

#### 自定义组件样式相关

组件内样式对外部样式的影响：

1. 组件内的class样式不会影响引用页的样式

2. 组件内不建议使用id选择器，属性选择器，标签选择器

外部样式对组件内样式的影响：

1. 外部样式使用class样式，只对外部wxml生效，对组件内不生效
2. 外部样式使用id选择器，属性选择器不对组件内生效
3. **外部使用标签选择器，会对组件内生效**

PS:官方不推荐使用id,标签，属性选择器

使样式能相互影响：

组件js文件内 

``` js
component({
    options: {
        styleIsolation: 'isolated(默认值)'|| 'apply-shared(页面影响组件)' || 'shared(互相影响)'
    }
})
```



#### 组件通信

![](C:\Users\yoki\Desktop\组件通信.png)



#### 父传子 数据:properties

``` js
//子组件js文件：
component({
    properties: {
        xxxdata: {    //接收的数据格式和名字
            type: String,
            value: '默认值'
        } 
    }
})
```

``` html
<!--子组件wxml文件-->
<view>{{xxxdata}}</view>
```

``` html
<!---父组件wxml文件 把david传给子组件-->
<my-cpn xxxdata="david"/>
```



#### 父传子 样式:externalClasses

``` js
//子组件js
component({
    externalClasses: ['propclass']  //是一个数组对象，传递的类名不能用驼峰
})
```

``` html
<!--子组件wxml-->
<view class="propclass">xxxxxx</view>
```



#### 子传父 自定义事件

``` html
<!--子组件wxml-->
<button bindtap="increment">+1</button>
```

``` js
//子组件js文件
Components({
    methods: {
        increment(){
            //此处通过triggerEvent方法发射自定义事件，并定义事件名
            this.triggerEvent('handleIncrement',{})
        }
    }
})
```

``` html
<!--父组件wxml 接收自定义事件--->
<my-event bind:handleIncrement="handleIncrement"/>
```

``` js
//父组件js
data: {
    counter: 0
}
handleIncrement(){
    //通过触发的事件修改数据
    this.setData({
        counter: this.data.counter + 1
    })
}
```



#### 父组件直接调用子组件中的数据

子组件my-cpn的wxml&js:

``` html
<view>我是子组件啦啦啦</view>
```

``` js
Component({
    data: {
        counter: 0
    }
})
```

父组件wxml&js:

``` html
<button bindtap="changeData">修改组件中的数据</button>

<!--1.此处需要给子组件一个class或者id供父组件调用-->
<my-cpn id='sel-id' class='sel-class'></my-cpn>
```

``` js
changeData(){
    //2.使用selectComponent()方法
	const my_sel = this.selectComponent('.sel-class')  
    console.log(my_sel)  //返回一个对象，子组件的counter保存在my_sel.data属性内
    my_sel.incrementCounter(10)  //调用组件自己的方法对data进行修改
}
```



### slot插槽

#### **单个插槽:**

子组件:

``` html
<!--子组件设置一个插槽-->
<view>
	<view>我是头部</view>
    <slot></slot>
    <view>我是尾部</view>
</view>
```

父组件:

``` html
<my-slot>
    <!--父组件调用时直接插入内容即可-->
	<text>我是插入的内容</text>
</my-slot>
```

#### **多个插槽：**

注意点：

1. 插槽需要定义name属性
2. **需要在js内添加options属性 ---> multipleSlots: true**

``` html
<view>
	<view>我是头部</view>
    <slot name="slot1"></slot>
    <slot name="slot2"></slot>
    <slot name="slot3"></slot>
    <view>我是尾部</view>
</view>
```

``` html
<my-slot>
	<text slot="slot1">我是1内容</text>
    <text slot="slot2">我是2内容</text>
</my-slot>
```



### 微信官方API

官方API都在开发文档的API界面下

#### 网络请求：wx.request

request常用属性:

url: 请求地址  (必传)

data: 请求的参数

header: 设置请求的header, header中不能设置referer,content-type默认值为application/json

method: 请求的方法    get(默认)||post

dataType:  返回的数据格式  大部分都是Json格式

responseType: 响应的数据类型   大部分都是文本，图片之类数据，一般无需设置

success:  请求成功的回调函数

fail: 请求失败回调函数

complete:  请求结束回调函数(成功或失败都会执行)

``` js
Page({
    onload: function(options){
		wx.request({
            url: 'http://xxxx.com',  //需要在小程序内配置域名列表，否则报错
            data:{
                type: 'pop',   //请求有额外参数的接口
                page: 1
            }
            success: function(res){
                console.log(res)
            }
        })
    }
})
```

 #### 网络请求封装

``` js
//封装网络请求方法request.js 使用promise方法进行包装
export default function request(options){
    return new Promise((resolve,reject) => {
        wx.request({
            url: options.url,
            data: options.data,
            method: options.method || 'get',
            success(res){
                resolve(res)
            },
            fail(err){
                reject(err)
            }
        })
    })
}

//外部文件调用该方法 可以链试调用then()获取数据，更优雅，且代码耦合度更低
import request from './network/request.js';
request({
    url: 'xxx.com',
    method: 'get',
}).then(res => {
    console.log(res)
}).catch(err => {
    console.log(err)
})
```



#### 页面回到顶部wx.pageScrollTo

``` js
wx.pageScrollTo({
    scrollTop: 0
})
```



#### 获取用户信息getUserProfile

取代getUserInfo的新接口

```js
wx.getUserProfile(e){
    desc: 'XXX用途',  //声明用途，会展示在弹窗中
    success: res => {
        console.log(res)
    }
}
```



#### 弹窗API

小程序弹窗有4种类型:**showToast, showModal, showLoading, showActionSheet**

``` html
<button bindtap="onToastClick">showToast</button>
<button bindtap="onModalClick">showModal</button>
<button bindtap="onLoadingClick">showLoading</button>
<button bindtap="onActionSheetClick">showActionSheet</button>
```

``` js
onToastClick(){
    wx.showToast({
        title: '你好',  //提示的文本
        duration: 3000,  //toast持续时间
        icon: 'loading', //icon图标 有loading success等 可在官方文档中查看
        mask: true,  //蒙板  弹窗时按钮不可点击
        success: function(){
            console.log('展示成功')
        },
        fail: function(){},
        complete: function(){}
    })
}

onModalClick(){
    wx.showModal({
        title: '我是标题',
        content: '我是内容',
        showCancel: true,
        cancelText: '返回',
        cancelColor: '#fff',
        success(res) {
            if(res.confirm){
                console.log('用户点击了确定')
            }
            if(res.cancel){
                console.log('用户点击了取消')
            }
        }
    })
}

//一般网络请求使用showLoading，在数据成功返回的回调函数内调用hideLoading()
onLoadingClick(){
    wx.showLoading({   //showLoading会一直展示
        title: '加载ing', 
        mask: true
    })
    setTimeout(() => {  //必须调用hideLoading()才能隐藏showLoading
        wx.hideLoading()
    },2000)
}

onActionSheet(){
    wx.showActionSheet({
        itemList: ['相册','拍照'],  //从底部展示一个弹窗，选择相册和拍照
        itemColor: '#fff',
        success(res => {
         	console.log(res)        
        })
    })
}
```



##### wx.showLoading 

```js
//1.把wx.showLoading()封装到请求方法中，这样可以避免每次网络请求都写一遍
//2.当一个页面有多个异步请求时，不能在一个请求完成后就直接调用wx.hideLoading(),
//  而是在所有请求完成后再执行wx.hideLoading()

let ajaxTimes = 0 //声明一个变量，表示同时发送异步请求的次数
export function request(options){
    ajaxTimes++;  //每调用一次请求，ajaxTimes +1
    wx.showLoading({  //显示加载弹窗
        title: '加载中',
        mask: true //蒙板
    })
    return new Promise((resolve,reject) => {
        const baseURL = 'xxxx'
        wx.request({
            url: baseURL + options.url,
            method: options.method || 'get',
            success: (res) => {
                resolve(res)
            },
            fail: (err) => {
                reject(err)
            },
            complete: () => {
                ajaxTimes--   //完成请求后ajaxTimes-1
                if(ajaxTimes===0){//ajax=0表示所有请求都完成，此时再调用hideLoading
                    wx.hideLoding() 
                }
            }
        })
    })
}
```



#### 预览图片wx.previewImage

```js
wx.previewImage({
    url: [],    //要预览的图片数组
    current: currentImage  //当前要显示的图片
})
```

#### 获取用户地址wx.chooseAddress

```js
wx.chooseAddress({
    success:(res) => {
		console.log(res)}
})
```

#### 上传图片wx.chooseImage

```js
wx.chooseImage({ //打开图片选择窗接口
    count: 9,  //最大可上传图片数
    success: (res) => {
        // 上传成功后回调函数，res会返回图片的临时路径，可保存后对页面渲染
    },
    fail:
    complete: 
})
```

#### 上传文件至服务器wx.uploadFile

``` js
wx.uploadFile({  //该方法一次只能传一个文件或一张图，要传数组时只能遍历后逐个上传
    url: '',  //图片要上传到哪
    filePath: '', //被上传的图片路径
    name: '',     //文件名，可自定义
    formData: {},   //额外要传的信息
    success: () => {
        
    },
    fail:
    complete:
})
```





### 分享wx.onShareAppMessage

page页面配置onShareAppMessage()方法

``` js
Page({
    onShareAppMessage: function() {
        title: '分享的标题',
        path: 'pages/home/home', //分享的页面路径
        imageUrl: '本地图片或网络图片'  //分享显示的图片，不配置默认显示当前页缩略图
    }
})
```

直接在button键上进行分享，设置open-type属性，直接调用分享接口

``` html
<button open-type="share">分享</button>
```



### 登录wx.login

客户端（小程序） ----》自己的服务器-------》微信接口服务

1. 调用wx.login，微信返回一个code
2. 调用wx.request发送code到自己的服务器，服务器携带code和appid请求微信，微信返回session-key ,openid, 服务器对openid进行关联，返回一个登录态标识token给客户端
3. 前端将登录态标识token进行储存(保存在storage中)，以便下次使用
4. 请求需要登录态标识的接口时，携带token

 **登录请求一般放在app.js----》onLounch生命周期内，即小程序加载完就进行登录请求**

``` js
App({
    globalData: {  //创建一个globalData保存token
        token : ''
    },
    onLounch(){
        wx.login({
            //login接口会返回一个res, 其中res.code就是要用的，只有5分钟有效期
            success: res => {
                console.log(res.code)
                const code = res.code
                
                wx.request({
                    url: 'http://123.207.32.32:3000/login',
                    method: 'post',
                    data: {
                        code   //把拿到的code发送给服务器
                    },
                    success: res => {
                        console.log(res.data.token) //服务器返回拼接好的token (服务端处理)
                        //1.保存token到globalData中
                        //别的页面调用: const app = getApp()   app.globalData.token
                        //保存到globalData中的缺点: 
                        //globalDAta是一个对象，小程序关闭内存就会回收，globalData也没了
                        const my_token = res.data.token
                        this.globalData.token = my_token
                        
                        //2.保存Token到本地  wx.setStorage()方法
                        wx.setStorage('token',token)
                    }
                })
            }
        })
    }
})
```

#### 本地缓存 storage

获取本地缓存: **wx.getStorageSync('token')**

保存数据到本地缓存： **wx.setStorageSync('token',my_token)**



### 页面跳转

页面跳转有2种方式:  **1.navigator组件**    **2.wx.navigateTo**

#### wx.navigate跳转

open-type属性：

1.navigate:保留当前界面，跳转到应用内的某个界面
 2.redirect：关闭当前界面，跳转到应用内的某个界面
 3.reLaunch：关闭所有页面，打开跳转的页面
 4.switchTab：跳转到TabBar页面，关闭其他非tabBar页面

 ``` html
<navigator url="/pages/about/about" open-type="跳转的形式">跳转到关于页</navigator>
 ```

navigator默认不允许跳转到tabBar页面,必须加**open-type="switchTab"**属性

```html
<navigator open-type="switchTab" url="/pages/xxx/index">xxx</navigator>
```



#### 页面跳转参数传递

正向：首页---->详情页传递数据

``` html
<navigator url="/pages/detail/detail?name=david&age=33" >跳到详情页</navigator>
```

```js
//对应detail.js文件 url携带的参数会传到onLoad生命周期函数内
Page({
    onLoad: function(options){
        console.log(options)  //options内包含name: 'david', age:33 
    }
})
```





反向：详情页----->首页传递数据

``` js
//从详情页返回时，修改首页数据
Page({
    onUnload: function(){ //在页面发生关闭时传递
        const pages = getCurrentPages() //全局方法，获取当前页面对象
        const home = pages[pages.length - 2] //pages返回一个数组，使用-2获取home对象
        home.setData({
            title: '要修改的值'   //修改title数据
        })
    }
})
```



#### 通过API跳转

``` html
<button bindtap="toDetail">跳到详情页</button>
```

```js
Page({
    toDetail(){
        wx.navigateTo({
            url: '/pages/xxx'
        })
    }
})
```



### 引入iconfont注意点

因为小程序是wxss格式，直接import css文件会编译错误，应该把iconfont.css拷贝并新建一个wxss文件内



### wxss样式初始化

因为小程序不支持通配符*，所以要一个个标签初始化

``` css
text,view,swiper,swiper-item,image,navigator {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
```



### 添加本地缓存

思路：

1. 判断本地是否有旧数据

   储存数据格式: 时间戳和数据本身，**{time: Date.now(), data: [...] }**

2. 如果有 ，且没有过期，怎么使用本地数据

3. 如果没有，则发送请求

``` js
//1.获取缓存
const titles = wx.getStorageSync('titles')
//2.判断缓存是否存在
if(!titles) { //不存在，进行数据请求
    getCategory().then(res => {
	this.setData({
        goodsLists: res.data.message
    })
        //把数据保存到缓存里，保存字段是{time: Date.now(),data: xxx}
        wx.setStorageSync('titles',{time:Date.now(),data: res.data.message})
    })
    //判断当前时间和缓存中的时间戳间隔，大于1000则重新请求
}else if(Date.now() - titles.time > 1000){
    getCategory().then(res => {
	this.setData({
        goodsLists: res.data.message
    })
        wx.setStorageSync('titles',{time:Date.now(),data: res.data.message})
    })
}else{  //使用缓存数据
    this.setData({
        goodsList: titles.data
    })
}
```

小程序和web原生缓存使用区别

``` js
//1.方法不同
//原生
localStorage.setItem('key','val')
localStorage.getItem('key')
//小程序
wx.setStorageSync('key'，'val')
wx.getStorageSync('key')

//2.保存方式不同  原生会对键值对做toString处理，小程序不会处理
```



### data同层级临时数据

在Page或Component里，data同层级也可以放一些**不与渲染层交互**的临时变量

``` js
Page({
    data: {
        obj
    },
    //data同层级的临时数据
    goodsList: [],
    
    onload: function(){ 
        //直接使用this调用即可
        this.goodsList = res
    }
})
```



### 滚动触底加载下一页

思路：

1. 在onReachBottom回调函数内触发
2. 判断是否有下一页
   1. 获取总页数:  **Math.ceil( 总条数 / 每页条数 )**
   2. 获取当前页数
   3. 判断当前页数 >= 总页数   大于等于则没有下一页
3. 没有下一页，则弹出一个提示
4. 有下一页，则加载
   1. **当前页码 +1** 
   2. 重新发送请求
   3. 对请求回来的**数据进行拼接** (原页码数据+新页码数据)

```js
const total = res.data.total //获取总数据条数
const totalPages = Math.ceil( total / this.queryParam.pagesize) //总页码 / 每页条数

onReachBottom: function() {
    if(this.queryParam >= this.totalPages){ //当前页码大于等于总页码，提示没有下一页
		wx.showToast({
            title: '没有下一页了',
            icon: 'none'
        })
    }else {
        this.getGoodsList().then(res => {
            this.queryParam.pagenum += 1 //关键1：请求页码+1
            const oldPage = this.data.goodsList
            this.setData({
                goodsList: [...oldPage, ...res.data.goods] //关键2：解构数组并进行拼接
            })
        })
    }
}
```





### 触发下拉刷新

1. 在onPullDownRefresh函数内触发(json内记得开启配置**enablePullDownRefresh** )
2. 重置数据和页码
3. 重新发送请求



### 点击 加入购物车

​	1.绑定点击事件

​	2.获取缓存中的购物车数据(一般都为数组)

​	3.判断当前商品是否已存在购物车中

4. 若存在，则商品数量+1 ，重新添加到缓存中
5. 若不存在，直接给购物车数组添加新元素，重新添加到缓存中



### 生命周期函数注意点

不能用es6语法写生命周期，会报错

``` js
onShow: () => { //es6箭头函数会报错
    
}
//必须用es5写：
onShow: function(){
    
}
```



### 小程序页面栈getCurrentPages()

用户每访问一个页面并跳转，小程序会把页面存入页面栈数组中

获取当前页面对象：页面栈数组的最后一个元素

```js
let pages = getCurrentPages()  //拿到页面栈数组
let currentPage = pages[pages.length - 1]   //数组的最后一位就是当前页面对象
console.log(currentPage.options)  //url中传过来的参数也可以在这拿
```





### 微信支付

1. 仅企业账号可以实现支付功能
2. 企业账号的小程序后台必须给开发者添加白名单
   1. 一个appid可以绑定多个开发者
   2. 这些开发者可以共用这个appid和开发权限
   3. 先判断缓存中是否有token,若没有则跳转到授权页面

#### 支付流程

 1. **获取code:**先通过wx.login接口**获取用户code**

 2. **获取token:**把code传给自己的后台登录接口，通过自己后台的登录接口**获得token**

 3. **创建订单**：根据创建订单接口所需参数，传入token和对应的参数，**获取返回的订单编号**

 4. **获取支付参数**：把订单编号和token发送给支付参数接口，**返回支付参数pay(调用微信支付必须的参数)**

 5. **发起支付：**提交pay参数，调用**wx.requestPayment** 发起微信支付

 6. **查询订单:**  在requestPayment的success回调中 发起查询后台订单请求，根据返回值判断是否支付成功

  7. 支付成功后，**删除购物车中已选中的数据，并更新缓存**



### 优化支付请求

对带有登录态的接口进行判断：

1. 带有登录态的接口：创建订单，获取支付参数，发起支付，查询订单等接口都需要在请求头中传token
2. 对url进行判断，登录态接口的格式一般为 **/my/**xxx/xxx  判断url中的/my/





### 没有声明的data,也可以直接在setData中使用



### wx.getLocation

```js
wx.getLocation({
 type: 'wgs84',   //gps坐标
 success (res) {
   const latitude = res.latitude   //纬度
   const longitude = res.longitude //经度
   const speed = res.speed    	//速度 m/s
   const accuracy = res.accuracy //位置的精确度
 }
})
```

### wx.getSystemInfo

success内返回品牌，型号，屏幕宽高，可使用宽高，客户端平台，当前运行环境等

```js
wx.getSystemInfo({
  success (res) {
    console.log(res.model)
    console.log(res.pixelRatio)
    console.log(res.windowWidth)
    console.log(res.windowHeight)
    console.log(res.language)
    console.log(res.version)
    console.log(res.platform)
    console.log(res.environment)
  }
})
```



### 控制遍历的数据条数

遍历5条之后的数据就不显示了

```html
<view wx:for="{{dataList}}" wx:key="{{index}}" wx:if="{{index <= 5}}"></view>
```



### openSetting

```js
onAuthorize() {
			    let self = this;
    			//打开用户的权限设置列表，根据返回的用户权限设置进行相关操作
			    uni.openSetting({
			      success(res) {
                      //查看用户是否授权地理位置
			        if (res.authSetting["scope.userLocation"]) {
			          console.log('授权成功');
					  self.isAuthor = true;
			          setTimeout(() => {
			            // 获取用户坐标
			            self.getLocation((res) => {
			             
			            });
			          }, 1000);
			        }
			      }
			    })
			  },
			/**
			 * 封装获取用户坐标
			 */
			getLocation(callback) {
				let self = this;
				uni.getLocation({
					type: 'wgs84',
					success(res) {
						self.longitude = res.longitude;
						self.latitude = res.latitude;
						self.getData();
					},
					fail() {
						uni.showToast({
						    title: '获取定位失败，请点击右下角按钮打开定位权限',
						    duration: 2000,
							icon:'none'
						});
						self.isAuthor=false;
					},
				})
			},
```

### wx.getSetting

获取用户的当前设置。**返回值中只会出现小程序已经向用户请求过的[权限](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html)**。

```js
wx.getSetting({
  withSubscriptions: true,
  success (res) {
    console.log(res.authSetting)
    // res.authSetting = {
    //   "scope.userInfo": true,
    //   "scope.userLocation": true
    // }
    console.log(res.subscriptionsSetting)
    // res.subscriptionsSetting = {
    //   mainSwitch: true, // 订阅消息总开关
    //   itemSettings: {   // 每一项开关
    //     SYS_MSG_TYPE_INTERACTIVE: 'accept', // 小游戏系统订阅消息
    //     SYS_MSG_TYPE_RANK: 'accept'
    //     zun-LzcQyW-edafCVvzPkK4de2Rllr1fFpw2A_x0oXE: 'reject', // 普通一次性订阅消息
    //     ke_OZC_66gZxALLcsuI7ilCJSP2OJ2vWo2ooUPpkWrw: 'ban',
    //   }
    // }
  }
})
```



### onlaunch(e)的返回值

```js
e:{
    path: "Catering/pages/selectNum/selectNum"
	query: {seat_id: "1", wxapp_id: "10001", shop_id: "10001"}  //进来的url携带的参数
	referrerInfo: {}
	scene: 1001
}

```

### wx.getUserProfile

```vue

<button class="btn_black"  lang="zh_CN" bindtap="authorLogin">登录</button>

<script>
	authorLogin: function () {
    let _this = this 
    wx.getUserProfile({  //调用改方法拿到用户昵称和头像
      desc: '完善会员资料',
      success(e){
        console.log(e,'同意授权')
        wx.showLoading({
          title: '正在登陆',
          mask: true
        })
        wx.login({
          success(res){
            App._post_form('?s=/api/user/login', {
                  code: res.code,
                  user_info: e.rawData,
                  encrypted_data: e.encryptedData,
                  iv: e.iv,
                  wxapp_id: 10002,
                  shop_id: App.shop_id,
                }, function (result) {
                  console.log(result.data.user_info)
                  // 记录token user_id
                  wx.setStorageSync('token', result.data.token);
                  wx.setStorageSync('user_id', result.data.user_id);
                  _this.setData({
                    isLogin: true,
                    userInfo: result.data.user_info
                  })
                  wx.showToast({
                    title: '登录成功',
                  })
                }, false, function () {
                  wx.hideLoading();
                });
          }
        })
      },
      fail: err => {
        console.log(err,'用户拒绝授权')
      }
    })
</script>
```



### 注意点:

### navigateTo跳转方法每次都会触发onLoad

### SwitchTab只会触发onLoad一次



### van-popup组件用法

```html

<!--弹窗实例-->
<van-popup show="{{isShowSeatList}}"
    	custom-style="width: 80%;border-radius: 8rpx;"
    	closeable position="center" bind:close="onClose">
    <view class="seat-container">
      <view class="seat-title">目前可选桌位</view>
      <view class="seat-list">
        <block wx:for="{{seatList}}">
        <view class="seat-item {{currentIndex === index ? 'active' : ''}}" 
        data-index="{{index}}" bindtap="chooseSeat" >
          {{item.seat_name}}
        </view>
      </block>
      </view>
      <view class="btn-group">
        <button size="mini" bindtap="changeTable" class="confirm-btn">确认换桌</button>
        <button size="mini" bindtap="onClose">取消</button>
      </view>
    </view>
</van-popup>
```

### form表单用法

```html
<form bindsubmit="mixSubmit">
  <block wx:for="{{payTypes}}">
  <view wx:if="{{item.value != 1000}}" class="mix-item">
    <!-- 给每个表单组件绑定name后才能通过bindsubmit获取到所有表单数据 -->
    <text>{{item.name}}: </text><input name="{{item.value}}" type="number" placeholder="请输入金额" bindinput="mixInput" />
   </view>
   </block>
  <view class="btn-group">
      <button size="mini" form-type="submit" class="confirm-btn">确认</button>
      <button size="mini" bindtap="onClose">取消</button>
  </view>
</form>
```

```js
mixSubmit(e){
    //e.detail.value 就是表单的数据
}
```

### picker用法

```html
<picker :range="order.coupon_list" 
        range-key="name" 
        @change="selectCoupon"
		v-if="order.user && order.coupon_list && order.coupon_list.length > 1">
	<view class="section-coupon-info"
		:style="selectCouponName == '不使用优惠券' ? 'filter:grayscale(100%)' : ''">
		{{ selectCouponName || '请选择优惠券' }}
		<image src="/static/images/icon-down.png" mode=""></image>
	</view>
</picker>

<!--JM优惠券 coupon: 优惠券列表 range-key必须设置，是picker内要显示的字段名字 -->
<picker range="{{coupon}}" 
        range-key="name" 
        bindchange="changeCouponPicker">
      <view class="popup-item-value">{{coupon[coupon_index].name || '请选择优惠券'}}</view>
</picker>
```

```js
  changeCouponPicker(e) {
    let index = e.detail.value
    this.setData({
      coupon_index: index
    })
  },
```



### checkbox用法

```vue
<checkbox-group @change="checkboxChange">
    <label v-for="(item,index) in order.coupon_list" :key="index">
        <view>
            <checkbox :value="String(index)" :checked="item.checked" />
            <text>{{item.name}}</text>
        </view>
    </label>
</checkbox-group>
```



### 修改上一页数据

```js
var pages = getCurrentPages();
var Page = pages[pages.length - 1];//当前页
var prevPage = pages[pages.length - 2];  //上一个页面
//小程序的data保存在prevPage.__data__里
var info = prevPage.data //取上页data里的数据也可以修改
prevPage.setData({键:值 })//设置数据
```



### 获取用户手机号

```html
<button class="login-btn" style="margin-top:40rpx;" open-type="getPhoneNumber" bindgetphonenumber="getPhone">获取手机号</button>
```

```js
getPhone: function (e) {
    console.log(e)
    const _this = this;
    if (e.detail.iv) {
      App._post_form('user/phone', {
        "iv": e.detail.iv,
        "encryptedData": e.detail.encryptedData,
        "uid": wx.getStorageSync('user_id')
      }, function (res) {
        wx.setStorageSync('mobile', res.data.phone)
        _this.navigateBack();
      });
    } else {
      return;
    }
  },
```



### 获取用户信息

```html
<button class="btn-normal" wx:if="{{!isLogin}}" bindtap="getUserProfile">授权登录</button>
```

```js
getUserProfile(){
    let _this = this
    wx.getUserProfile({
      desc:'获得你的公开信息',
      success:(e)=>{
        console.log(e,22)
        wx.showLoading({
          title: "正在登录",
          mask: true
        });
        // 执行微信登录
        wx.login({
          success(res) {
            // 发送用户信息
            App._post_form('?s=/api/user/login', {
              code: res.code,
              user_info: JSON.stringify(e.userInfo),
              referee_id: wx.getStorageSync('referee_id')
            }, result => {
              // 记录token user_id
              wx.setStorageSync('token', result.data.token);
              wx.setStorageSync('user_id', result.data.user_id);
              // 执行回调函数
              if(!result.data.user_info.mobile){
                _this.setData({
                  isLogin:true,
                  hasPhone:false
                })
              }else{
                wx.setStorageSync('userInfo', result.data.user_info)
                wx.setStorageSync('mobile', result.data.user_info.mobile)
                _this.onNavigateBack(1);
              }
            }, false, () => {
              wx.hideLoading();
            });
          }
        });
      },
      fail:(err)=>{
        console.log(err,232)
      }
    })
  },
```

### 保存图片

```js
//牛者，保存邀请函 这个方法没有判断用户授权
onSavePoster(e) {
    let _this = this;
    wx.showLoading({
      title: '加载中',
    });
    // 下载海报图片
    wx.downloadFile({
      url: _this.data.qrcode,
      success(res) {
        wx.hideLoading();
        // 图片保存到本地
        wx.saveImageToPhotosAlbum({
          filePath: res.tempFilePath,
          success(data) {
            wx.showToast({
              title: '保存成功',
              icon: 'success',
              duration: 2000
            });
            // 关闭商品海报
            _this.closePopup();
          },
          fail(err) {
            console.log(err.errMsg);
            if (err.errMsg === 'saveImageToPhotosAlbum:fail auth deny') {
              wx.showToast({
                title: "请允许访问相册后重试",
                icon: "none",
                duration: 1000
              });
              setTimeout(() => {
                wx.openSetting();
              }, 1000);
            }
          },
          complete(res) {
            console.log('complete');
            // wx.hideLoading();
          }
        })
      }
    })
  },
```

### wx.authorize授权

提前向用户发起授权请求。调用后会立刻弹窗询问用户是否同意授权小程序使用某项功能或获取用户的某些数据，但不会实际调用对应接口。如果用户之前已经同意授权，则不会出现弹窗，直接返回成功。

```js
// 可以通过 wx.getSetting 先查询一下用户是否授权了 "scope.record" 这个 scope
wx.getSetting({
  success(res) {
    if (!res.authSetting['scope.record']) {
      wx.authorize({
        scope: 'scope.record',
        success () {
          // 用户已经同意小程序使用录音功能，后续调用 wx.startRecord 接口不会弹窗询问
          wx.startRecord()
        }
      })
    }
  }
})
```

### authorize获得授权后保存图片

```js
Page({
  data: {	
  url:"https://wechat.weixinzjit.com/costa/public/uploads/images/20190109/67b16149693920598435315fd0d5ab3e.jpg"
  },
  // 长按保存图片
    saveImg(e){
    let url = e.currentTarget.dataset.url;
    //用户需要授权
    wx.getSetting({
      success: (res) => {
        if (!res.authSetting['scope.writePhotosAlbum']) {
          wx.authorize({
            scope: 'scope.writePhotosAlbum',
            success:()=> {
              // 同意授权
              this.saveImg1(url);
            },
            fail: (res) =>{
              console.log(res);
            }
          })
        }else{
          // 已经授权了
          this.saveImg1(url);//用户授权后，调用saveImg()方法，进行图片的保存
        }
      },
      fail: (res) =>{
        console.log(res);
      }
    })   
    },
    saveImg1(url){
    wx.getImageInfo({
      src: url,
      success:(res)=> {
        let path = res.path;
        wx.saveImageToPhotosAlbum({
          filePath:path,
          success:(res)=> { 
            console.log(res);
          },
          fail:(res)=>{
            console.log(res);
          }
        })
      },
      fail:(res)=> {
        console.log(res);
      }
    })
    },
})
```



### 自定义分享

监听用户点击页面内转发按钮（[button](https://links.jianshu.com/go?to=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fcomponent%2Fbutton.html) 组件 `open-type="share"`）或右上角菜单“转发”按钮的行为，并自定义转发内容。

```html
<!-- 自定义分享，在界面中只能通过按钮来触发 -->
  <view class="shareBox">
    <text>分享好友</text>
    <button type="primary" open-type="share">分享好友</button>
  </view>
```

```js
// 自定义分享
/**
1、分享页面的标题设置
2、分享的页面路径
3、分享的图片设置
*/
  onShareAppMessage() {
    return {
      title: this.data.info.fang_name,
      path: '/pages/fang/fang?id=' + this.data.info.id + '&openid=' + cache.get('openid'),
      imageUrl: this.data.info.pic
    }
  }
```

```js
//全局重写分享方法
overShare: function () {
    let _this = this;
    //监听路由切换，间接实现全局设置分享内容
    wx.onAppRoute(function (res) {
      //获取加载的页面
      let pages = getCurrentPages(),
        //获取当前页面的对象
        view = pages[pages.length - 1],
        data;
        console.log(view,'当前页面对象')
      if (view) {
        data = view.data;
          //是否需要重写开关: isOverShare, hasShare 都在data中预先定义
        console.log('是否重写分享方法', data.isOverShare); 
        if (!data.isOverShare) {
          data.isOverShare = true;
          if (data.hasShare){ 
            return
          }
          view.onShareAppMessage = function () {
            //你的分享配置
            return {
              title: 'J&M HEALTHY LIFE',
              //不直接去登录页， 去掉错误的分享图
              // path: '/pages/login/login',
              // imageUrl: _this.imageUrl + 'millShare.jpg'
            };
          }
        }
      }
    })
  },
```



### 支付流程

```js

 const pay = (result, self, success, fail) => {
	if (result.code === -10) {
		self.showError(result.msg);
		return false;
	}

	// 发起微信支付
	if (result.data.pay_type == 20) {
		//小程序支付
		// #ifdef  MP-WEIXIN	
		uni.requestPayment({
			provider: 'wxpay',
			timeStamp: result.data.payment.timeStamp,
			nonceStr: result.data.payment.nonceStr,
			package: 'prepay_id=' + result.data.payment.prepay_id,
			signType: 'MD5',
			paySign: result.data.payment.paySign,
			success: res => {
				paySuccess(result, self, success);
			},
			fail: res => {
				self.showError('订单未支付成功', () => {
					payError(result, fail);
				});
			},
		});
 //调用
 self._post('plus.package.package/buy', params, function(res) {
			pay(res, self, self.paySuccess, self.payError);
	});
```



### "backgroundTextStyle": "dark"

下拉加载动画图案颜色 默认是light(白色)



### 通过NPM安装三方库

打开终端

1.初始化npm init -y 快速初始化 生成package.json

2.npm install @vant/weapp

3.勾选本地设置-使用NPM模块

4.工具- 构建NPM模块-->生成miniprogram-npm (小程序使用的插件转化在这个文件内)



### 小程序数据共享第三方库

小程序没有类似vuex的数据共享方案，app->globalData内保存的数据是非响应式的

第三方库地址: github.com/coderwhy/hy-event-store

使用方式和vuex类似

安装: **npm install hy-event-store**



### 全局paddIng下，单独给某个组件设置宽度

当给page设置padding后，页面内所有子组件都有了padding

如何单独给横向滚动条去掉padding样式?

方案1：

1. wx.getSystemInfoSnyc() 获取屏幕宽度
2. 然后给该组件设置width: screenWidth

方案2(推荐)：

直接给组件设置样式width: 100vw   视口宽度



### 小程序去掉顶部样式(背景通铺)

页面.json文件配置： "navigationStyle": "custom"



### 自定义的组件的生命周期

```js
Component({
    lifetimes: {
        attached: function() {},//组件进入页面节点树时执行
        detached:  function() {},//组件被从页面节点树移除时执行
        created: function() {}, //组件实例刚被创建时执行
        ready: function() {}  // 组件在视图层布局完成后执行
    }
})
```



### 使用多个具名插槽需配置

```js
Component({
    options: {
       multipleSlots: true
    }
})
```

### globalData常用的地方

globalData不是响应式数据，可以用来保存不会经常变化的属性，比如屏幕宽高等

```js
App({
    onLaunch: function() {
        const info = wx.getSystemInfoSync()
        this.globalData.screenWidth = info.screenWidth
        this.globalData.screenHeight = info.screenHeight
        this.globalData.statusBarHeight = info.statusBarHeight // 手机最顶部状态栏高度
    }
    globalData: {
        screenWidth: 0,
        screenHeight: 0,
    	statusBarHeight: 0
    }
})
```

