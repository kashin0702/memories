### 一些重要概念

#### vue生命周期

**beforeCreate( 创建前 )**

在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods， data， computed等上的方法和数据。

**created ( 创建后 ）**

实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch/event事件回调，完成了data 数据的初始化，el没有。 然而，挂在阶段还没有开始, $el属性目前不可见，这是一个常用的生命周期，因为你可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也有一些童鞋喜欢在这里发ajax请求，**值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截**的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter中完成

**beforeMount**

挂载开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。

**mounted**

挂载完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。

**beforeUpdate**

在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程

**updated（更新后）**

在由于数据更改导致地虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用

**beforeDestroy（销毁前）**

在实例销毁之前调用，实例仍然完全可用，

1. 这一步还可以用this来获取实例，
2. 一般在这一步做一些重置的操作，比如**清除掉组件中的定时器  和 监听的dom事件**

**destroyed（销毁后）**

在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用

#### 运算符优先级

除了赋值符从右往左，其他运算符都遵循从左往右规则

混淆点:  

例1： a.xx && a.xx === 'abc'    .运算符优先级最高， 先判断a.xx 若false则直接短路，不会判断a.xx === 'abc'

若a.xx为真，再判断a.xx === 'abc' ，最后通过&& 返回结果 , 符合 === 优先级高于 && 规则

例2： var c = 4 || 3 && 8 - 1   返回4 ,   因为 ||左侧4为真，不会再执行||后面的运算

| 运算符                             | 描述                                         |
| ---------------------------------- | :------------------------------------------- |
| . [] ()                            | 字段访问、数组下标、函数调用以及表达式分组   |
| ++ -- - ~ ! delete new typeof void | 一元运算符、返回数据类型、对象创建、未定义值 |
| * / %                              | 乘法、除法、取模                             |
| + - +                              | 加法、减法、字符串连接                       |
| << >> >>>                          | 移位                                         |
| < <= > >= instanceof               | 小于、小于等于、大于、大于等于、instanceof   |
| == != === !==                      | 等于、不等于、严格相等、非严格相等           |
| &                                  | 按位与                                       |
| ^                                  | 按位异或                                     |
| \|                                 | 按位或                                       |
| &&                                 | 逻辑与                                       |
| \|\|                               | 逻辑或                                       |
| ?:                                 | 条件                                         |
| = oP=                              | 赋值、运算赋值                               |
| ,                                  | 多重求值                                     |





#### 基本类型和引用类型

基本类型：string number boolean undefined null

引用类型：function object array

1.基本类型按值访问，比较是值的比较，保存在**栈内存中**

2.基本类型赋值是创建一个新值，保存在不同的内存地址中

```js
var a = 10

var b = a 

a === b  //true  值的比较

a++  

console.log(a);  //11

console.log(b); //10
```

1.引用类型拥有属性和方法，引用类型的副本是指向保存在栈内存和堆内存中的一个指针

2.引用类型的比较是引用在**堆内存中地址的比较**

```js
var a = {};

var b = {};

a === b  //false  ab指向不同的内存地址，这两个都是指针

var a = {};

b = a;   

a === b //true  b和a都指向同一个内存地址，此时修改b的值也会影响到a
```



#### 包装类型

为了便于操作“基本类型值”，JS 提供了 三个 特殊的引用类型：**Boolean、Number、String**。这些类型和其他引用类型相似，但同时 也具备 与各自基本类型相应的特殊行为。 实际上：每当读取一个基本类型值的时候， “**后台就会创建**一个 对应的**基本包装类型的对象**”，从能能够调用一些方法来操作这些数据。 



#### 获取属性值[]和. 的区别

[] 可以使用字符串作为属性名，.不行

[]可以使用数字作为属性名，.不行

[]可以使用js关键字和保留字作为属性名， .不行

**个人理解：** 

相同：都可以用来给对象添加属性

不同： 获取属性

句点法获取属性时，指向确定的属性名, **如obj.name  这个name只能是obj中名为’name‘的key，不能是变量名**

[]通过传入(变量,字符串,数字)，**变量需要对应对象的key名**，否则是undefined 

```js
let obj = {
    key1: 'xxx',
    key2: 'zzz',
    key3: 'ccc'
}
for(let i=1;i<4;i++){
    let key = 'key' + i
    console.log(obj[key])// 正常输出属性值
    //句点法获取的是obj对象的key,obj对象内并没有'key'这个键名
    console.log(obj.key) // undefined
}

let obj2 = {
    water: 'woo',
    2: 'ww',
    3: 'zzz'
}
let ss = 'water'
console.log(obj2[ss]) // woo 通过变量ss获取到key
console.log(obj2.ss) // undefined 跟上面一样，obj2内并没有ss这个key
```



#### typeof 

typeof是检测string , number, boolean,undefined这些**基本类型**的最佳工具，但检测null的话返回的是object，对function的检测不准确（有可能是正则表达式）。

typeof返回值:

   \1. 'undefined'       --未定义的变量或值

​    \2. 'boolean'         --布尔类型的变量或值

​    \3. 'string'           --字符串类型的变量或值

​    \4. 'number'         --数字类型的变量或值

​	 \5. 'object'          --对象类型的变量或值，或者null(这个是js历史遗留问题，将null作为object类型处理)

​    \6. 'function'         --函数类型的变量或值

**typeof运算符用于判断对象的类型，但是对于一些创建的对象，它们都会返回'object'，有时我们需要判断该实例是否为某个对象的实例，那么这个时候需要用到instanceof运算符**



#### instanceof

语法：object instanceof constructor

`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

````js
// 定义构造函数
function C(){}
function D(){}

var o = new C();

o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototype

o instanceof D; // false，因为 D.prototype 不在 o 的原型链上

o instanceof Object; // true，因为 Object.prototype.isPrototypeOf(o) 返回 true
C.prototype instanceof Object // true，同上

C.prototype = {};
var o2 = new C();

o2 instanceof C; // true

o instanceof C; // false，C.prototype 指向了一个空对象,这个空对象不在 o 的原型链上.

D.prototype = new C(); // 继承
var o3 = new D();
o3 instanceof D; // true
o3 instanceof C; // true 因为 C.prototype 现在在 o3 的原型链上

````



```js
//手写instanceof 方法
function myInstanceof (left, right) {
    // 基本数据类型直接返回false
    if (typeof left !== 'object' || left === null) return false
    // getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象
    let proto = Object.getPrototypeOf(left)
    while (true) {
        // 查找到尽头，还没找到
        if (proto == null) return false
        // 找到相同的原型对象
        if (proto == right.prototype) return true
        proto = Object.getPrototypeOf(proto) //递归 继续判断该对象中是否有原型对象
    }
}
//测试
console.log(myInstanceof("111", String)); //false
console.log(myInstanceof(new String("111"), String));//true
```



#### 判断是否是数组的6种方法

```js
// 1. instanceof
let arr = [];
console.log(arr instanceof Array); // true

//2. 利用构造函数的constructor属性判断
let arr = [];
console.log(arr.constructor === Array); // true

//3. Array 原型链上的 isPrototypeOf
//isPrototypeOf() 用于测试一个对象是否存在于另一个对象的原型链上。
let arr = [];
console.log(Array.prototype.isPrototypeOf(arr)); // true

//4. Object.getPrototypeOf() 方法返回指定对象的原型
let arr = [];
console.log(Object.getPrototypeOf(arr) === Array.prototype); // true

//5. Object.prototype.toString.call(arr) === '[object Array]'
//虽然Array也继承自Object，但js在Array.prototype上重写了toString，而我们通过toString.call(arr)实际上是通过原型链调用了。
let arr = [];
console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true

//6. Array.isArray(arr) es5新增
let arr = [];
console.log(Array.isArray(arr)); // true
```



#### 数组去重的几种方法

```js
let arr = [1,2,2,3,4,4,4,5,6,7]
// 方法1 filter
let newArr = arr.filter((item, index) => {
    //indexOf只会返回匹配到的第一个数组下标， 之后重复的都不会匹配到
    return arr.indexOf(item) === index   
})
// 方法2 普通遍历
let newArr = []
for (let item of arr) {
    if (newArr.indexOf(item) === -1) newArr.push(item)
}
// 方法3 reduce
let newArr = arr.reduce((prev,cur) => {
    if (prev.indexOf(cur) === -1) prev.push(cur)
	return prev
}, [])
// 方法4 双循环去重
for (let i=0; i<arr.length; i++) {
    for (let j=0; j<arr.length; j++) {
        // 当内循环j和外循环i相等，且索引不相等表示是重复项，剔除索引=j的项
        if (arr[i] === arr[j] && i !== j) arr.splice(j, 1)
    }
}
```



#### 连续赋值

解答思路：

1、优先级.的优先级高于=，所以先执行a.x，堆内存中的{n: 1}就会变成{n: 1, x: undefined}，改变之后相应的b.x也变化了，因为指向的是同一个对象。
2、赋值操作是从右到左，所以先执行a = {n: 2}，a的引用就被改变了，然后这个返回值又赋值给了a.x，需要注意的是这时候a.x是第一步中的{n: 1, x: undefined}那个对象，其实就是b.x，相当于b.x = {n: 2}

```js
var a = {n: 1}; 
var b = a;
a.x = a = {n: 2};  //关键点a.x优先声明
console.log(a.x)  //undefined
console.log(b.x) //{n: 2}

/*
给a添加属性x，此时a,b都是 { n:1,x:undefined },a.x 运算后的结果即为这个object（可以说也就是b）的x属性值。
把{n:2}赋值给a，此时a是 {n:2},是一个新的对象。 b是{ n:1,x:undefined }。
由于（ .  运算符最先计算）一开始js已经先计算了a.x，便已经解析了这个a.x是对象A的x，所以在同一条公式的情况下再回来给a.x赋值，也不会说重新解析这个a.x为对象B的x。
所以 a.x=a 应理解为对象A的属性x指向了对象B:
（这个时候a.x 已经运算完了，不会再与a产生任何关系，a.x依旧代表那个n为1对象的x属性值，和a已经没关系了。）
把{n:2}赋值给a.x 也就是 { n:1,x:undefined }这个对象的x属性，这个时候b依旧指向这个object，因此此时，a是{n:2}，b是{n:1,x:{n:2}}
*/
```



```js
var box ='Mr.Xiao';     //字面量创建方式 
alert(box.substring(2)); //box 是基本类型，但是也是特殊的引用类型，在后台会创建一个基本包装类型的对象，所以可以调用 系统内置的函数
```

#### substring()/substr()区别

```js
// substring 返回下标n到m之间的字符串，包括n,不包括m
// substr 返回下标n开始的m个字符串
let str = 'hello david'
str.substring(2,5) // 'llo'
str.substr(2,5)    // 'llo d'

```

#### Object.defineProperty

`Object.defineProperty()`的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性

1. obj 需要定义属性的当前对象

2. prop 当前需要定义的属性名

3. desc 属性描述符

   属性描述符有2种：数据描述符、存取描述符

```js
//Object.defineProperty(obj, prop, desc)
// 数据描述符 特有的两个属性(value,writable)
let Person = {}
Object.defineProperty(Person, 'name', {
    value: 'jack',
    writable: false,  // 默认值true 属性值是否可改变 
    enumerable: true, // 默认值true 属性是否可遍历
    configurable: true  // 默认false 能否通过delete删除属性从而重新定义属性
})
Person.name = 'david' // 不会报错，但还是'jack'

// 存取描述符 由一对 getter、setter 函数功能来描述的属性
// get: 一个给属性提供getter的方法，如果没有getter则为undefined。该方法返回值被用作属性值。默认为undefined
// set: 一个给属性提供setter的方法，如果没有setter则为undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认值为undefined
let temp = null
Object.defineProperty(Person, 'name', {
    get: function(){
        return temp
    },
    set: function(newValue){  //set会传入一个newValue
        temp = newValue
    }
})
Person.name = 'david'
console.log(Person.name) //'david'
```



#### Object.getPrototypeOf

`Object.getPrototype(obj)`是ES5中用来获取obj对象的原型对象的标准方法。

`obj.__proto__`是获取obj对象的原型对象的非标准方法。

User.prototype`用于建立由 `new User() 创建的对象的原型。

```js
//创建一个User构造函数
function User(name, passwordHash) {
  this.name = name;
  this.passwordHash = passwordHash;
}

User.prototype.toString = function() {
  return '[User ' + this.name + ']';
}

User.prototype.checkPassword = function(password) {
  return hash(password) === this.passwordHash;
}
//创建u实例
var u = new User('Lix', '123456');
//输出都一样
console.log(Object.getPrototypeOf(u)); // User { toString: [Function], checkPassword: [Function] }

console.log(u.__proto__); // User { toString: [Function], checkPassword: [Function] }

console.log(User.prototype); // User { toString: [Function], checkPassword: [Function] }
```

#### if( xx in obj)  判断xx属性是否属于obj对象

判断一个属性是否属于一个对象。有返回true,没有返回false

```js
let names = ['Lily', 'Barry', 'Dendi', 'Boogie', 'Lily'];

    let nameNum = names.reduce((pre, cur) => {
        if (cur in pre) { //pre 中是否有 cur 属性
            pre[cur]++;
        } else {
            pre[cur] = 1; //为 pre 这个对象添加 cur 属性，并且赋值为 1
        }
        return pre;
    }, {})  //关键：这里设置初始值是一个空对象

    console.log(nameNum); //{Barry: 1,Boogie: 1,Dendi: 1,Lily: 2 }

```



#### if if  和 if else if 区别

```c
if (条件1)
{
    //语句1
}

if (条件2)
{
    //语句2
}
```



这种格式中，程序会依次判断条件1和条件2是否成立并根据结果决定是否执行语句1和语句2，也就是说，第一个 if 块和第二个 if 块没有影响（除非在执行第一个 if 块的时候就凶残地 return 了）

```c
if (条件1) 
{
    //语句1
}
else if (条件2)
{
    //语句2
}
```

if 块和 else if 块本质上是互斥的！也就是说，一旦语句1得到了执行，程序会跳过 else if 块，else if 块中的判断语句以及语句2一定会被跳过；同时语句2的执行也暗含了条件1判断失败和语句1没有执行；当然还有第3个情况，就是条件1和条件2都判断失败，语句1和语句2都没有得到执行。





#### for/in for/of区别

for in 遍历数组时是索引值index，遍历对象时是key  

for of 遍历数组的value，**不能遍历对象**   for of适合遍历数组



#### for循环中++i和i++的区别

for(语句1；语句2；语句3){ 被执行的代码块 }

语句1：在循环开始前执行

语句2：定义循环的条件

语句3：在循环已被执行后执行(这就是i++和++i结果一样的原因)

for循环的语法定义 ++i 和 i++的结果是一样的，**都要等代码块执行完毕才能执行语句3**，但是性能是不同的。在大量数据的时候++i的性能要比i++的性能好原因：

i++由于是在使用当前值之后再+1，所以需要一个临时的变量来转存。

而++i则是在直接+1，省去了对内存的操作的环节，相对而言能够提高性能

#### for循环的本质

对于一个for循环，设置循环变量的地方是一个父作用域，而循环体代码在一个子作用域内；别忘了for循环还有条件判断，与循环变量的自增

for循序的执行顺序是这样的：**设置循环变量(var i = 0) ==》循环判断(i<3) ==》满足执行循环体 ==》循环变量自增(i++)**



#### 闭包

**作用：**闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」。

1.可以访问其他函数内变量的函数，叫做闭包。
2.闭包可以用来保存一个需要持久保存的变量，可以模拟命名空间。

```js
function fn(){
    var num1 = 5;
    return function(){ //return出去，让外部调用，同时形成了闭包
        var num2 = 0;
        console.log(++num1)
        console.log(++num2)
    }
}
var fn1 = fn()  //此时fn1 = function(){var num2 = 0 ...}
fn1() //6 1  fn1引用了fn内的num1 所以num1不会销毁 产生了闭包
fn1() //7 1   


for(var i = 0;i<5;i++){
    setTimeout(() => {
        console.log(i)  //输出5个5，js是单线程所以当定时器执行时i已经等于5
    })
}

//通过闭包实现依次输出 其实也是立即执行函数
//这里for循环和立即执行函数同步执行，循环5次产生了5个函数作用域，i也依次保存下来
for(var i=0;i<5;i++){
    (function(i){ 
        setTimeout(() => {
            console.log(i) //i引用了外部函数的i
        },0)
    })(i)  
}

// 使用let建立独立作用域
for(let i=0;i<5;i++){
    setTimeout(function(){
        console.log(i)
    },0)
}
```

好处

1. 保护函数内的变量安全 ，实现封装，防止变量流入其他环境发生命名冲突

2. 在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）

3. 匿名自执行函数可以减少内存消耗

坏处

1. 被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用完变量后手动为它赋值为null；
2. 其次由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响



#### scrollTop、offsetTop 区别

网页可见区域高：document.body.clientHeight
网页可见区域高（包括边线的高）：document.body.offsetHeight
网页被卷去的高：document.body.scrollTop

网页正文全文高：document.body.scrollHeight

屏幕分辨率高：window.screen.height

offsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素

![img](D:\typora-img\20210414142501307.png)

![img](D:\typora-img\20210414142441565.png)



#### && || 参与计算

关键在于条件执行到哪里返回

```js
var result = a && b //a真，此时判断b 不论b真假都返回b
var result = a || b //a真，此时不判断b，直接返回a
var result2 = c && d //c假，此时不判断d 直接返回c
var result2 = c || d //c假,此时判断d,并直接返回d
```

#### 高阶函数( filter方法为例 )

```js
//数组的filter方法源码
Array.prototype.myFilter = function(fn){
  let newArr = [];
  for(let i =0, len = this.length; i < len; i++){
    fn(this[i]) && newArr.push(this[i])  //等价于if(fn(this[i])){ newArr.push(this[i]) }
  }
  return newArr; //返回新数组
}

//调用myFilter方法，以函数为参数的高阶函数
var arr = [2,3,5,23,57]
arr.myFilter(function(item){
  return item > 3; //此处return值为true,加入了新数组，然后新数组返回
})
```



#### 递归函数

递归函数会先执行递归内的函数，**跟嵌套循环一样，先执行内部再执行外部**

```js
getLeafKeys(node,arr){
    //1.如果当前node节点不包含children属性，则是3级节点，把node的id保存到数组arr中
    if(!node.children){
        return arr.push(node.id)
    }
    //2.不是3级节点，循环children属性，拿到字节点item，对item再次调用函数进行递归
    node.children.forEach(item => {
        this.getLeafKeys(item,arr)
    })
}

//手写instanceof 方法
function myInstanceof (left, right) {
    // 基本数据类型直接返回false
    if (typeof left !== 'object' || left === null) return false
    // getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象
    let proto = Object.getPrototypeOf(left)
    while (true) {
        // 查找到尽头，还没找到
        if (proto == null) return false
        // 找到相同的原型对象
        if (proto == right.prototype) return true
        proto = Object.getPrototypeOf(proto) //递归循环
    }
}
```

#### 递归（高级用法）

```js
// 扁平化处理数组 把N层结构的数组处理成自己想要的层数
recursionOffer (mainOfferNodes, level) {
  let list = []
  console.log(mainOfferNodes)
  for (let item of mainOfferNodes) {
    let node = {
      catalogId: item.catalogId,
      catalogLevel: item.catalogLevel,
      catalogName: item.catalogName,
      leafNode: item.leafNode
    }
    if (!isEmpty(item.subNodes) && Object.prototype.toString.call(item.subNodes) === '[object Array]' && item.subNodes.length > 0) {
       // 关键句：获取返回的subNodes数组
       // 递归调用会从最内层，层层往外返回结果
      let subNodes = this.recursionOffer(item.subNodes, item.catalogLevel)
      // 根据当前层数对返回的数组处理
      if (item.catalogLevel >= 4) {
        list = list.concat(subNodes) // >=4层时 concat拼接返回的数组进行扁平化
      } else {
        node.subNodes = subNodes // 小于4时默认处理
      }
    }
    list.push(node)
  }
  return list
```



#### Promise函数

resolve和reject是promise对象的两种状态，分别代表请求成功或失败时的回调

promise的优势在于可以进行链式回调，使代码可读性更高，不用像普通回调一样嵌套

```js
new Promise((resolve,reject) => {
    setTimeout(() => { //模拟异步请求
        if(xxx){
            resolve('成功的数据')
        }else{
            reject('失败时的数据')
        }        
    })
}).then(res => {
    console.log(res)  //此处是resolve返回的数据
}).catch(err => {
    console.log(err)  //此处是reject返回的数据
})

//链式回调
new Promise(resolve => {
    //xxxxx
}).then(res => {
    return res + 'xxx'
}).then(res => {  //链式调用
    //xxx
})
```



#### Promise.then

**只有当resolve()执行后，才会调用then(fn1,fn2)中的fn1回调函数**

**只有当reject()执行后，才会调用then(fn1,fn2)中的fn2回调函数**

```js
// then的2个回调函数
promise.then(resolvedCallback, rejectedCallback);

promise.then(function(value) {
  // 把这个函数作为promise对象状态变为成功后调用的回调函数
  // 成功时的逻辑
}, function(error) {
  // 把这个函数作为promise对象状态变为失败后调用的回调函数
  // 失败时的逻辑
});
```



Promise实例生成以后，可以用then方法指定两个回调函数。
then方法中的第一个参数，是promise对象的状态由pending变为resolved后会调用的回调函数；then方法中的第二个参数，是promise对象的状态由pending变为rejected后调用的回调函数；
这两个回调函数中，rejectedCallback可选的，不一定要提供。
例一中，如果异步操作成功，就会调用resolve(value)，调用resolve(value)，**当前promise的状态由进行中变为成功，随即调用then方法中的第一个回调函数参数**。
我们在例一中调用resolve(value)的时候其实就可以看作是在调用then方法里传的第一个回调函数。
then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行( 也就是说resolve()后面如果还有其他同步语句(如上面例子中的console.log(1) )，会先执行完这些同步语句， 然后在执行then方法中的回调函数)。（其实这里涉及到的是事件循环的概念，不清楚的可以去了解）

then方法会返回一个**新的**Promise实例。因此可以采用链式写法，即then方法后面再调用另一个then方法。采用链式的then，可以指定一组按照次序调用的回调函数。

**成功时的回调 和 失败时的回调函数 中的return返回值**
第一个回调函数完成以后，会将返回结果作为参数，传入下一级的回调函数。返回结果可能是一个参数或者一个新的promise实例（即有异步操作），这时候一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。
如果then方法中的回调函数(不管是成功的回调还是失败的回调)返回了一个参数(return xxx)，那么这个then方法返回的新的promise的状态会变成fulfilled(同时成功的回调函数也会被调用)。

#### Promise.all

Promise.all可以将**多个Promise实例**包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。

```js
let wake = (time) => {
  // 通过return new Promise包装实例
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(`${time / 1000}秒后醒来`)
    }, time)
  })
}

let p1 = wake(3000)
let p2 = wake(2000)

Promise.all([p1, p2]).then((result) => {
  console.log(result)       // [ '3秒后醒来', '2秒后醒来' ]
}).catch((error) => {
  console.log(error)
})
```



#### call()  apply()  

call()  apply()两个方法的核心就是改变函数的作用域，都是用来代替另一个对象调用一个方法

区别是传参形式不同

bind()方法返回一个函数

```js
func1.apply(this[,arguments]) //this表示当前作用对象，第二个参数必须是数组
func1.call(this,args1,args2) //可以传N个参数，但必须一个个写入
```

```js
let age = 18;
let obj = {
    name: 'david',
    age: this.age,
    myFn: function(){
        console.log('name is' + this.name + ', age is' + this.age)
    }
}
obj.myFn() //name is david, age is undefined ,this指向obj的获取不到
let obj2 = {
    age: 22
}
obj.myFn.call(obj2) //name is undefined age is 22
```

#### bind()

**bind 的第一个参数会作为原函数运行时的 this 指向**；而第二个开始的参数是可选的，当绑定函数被调用时，这些参数加上绑定函数本身的参数会按照顺序作为原函数运行时的参数。怎么理解？

```js
function fn(a, b, c) {
  return a + b + c;
}

var _fn = fn.bind(null, 10);
var ans = _fn(20, 30); // 60
```

fn 函数需要三个参数，_fn 函数将 10 作为默认的第一个参数，所以只需要传入两个参数即可，如果你不小心传入了三个参数，放心，也只会取前两个。

```js
function fn(a, b, c) {
  return a + b + c;
}

var _fn = fn.bind(null, 10);
var ans = _fn(20, 30, 40); // 60
```

这有啥用呢？如果某些函数，前几个参数已经 “内定” 了，我们便可以用 bind 返回一个新的函数。也就是说，**bind() 能使一个函数拥有预设的初始参数**。这些参数（如果有的话）作为 bind() 的第二个参数跟在 this 后面，之后它们会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们的后面。

```js
function list() {
  return Array.prototype.slice.call(arguments);
}

var list1 = list(1, 2, 3); // [1, 2, 3]

// 绑定一个预设参数37
var leadingThirtysevenList = list.bind(undefined, 37);

var list2 = leadingThirtysevenList(); // [37]
var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]
```

bind会返回一个函数

```js
//this被改变的情况
var a = {
	b : function(){
		var func = function(){
			console.log(this.c);
		}
		func(); //函数直接调用就是默认绑定，this指向了window,报undefined
	},
	c : 'Hello!'
}
a.b();  //undefined


//解决方法1：保存this指向的对象
var a = {
	b : function(){
		var that = this; //这里保存了this指向的对象,当调用a.b()时，this指向了a
		var func = function(){
			console.log(that.c); //that == 对象a
		}
		func();
	},
	c : 'Hello!'
}
a.b(); //Hello!

//解决方法2：使用bind绑定作用域
var a = {
	b : function(){
		var func = function(){
			console.log(this.c);
		}.bind(this);
		func();
	},
	c : 'Hello!'
}
a.b(); //Hello!

 
var a = {
	b : function(){
		var func = function(){
			console.log(this.c);
		}
		func.bind(this)();
	},
	c : 'Hello!'
}
a.b(); //Hello!

```



#### [object Object] 

我们的代码中有`+`（加号）运算符，它在这种情况下（字符串 + 其它什么东西），会调用`toString()`方法，将其它类型的东西转化为字符串，再和原始字符串拼接成一个字符串；

- 默认情况下，`toString()`方法被每个`Object`对象继承。如果此方法在自定义对象中未被覆盖，`toString()`返回 "`[object type]`"，其中`type`是对象的类型。

```js
// 对象转字符串 调用了Object的toString()方法 会返回[object Object]
console.log('res:' + res); //res:[object Object]
Object.prototype.toString.call([1,2,3]) // [object Array]
```



#### String match()方法 

参数为普通字符串的使用方式，此时match方法的返回值是存放首次匹配内容的数组。如果没有找到匹配结果，返回null。语法结构：

1 str.match(searchvalue)
参数解析：
（1）.searchvalue：必需，规定方法要检索的字符串。
代码实例：

```js
let str="antzone"; 
console.log(str.match("n"));
//代码运行效果：
**["n", index: 1, input: "antzone", groups: undefined]**
```

（1）.match方法在有匹配结果的时候返回值是一个数组。
（2）.数组第一个元素是match方法首次匹配到的子字符串，"antzone"虽然有多个"n"，但是返回的数组只存储首次匹配到的"n"，如果match方法的参数是全局匹配的正则，将会存储所有的匹配到的子字符串。
（3）.index属性值返回首次匹配到子字符串的位置。
（4）.input属性值是原字符串"antzone"。
（5）.groups属性当前并不被支持，暂时不做介绍。



#### this指向问题

- 在方法中，this 表示该方法所属的对象。
- 如果单独使用，this 表示全局对象。
- 在函数中，this 表示全局对象。
- **在函数中，在严格模式下，this 是未定义的(undefined)**。
- 在事件中，this 表示接收事件的元素。
- 类似 call() 和 apply() 方法可以将 this 引用到任何对象。



coderwhy关于this解释：

- 1.函数在调用时，JavaScript会默认给this绑定一个值；
- 2.this的绑定和定义的位置（编写的位置）没有关系；
- 3.this的绑定和调用方式以及调用的位置有关系；
- 4.**普通函数this是在运行时被绑定的；**
- 5.**箭头函数this只看定义时的上层作用域**

```html
<!--在 HTML 事件句柄中, this指向了接收事件的 HTML 元素-->
<button onclick="this.style.display='none'">点我后我就消失了</button>
```

```js
function foo(){
    console.log(this)
}
//1.对于new 方式，this永远被绑定在c上
const c = new foo()
//2.对于直接调用的函数，this永远指向window
foo()



// 函数作为参数传入
function foo(func) {
  func() 
}

var obj = {
  name: "why",
  bar: function() {
    console.log(this); // window
  }
}
//在真正函数调用的位置，并没有进行任何的对象绑定，只是一个独立函数的调用 所以指向window
foo(obj.bar);
```

```js
//3. this的指向在方法创建时是无法决定的，this仅指向调用它的上一级对象
var obj = {
    a: 'haha',
    fn: function(){
		console.log(this.a)  
    }
}
obj.fn()   //'haha'  this指向对象obj 因为调用fn()是通过obj.fn()执行的

var obj2 = {
    a: 'keke',
    b: {
        a: 'heyhey',
        fn: function(){
    		console.log(this.a)  //heyhey
		}
    }
}
obj2.b.fn()  //heyhey,由obj2发起调用，但没有指向obj2的a 而指向了b的a 所以仅指向上一级对象

var obj3 = {
    a: 'david',
    b: {
        fn: function(){
            console.log(this.a)  //undefined
        }
    }
}
obj3.b.fn() //undefined,虽然是obj3发起调用，但b内没有a属性，所以调用fn()时提示undefined

//方法赋值给别的对象
var obj4 = {
    a: 'david',
    b: {
        a: 'kashin',
        fn: function(){
            console.log(this.a)
        }
    }
}
var obj5 = obj4.b.fn 
obj5()  //undefined  obj5相当于只是获得了fn这个方法,直接执行fn() 自然就指向了window
```



#### 箭头函数=>

- 箭头函数的 this和**调用时上下文无关**，它不绑定this, 它会捕获其**所在上层作用域**（即定义的位置）的this值，一旦确定，任何方法都改变不了其指向，如 call() ,  bind() ,  apply() 

```js
var obj = {
  a: 10,
  b: () => {//箭头函数和b平级，以key:value形式存在，箭头函数所处对象是obj,而obj的父执行上下文就是window
    console.log(this.a); // undefined
    console.log(this); // Window 
  },
  c: function() {
    console.log(this.a); // 10
    console.log(this); // {a: 10, b: ƒ, c: ƒ}
  }
}
obj.b(); 
obj.c();

var obj = {
    data: [],
    // 模拟网络请求后把数据放到data中
    getData: function(){
        // 箭头函数不绑定this,所处位置在getData内，所以this指向了getData的上层作用域即obj
        setTimeout(() => {
            var res = [1,2,3]
            this.data.push(...res)
        }, 1000)
    }
}
obj.getData()
```

```js
function make () {
  return ()=>{ // 定义时this并没有确定
    console.log(this);
  }
}
const testFunc = make.call({ name:'foo' }); // 给make绑定了作用域，所以内部箭头也确定了作用域
testFunc(); //=> { name:'foo' }
testFunc.call({ name:'bar' }); //=> { name:'foo' } 给箭头函数绑定this无效
```




  ```js
//箭头函数在不写{} 的情况下，可以省略return关键字，而默认return接下来的东西
() => () => ...
//等价于：
() => {return () => {return ...}}
//等价于
function () {
    retunrn function() {
        return ...
    }
}
  ```



#### try/catch错误处理

目前我们可能得到的系统异常主要包含以下6种:

- **EvalError**: raised when an error occurs executing code in eval() 
- **RangeError**: raised when a numeric variable or parameter is outside of its valid range 
- **ReferenceError**: raised when de-referencing an invalid reference 
- **SyntaxError**: raised when a syntax error occurs while parsing code in eval() 
- **TypeError**: raised when a variable or parameter is not a valid type 
- **URIError**: raised when encodeURI() or decodeURI() are passed invalid parameters 

上面的六种异常对象都继承自Error对象。他们都支持以下两种构造方法:

```javascript
new Error();
new Error("异常信息");
```

手工抛出异常的方法如下：

```javascript
try {
 throw new Error("Whoops!");
} catch (e) {
 alert(e.name + ": " + e.message);
}
```

Error具有下面一些主要属性：

- description: 错误描述 (仅IE可用). 
- fileName: 出错的文件名 (仅Mozilla可用). 
- lineNumber: 出错的行数 (仅Mozilla可用). 
- message: 错误信息 (在IE下同description) 
- name: 错误类型. 
- number: 错误代码 (仅IE可用). 
- stack: 像Java中的Stack Trace一样的错误堆栈信息 (仅Mozilla可用). 

如要判断异常信息的类型，可在catch中进行判断：

```javascript
try {
 foo.bar();
} catch (e) {
 if (e instanceof EvalError) {
     alert(e.name + ":" + e.message);
 } 
 else if (e instanceof RangeError) {
     alert(e.name + ": " + e.message);
 } 
 // etc 
}
```

JavaScript中的throw命令事实上可以抛出任何对象，并且我们可以在catch接受到此对象。例如：

```js
try {
 throw new Date(); // 抛出当前时间对象 
} catch (e) {
 alert(e.toLocaleString()); // 使用本地格式显示当前时间 
}
```

菜鸟教程try/catch应用

```js
function myFunction() {
    var message, x;
    message = document.getElementById("message");
    message.innerHTML = "";
    x = document.getElementById("demo").value;
    try { 
        if(x == "")  throw "为空";
        if(isNaN(x)) throw "不是一个数字";
        if(x > 10)   throw "太大了";
        if(x < 5)    throw "太小了";
    }
    catch(err) {
        message.innerHTML = "输入的值 " + err;
    }
}
```

#### axios返回的error对象获取信息

#### error.response

要用**error.response**才能拿到错误信息

#### 防抖和节流函数

防抖函数 (规定时间内不触发事件才执行1次，触发就会重新计时)

```js
function debounce(fn,delay){
    let timer = null;
    return function(){
        let context = this;
        let args = arguments;
        if(timer) clearTimeout(timer);
        timer = setTimeout(function(){
            fn.apply(context,args) //apply绑定原作用域
        },delay)
    }
}
function loadSize(){
    console.log('屏幕在动')
}
window.addEventListner('resize',debounce(loadSize,1000))


// 完整版防抖函数
function debounce (fn, interval, immediate = false, callback) {
    let timer = null
    let isInvoke = false
    const _debounce = function (...args) {
        return new Promise(resolve => {
            if (timer) clearTimeout(timer)
            if (immediate && !isInvoke) { // 第一次是否直接触发，且还没有触发过
                const res = fn.apply(this, args)
                resolve(res)
                callback && callback(res)
                isInvoke = true // 设置为true,定时器生效期间就不会调用了
            } else {
                timer = setTimeout(() => {
                    const res = fn.apply(this, args)
                    resolve(res)
                    callback && callback(res)
                    timer = null
                    isInvoke = false // 定时器执行完后再设置为false, 下次调用就会调上面的
                }, interval)
            }
        })
    }
    _debounce.cancel = function () {
        if (timer) {
            clearTimeout(timer)
            timer = null
            isInvoke = false
        }
    }
    return _debounce
}

```

节流函数 (规定时间内仅执行一次，稀释函数执行频率)

```js
function throttle(fn,delay){
    let timer = null;
    return function(){
        let context = this;
        if(!timer){  //如果没有定时器，就设置一个定时器，执行相关操作
            timer = setTimeout(function(){
            /** 关键语句：
            	必须设置为null,不能用clearTimeout(timer)
            	因为定时器默认会返回一个timerId，clearTimeout只是清除了定时行为，并不会清除timerId
            */
                timer = null; 
                fn.apply(context) //apply绑定作用域
            },delay)
        }
    }
}

// 完整版节流函数(时间戳+定时器) options:节流配置参数
function throttle (fn, interval, options = {leading: true, trailing: false}) {
    const {leading, trailing, callback} = options
    let timer = null
    let lastTime = 0
    const _throttle = function (...args) {
        return new Promise(resolve => {
            const nowTime = new Date().getTime()
            if (!leading && !lastTime) lastTime = nowTime
            const remainTime = interval - (nowTime - lastTime)
            if (remainTime <= 0) {
                if (timer) {
                    timer = null
                    clearTimeout(timer)
                }
                let res = fn.apply(this, args)
                resolve(res)
                callback && callback(res)
                lastTime = nowTime
                return
            }
            if (!timer && trailing) {
                timer = setTimeout(() => {
                    lastTime = leading ? new Date().getTime() : 0
                    let res = fn.apply(this, args)
                	resolve(res)
                	callback && callback(res)
                    timer = null
                }, remainTime)
            }
        })
    }
    _throttle.cancel = function () {
        if (timer) {
            clearTimeout(timer)
            timer = null
            lastTime = 0
        }
    }
    return _throttle
}
```



#### localStorage sessionStorage

localstorage以键值对的形式储存在本地中，可以在浏览器application-Local Storage中查看

```js
var local = document.getElementById('username').value
button.onclick = function(){
    localStorage.setItem('username',local)
}
```





#### css定义变量和使用变量

``` css
page {
    /*定义全局颜色*/
    --themeColor: #fff;
}

/*使用变量*/
view {
    color: var(--themeColor);
}
```



#### :nth-child 和 :nth-of-type区别

:nth-child(n)  不带标签则匹配任意元素的父元素中第n个子元素

p:nth-child(n)   **每个P元素匹配的父元素中第n个子元素** ，前面的同级元素有效，**若第n个不是p则未匹配到**

p:nth-of-type(n)   **每个P元素匹配的父元素中第n个p类型子元素**，前面的其他元素无效 ，只看同类型p

```html
<html>
<head>
    <style>
    	:nth-child(2) {color: red}
        div:nth-child(2) {color: blue}
        div:nth-of-type(2) {color: yellow}
	</style>
</head>
<body>
    <div>
        <p>p1111111111111111</p>
        <!--被匹配，父元素div的第2个子元素-->
    	<p>p2222222222222222</p>
    	<p>22hahahaha</p>
    	<p>没class的PPPPPPPP</p>
    	<p>333hahahaha</p>
    	<p class="item">444hahahaha</p>
    	<p class="item">555hahahaha</p>
    </div>
    <!--被匹配,父元素body的第2个子元素,前面的同级元素div也计算在内-->
    <button>第一个button</button>
    
    <!--div:nth-child(2)匹配不到这个元素，因为是body的第3个child-->
    <!--div:nth-of-type(2)能匹配，因为是body的第2个div-->
    <div>第2个div</div>
    <button></button>
    <button></button>
</body>
</html>
```



当用类名时：

.item:nth-of-type(n)  先看标签名再看类名，选择第n个含class类的子元素，前面没有类名的同类元素也被计算在序列内

``` html
<style>
    .item:nth-of-type(5){
        color:  red;
    }
</style>
<div>
    <p class="item">11hahahaha</p>
    <p>没class的ppppPppp</p>
    <p class="item">22hahahaha</p>
    <p>没class的PPPPPPPP</p>
    <!--该行会被匹配，因为是第5个p，前面没有item的p也计算在序列内-->
    <p class="item">333hahahaha</p>
    <p class="item">444hahahaha</p>
    <p class="item">555hahahaha</p>
  </div>
```





#### :nth-child(an+b) n取值范围

an+b中  n>=0   an+b>=1

nth-child(n) nth-child(n+1)   表达式范围都是>=1 选择所有元素

nth-child(n-x)  因为n-x >=-x &an+b>=1 所以 n-x>=1 表示选择所有元素

nth-child(n+2) 表达式范围>=2 选择第二个以及后面所有元素

nth-chidl(-n+2) 表达式范围<=2 结合>=1 所以选择[1,2]  也就是第一，第二个元素



last-of-child(n)   表达式范围>=1 选择所有元素

last-of-child(n+2) 表达式范围>=2 选择倒数第二个以及前面所有元素

last-of-child(-n+2) 表达式范围[1,2]  选择倒数第一个和倒数第二个元素



#### :last-of-type 和 :last-child区别

p:last-of-type   先看类型，再看这个类型下的最后一个，即最后一个p类的子元素

p:last-child  先看最后一个子元素， 若最后一个子元素不是p 则样式不生效

```html
<body>
    <p>我是p</p>
    <p>我是p</p>
    <p>我是p</p>
    <p>我是最后一个p</p>
    <div>我是最后一个div</div>
</body>
<style>
    //最后一个p生效 因为是父元素body下的最后一个p
    p:last-of-type {
        color: red;
    }
    // 这个p不会生效，因为父元素Body的最后一个子元素不是p
    p:last-child {
        color:blue;
    }
    // 会生效
    div:last-child {
        color: yellow
    }
</style>
```





#### es7异步请求方法async await

```js
//申明请求方法前加async关键词
async getGoods() {
    //使用es7 async/await发送请求。 res就是以前then()返回的数据
    const res = await request({url: '/homeData'})
    this.cates = res.data.message
    //渲染数据
    //.....
}

```



#### es6 findIndex()方法

```js
//findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置
//findIndex() 方法为数组中的每个元素都调用一次函数执行
//当数组中的元素在测试条件时返回 true 时,返回符合条件的元素的索引位置，之后的值不会再查询
//如果没有符合条件的元素返回 -1  findIndex不改变原数组
let arr = [0,3,11,20]
const result = arr.findIndex(function(val){
    return val >= 10    
})
console.log(result)  //输出2  因为arr中的第3项'11'满足条件，返回它的Index=2
```



#### map、forEach、filter注意点

map不会修改原数组(基本类型)，也会修改引用类型，会返回一个映射的新数组 **必须写return**

filter不会修改原数组，**用于筛选数组**，需要**链式调用**或者**新建一个变量保存**过滤后的数组

forEach方法里**修改基本类型不会生效**，**修改对象生效**，想要操作里面的基本数据类型，就用arr[i]的形式直接操作数组。



#### reduce(数组归并)

#### reduce源码

```js
//reduce原理：总的一句，reduce方法主要是把数组遍历，
//然后把数组的每个元素传入回调函数中，回调函数怎么处理，就会的到什么样的效果
Array.prototype._reduce=function(fn,initVal){
    let pre=initVal;//对初始值进行赋值
    let i=0;        //index初始值为0
    if(!pre){//判断是否拥有初始值，若没传初始值，pre从数组第一个值开始,index从1开始
        pre=this[0];
        i=1;
    }
    for(i;i<this.length;i++){
        //关键句：把每次回调函数执行的返回值赋给pre, 并作为下一次执行的值传入给回调
        pre=fn(pre,this[i],i); 
    }
    return pre;//返回回调函数处理的最终结果，
}
```

语法

```js
arr.reduce(function(prev,cur,index,arr){
...
}, init); //init可以设置{} [] 等任意数据
```

**arr** 表示原数组；
**prev** 表示上一次调用回调时的返回值，或者初始值 init;
**cur** 表示当前正在处理的数组元素；
**index** 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；
**init** 表示初始值。 初始值可以设置{} []等任意值

##### 1. 求数组项之和

```js
var arr = [3,9,4,3,6,0,9];
var sum = arr.reduce(function (prev, cur) {
    return prev + cur;
},0);//此处传入init值为0
```

由于传入了初始值0，所以开始时prev的值为0，cur的值为数组第一项3，相加之后返回值为3作为下一轮回调的prev值，然后再继续与下一个数组项相加，以此类推，直至完成所有数组项的和并返回。

##### 2. 求数组项最大值

```
var max = arr.reduce(function (prev, cur) {
    return Math.max(prev,cur);
});
```

由于未传入初始值，所以开始时prev的值为数组第一项3，cur的值为数组第二项9，取两值最大值后继续进入下一轮回调。

##### 3. 基本类型数组去重

```js
var newArr = arr.reduce(function (prev, cur) {
    prev.indexOf(cur) === -1 && prev.push(cur);
    return prev;
},[]);//prev初始值空数组
```

##### 4. 对象类型数组去重

```js
//对象数组去重 
let arr = [
            {
                key:'1',
                name:'林青霞'
            },
            {
                key:'2',
                name:'张三丰'
            },
            {
                key:'1',
                name:'段誉'
            },
        ]
const hash = {};
let res = arr.reduce((pre, next: Object) => {
    //根据key值去重，若不存在则设置为true,并添加到数组中，若存在则跳过
    if (!hash[next.key]) {
      hash[next.key] = true
      pre.push(next)
    }
    return pre;
}, []); //将返回值的初始值定义为空数组

console.log(res) // 去重后数组:[{key: '1', name: '林青霞'},{key: '2', name: '张三丰'}]



// mill_pad端 reduce去重写法
initListInfo: function(goodList) {
    let arr = [];
    let productPut = 0;
    let putText = '';
    let returnNum = 0;
    for (let i = 0; i < goodList.length; i++) {
        let obj = {};
        obj.category_id = goodList[i].category_id;
        obj.category_name = goodList[i].category_name;
        obj.goodList = [];
        arr.push(obj);
    }
    //根据对象的属性去重，获取新数组
    let hash = {}; 
    let cateArr = arr.reduce(function(arr, current) {
        hash[current.category_id] ? '' : (hash[current.category_id] = true && arr.push(current));
        return arr;
    }, []);

    for (let i = 0; i < goodList.length; i++) {
        if (goodList[i].menu_status.value == 3) {
            //已上菜
            productPut++;
        }
        if (goodList[i].menu_status.value == -2) {
            //已退菜
            returnNum++;
        }
        if (returnNum == goodList.length) {
            putText = '正在上菜(0/0)';
        } else if (productPut >= goodList.length - returnNum) {
            putText = '上菜完毕，待买单';
        } else {
            putText = '正在上菜(' + productPut + ' / ' + Number(goodList.length - returnNum) + ')';
        }
        for (let j = 0; j < cateArr.length; j++) {
            if (goodList[i].category_id == cateArr[j].category_id) {
                cateArr[j].goodList.push(goodList[i]);
            }
        }
    }
    this.setData({
        cateArr: cateArr,
        putText: putText,
        totolGoods: Number(goodList.length - returnNum)
    });
},
```



#### map源码

```js
var arr = [1, 2, 3, 4, 5]
Array.prototype.myMap = function(fn){
    var len = this.length;
    //创建新数组
    var arr = [];
    for(var i = 0; i < len; i ++){
        arr.push(fn(this[i],i)) //将函数的返回值添加到返回数组，注意函数必须有返回值！
    }
    return arr;
}
var aa = arr.myMap(function(ele, index){
    return ele * 2;

```



#### forEach源码

```js
//1. 使用 call 方式
Array.prototype.forEach =function(callback,thisArg){
  var len =this.length;
  for(var i =0; i < len; i++){
   callback.call(thisArg,this[i], i,this);
  }
}
//2. 使用 bind 方式
Array.prototype.forEach =function(callback,thisArg){
 var len =this.length;
 callback = callback.bind(thisArg);
 for(var i =0; i < len; i++){
  callback(this[i], i,this);
 }
}
```

#### filter源码

```js
Array.prototype.myFilter = function(fn){
  let newArr = [];
  for(let i =0, len = this.length; i < len; i++){
    fn(this[i]) && newArr.push(this[i])  //等价于if(fn(this[i])){ newArr.push(this[i]) }
  }
  return newArr; //返回新数组
}

//调用myFilter方法，以函数为参数的高阶函数
var arr = [2,3,5,23,57]
arr.myFilter(function(item){
  return item > 3; //此处return值为true,加入了新数组，然后新数组返回
})
```



```js
//forEach修改原数组方法
let arr = [1,2,3]
arr.forEach((value, key) => {
 return arr[key] = value * value;  // arr = [1,4,9]
});
//map修改数组方法
let list = arr.map(value => {   
 return value * value;     //list = [1,4,9]
});

```



#### map/forEach区别点

1.都是循环遍历数组中的每一项

2.都不需要初始值和写条件表达式

3.参数都有3个，item循环的每一项，index索引值，arr原数组

4.只能遍历数组,遍历对象会报错

5.map和forEach本身不能终止循环,原因就是map和forEach第一个参数是函数，所以内部不会捕获错误



#### padding左右边距不能设置auto,会失效



#### flex布局内使用white-space:nowrap要设置固定宽度，否则会挤压左右内容



#### 字体图标大小调整使用font-size属性



### 数组splice方法

```js
var fruits = ["Banana", "Orange", "Apple", "Mango"];
// 从索引2处，删除0个元素，并插入2个元素
fruits.splice(2,0,"Lemon","Kiwi"); //fruits输出：Banana,Orange,Lemon,Kiwi,Apple,Mango
```



语法:

*array*.splice(*index*,*howmany*,*item1*,.....,*itemX*)

**注意：splice会默认返回删除的元素数组**

![img](D:\typora-img\9F673968-EB30-48C7-90F6-8CE14E737BC1.png)

| 参数                  | 描述                                                         |
| :-------------------- | :----------------------------------------------------------- |
| *index*               | 必需。规定从何处添加/删除元素。 该参数是开始插入和（或）删除的数组元素的下标，必须是数字。 |
| *howmany*             | 可选。规定应该删除多少元素。必须是数字，但可以是 "0"。 如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。 |
| *item1*, ..., *itemX* | 可选。要添加到数组的新元素                                   |

### vue重要概念

#### 全局API (常用) 

##### **Vue.set**

Vue.set( target, propertyName/index, value )

向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property 

(比如 `this.myObject.newProperty = 'hi'`)



##### Vue.nextTick

Vue.nextTick( [callback, context\] )

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。



##### Vue.filter

Vue.filter( id,  [definition] )

注册全局过滤器



##### Vue.component

Vue.component(id, [definition])

注册全局组件



#### 实例property

##### vm.$data

读取Vue实例中data的属性，可能包含多个键值对

```js
const vm = new Vue({
    data: {
        list: 'xxxx',
        counter: 'bbbb'
    }
})

//等价
vm.$data.list === vm.list
```



##### vm.$el

$el 获取vue实例关联的DOM根元素

##### vm.$parent / vm.$children

$parent: 父实例，如果当前实例有的话

$children: 当前实例的直接子组件, $children并不是响应式的

##### vm.$root

$root ： Vue根组件实例

```js
new Vue({
    data: {
        foo: 1
    },
    methods: {
        fn1:function(){}
    }
})
//所有的子组件都可以将这个实例作为一个全局 store 来访问或使用，但是大型应用推荐VueX来管理应用状态
this.$root.foo
this.$root.fn1()
```



##### vm.$refs

ref 被用来给元素或子组件注册引用信息， 引用信息将会注册在父组件的 $refs 对象上，如果是在普通的DOM元素上使用，引用指向的就是 DOM 元素，如果是在子组件上，引用就指向组件的实例。

ref 加在子组件上，用this.$refs.（ref值） 获取到的是组件实例，可以使用组件的**所有方法及data的变量**

```html
<base-input ref="userNameInput"></base-input>
```

```js
//访问子组件
this.$refs.userNameInput
```



##### vm.$slots / vm.$scopedSlots

##### vm.$attrs

$attrs是一个容器对象，这个容器对象会存放:父组件传过来的且子组件未使用props声明接收的数据

其实，爷组件传递给孙组件的逻辑流程就是，通过爷组件首先传递给父组件，当然父组件不在props中接收，那么爷组件传递给父组件的数据就会存放到父组件的`$attrs`对象中里面了，然后，再通过`v-bind="$attrs"`，再把这个`$attr`传递给孙组件，在孙组件中使用props就能接收到`$attrs中`的数据了，这样就实现了，祖孙之间的数据传递。

##### vm.$listeners

它是一个对象，包含了父作用域中的 (不含 `.native` 修饰器的) `v-on` 事件监听器。它可以通过 `v-on="$listeners"` 传入内部组件

$listeners对象：

{
  focus: function (event) { /* ... */ }
  input: function (value) { /* ... */ },
}

**注意：**

**1.子组件可以通过this.$listeners.XX 直接触发绑定事件**

**2.也可以this.$emit('XX')  传递给父组件触发**

```vue
<div id="app">
    A{{msg}}
    <my-button :msg="msg" @todo="handleClick"></my-button>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.7/vue.common.dev.js"></script>

  <script>
    let vm = new Vue({
      el: '#app',
      data: {
        msg: '100'
      },
      methods: {
        handleClick () {
          console.log('点击事件')
        }
      },
      components: {
        'MyButton': {
          template: `<div @click="$listeners.todo">B</div>`,
          created() {
            console.log(this.$listeners) // 包含父级所有绑定的方法
          }
        },
        
      }
    })
  </script>
```



#### 实例方法

##### vm.$watch

##### vm.$set /vm.$delete

```js
// 数组
Vue.$set(Array, index, newValue)
// 对象
Vue.$set(Object, key, value)
```



##### vm.$on

监听当前实例上的自定义事件。事件可以由 `vm.$emit` 触发。回调函数会接收所有传入事件触发函数的额外参数。

```js
vm.$on('test', function (msg) {
  console.log(msg)
})
vm.$emit('test', 'hi')
// => "hi"
```



##### vm.$emit

vm.$emit( eventName, […args\] )]

触发当前实例上的事件。附加参数都会传给监听器回调

#### 动态组件

```vue
<!--根据is传入的值 动态渲染要展示的组件-->
<!--home就是组件name: 'home'对应的名称，动态组件也像普通组件一样传值-->
<component is="home" :data="xxdata"></component>
```



#### vue插件安装

向vue添加全局功能时，通常用插件形式，有2种编写方式

1. 对象类型  一个对象，必须包含一个install函数，会在安装插件时执行
2. 函数类型 一个function 会在安装插件时执行

#### vue跨域配置

```js

//test.config.js文件 给window全局对象添加的额外属性
window.config = {
  mock: false,
  successCode: '0',
  returnCode: 'return_code',
  returnMessage: 'return_message',
  baseUrl: 'http://10.10.100.25:9090/iboss',
  SUCCESS_CODE: '000000',
  RETURN_CODE: 'code',
  RETURN_MESSAGE: 'message',
  PAPERLESS_RETURN_CODE: 'returnCode',
  PAPERLESS_RETURN_MESSAGE: 'returnMsg',
  PAPERLESS_SUCCESS_CODE: '1',
  PAPERLESS_AREA_CODE: '0791',
  APP_ID: 'iboss_hz',
  COLLECT_PATH: 'http://10.10.100.25:9090/collect/collect',
  COLLECT_APP_ID: 'gehua-iboss',
  COLLECT_APP_KEY: '6yqz442885bgtj0wsyjo'
}

// api/index.js 请求文件  
axios.defaults.baseURL = window.config.baseUrl  
axios.defaults.headers = {
  'Content-Type': 'application/json'
}

// config/index配置文件
proxyTable: {
      '/api': {
        target: 'http://10.10.100.99:9090',
        changeOrigin: true,
        pathRewrite: {
          '^/api': '/iboss'
        }
      }
    }
```



####  监听属性watch

```js
var watchExampleVM = new Vue({
  el: '#watch-example',
  data: {
    question: '',
    answer: 'I cannot give you an answer until you ask a question!'
  },
  watch: {
    // 如果 `question` 发生改变，这个函数就会运行
    question: function (newQuestion, oldQuestion) {  //监听函数会传入新值和旧值2个参数
      this.answer = 'Waiting for you to stop typing...'
      this.debouncedGetAnswer()
    }
  },
    
  // watch 两种写法
  watch: {
    //语法糖写法
    person(newValue,oldValue){
        console.log(newValue,oldValue)
    },
    //配置型写法, 可配置deep immediate
    person: {
        handler: function(newValue,oldValue){
            console.log(newValue,oldValue)
        },
        deep: true,     //深度侦听配置 可监听对象中属性改变
        immediate: true //立即执行
    }
}
}
```



#### 绑定class的一些用法

##### 1.绑计算属性

```html
<!--绑计算属性-->
<!--渲染结果class="active text-danger"-->
<div :class="classObj"></div>

```

```js
data: {
    isActive: true,
    error: null
},
computed:{
    classObj(){
        return {
            active: this.isActive && !this.error,
            'text-danger': this.error && this.error.type === 'fatal'
        }
    }
}
```

##### 2.绑数组

```html
<!--渲染结果class="active text-danger"-->
<div :class="[activeClass,errorClass]"></div>
<!--三元表达式动态切换-->
<div :class="[isActive ? activeClass : '', errorClass]"></div>
<!--数组中也可以使用对象语法-->
<div :class="[{ active: isActive }, errorClass]"></div>

```

```js
data: {
    activeClass: 'active',
    errorClass: 'text-danger'
}
```

##### 3.绑style样式

```html
<div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
```



#### v-show 和 v-if 区别

`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。

`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。

一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。



#### v-for 和 v-if 一起使用（官方不推荐一起用）

v-for优先级比v-if高



#### 绑定key不要用Index 



#### v-for遍历对象

```html
<!--返回object的所有value值-->
<div v-for="value in object">
	{{value}}
</div>
```

```js
data: {
    object: {
        name: 'david',
        age: 33,
        title: 'xxxx'    
    }
}
```

#### v-for遍历计算属性

```html
<!--遍历返回能被2整除的数组-->
<li v-for="n in evenNumbers">{{ n }}</li>
```

```js
data: {
    numbers: [1,2,3,4,5]
},
computed: {
    evenNumbers(){
        return this.numbers.filter(item => {
            return item % 2 === 0
        })
    }
}
```

#### v-for嵌套遍历（计算属性不适用时）

```html
<ul v-for="set in sets">
    <li v-for="n in even(n)">{{n}}</li>
</ul>
```

```js
data: {
    sets: [[1,2,3],[4,5,6]]
},
methods: {
    even(numbers){
        return numbers.filter(item => {
            return item % 2 === 0
        })
    }
}
```



#### v-on绑定事件

有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 `$event` 把它传入方法：

```html
<button v-on:click="warn('Form cannot be submitted yet.', $event)">
  Submit
</button>
```

```js
// ...
methods: {
  warn: function (message, event) {
    // 现在我们可以访问原生事件对象
    if (event) {
      event.preventDefault()
    }
    alert(message)
  }
}
```

#### 事件修饰符

```html
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>
```



#### 修饰符顺序

使用修饰符时，顺序很重要；因此，用 `v-on:click.prevent.self` 会阻止**所有的点击**(阻止了默认事件，也就阻止了click事件)

而 `v-on:click.self.prevent` 只会阻止对元素自身的点击。(阻止click事件，就不会执行阻止默认事件)



#### v-model

v-model : 双向绑定
一般用于绑定表单输入的内容,限制在<input>、<select>、<textarea>、components中使用

v-model其实是语法糖:
<input v-model="test">本质上是
<input :value="test" @input="test = $event.target.value">   //绑定输入框的value值，@input是对输入事件的监听，再把监听到的值放入value

checkbox v-model="checkedNames"

<input type=checkbox  @change="checkedNames=$event.target.value">

##### v-model修饰符

.lazy   将input的实时更新转换为change事件，即改变完后更新

.number v-model默认是字符串，将绑定值转化为Number类型

.trim  过滤用户输入的首尾空格

##### v-model绑定复选框

```html
<!--把复选框的value值传给了checkedNames-->
<input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
<label for="jack">Jack</label>
<input type="checkbox" id="john" value="John" v-model="checkedNames">
<label for="john">John</label>
<input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
<label for="mike">Mike</label>
<br>
<!--span根据checkbox选择显示对应的复选框value值-->
<span>Checked names: {{ checkedNames }}</span>
```

```js
new Vue({
  el: '...',
  data: {
    checkedNames: []
  }
})
```

##### v-model绑定下拉框

```html
<div>
    <select v-model="selected">
    	<option disabled value="">请选择</option>
        <option>A</option>
        <option>B</option>
        <option>C</option>
    </select>
    <!--显示对应选择的A或B或C-->
    <span>selected: {{selected}}</span>
</div>
```

```js
data: {
    selected: ''
}
```



#### prop静态或动态传值

```html
<!--静态传值 子组件获取一个字符串-->
<my-cpn title="my journey"></my-cpn>

<!--动态传值 获取Item的title属性-->
<my-cpn :title="item.title"></my-cpn>
```

##### 子组件变更prop 

prop是单向数据流，父级更新流动到子组件，反向不行

1.**这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。**在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：

```js
props: ['initialName'],
data: function(){
    return {
        name: this.initialName
    }
}
```

2.**这个 prop 以一种原始的值传入且需要进行转换。**在这种情况下，最好使用这个 prop 的值来定义一个计算属性：

```js
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
```

注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身**将会**影响到父组件的状态。

prop指定类型

```js
props: {
    //基础数值类型
    myNumber: Number,
    xxxList: {
        type: Array,  //数组类型  
        default() {   //数组或对象类型必须从一个函数中返回
            return []
        }
    }， 
    //自定义验证函数
    validator: function(value){  
        return ['success','warning','danger'].indexOf(value) !== -1
    }
}
```



#### 将事件绑定到组件 .native

当组件外包一层根元素时，**监听<input>这类特别元素时** .native会失效，需要使用$listeners，将监听器指向组件中的某个特定元素

$listeners对象：

{
  focus: function (event) { /* ... */ }
  input: function (value) { /* ... */ },
}

```html
<!--当父级调用这个组件并使用focus.native监听事件时会失效，-->
<base-input v-on:focus.native="onFocus"></base-input>

<!--base-input子组件，根元素是label, 原生focus事件失效-->
<label>
    {{label}}
	<input v-bind="$attrs" :value="value" @input="$emit('input',$event.target.value)" />
</label>
```

```js
//有了这个 $listeners property，你就可以配合 v-on="$listeners" 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 <input> 的你希望它也可以配合 v-model 工作的组件来说，为这些监听器创建一个类似下述 inputListeners 的计算属性通常是非常有用的：
//<base-input>就是一个透明的包裹器了，不必使用.native监听了
Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  computed: {
    inputListeners: function () {
      var vm = this
      // `Object.assign` 将所有的对象合并为一个新对象
      return Object.assign({},
        // 我们从父级添加所有的监听器
        this.$listeners,
        // 然后我们添加自定义监听器，
        // 或覆写一些监听器的行为 
        // 重要！相同的input属性，后者覆盖前者，所以$lisntener中的input会被覆盖
        {
          // 这里确保组件配合 `v-model` 的工作
          input: function (event) {
            vm.$emit('input', event.target.value)
          }
        }
      )
    }
  },
  template: `
    <label>
      {{ label }}
      <input
        v-bind="$attrs"
        v-bind:value="value"
        v-on="inputListeners"
      >
    </label>
  `
})
```



#### v-slot 

vue2.6.0以后 **slot  attribute具名插槽**和**slot scope attribute作用域插槽** 已在vue3中废弃， 使用**v-slot**代替

即`<div slot="header">` 这种写法已废弃

```html
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>

<!--v-slot必须用在<template>标签上(只有后面一种例外)-->
<base-layout>
  <template v-slot:header>
    <h1>Here might be a page title</h1>
  </template>

  <p>A paragraph for the main content.</p>
  <p>And another one.</p>

  <template v-slot:footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>
```

#### 作用域插槽

作用域插槽是绑定数据的插槽，可以获取到父组件传递的参数，将这些参数使用到子组件插槽里

```html
<!--<current-user>组件-->
<span>
  <slot>{{ user.lastName }}</slot>
</span>
<!--父组件想改变渲染的值,这种写法是不通的，父组件无法获取子组件的user-->
<current-user>{{user.firsrName}}</current-user>


<!--正确写法-->
<!--把user当做slot的一个属性绑定上去-->
<span>
    <!--这个叫插槽prop 把user作为值传给父组件-->
    <slot :user="user">{{user.lastName}}</slot>
</span>


<current-user>
    <!--包裹template 使用带值的v-slot来定义插槽名字,就可以通过slot的属性获取到user-->
	<template v-slot:default="slotProps">
    	{{slotProps.user.firstName}}
    </template>
</current-user>

```

#### 作用域插槽2

```vue
<!--创建作用域插槽-->
Vue.component("todo-list",{
    inheritAttrs:false,
    props:{
        todos:[Array,Object]
    },
    template:
    `<ul>
        <li v-for="todo in todos" :key="todo.id" style="display: block;" >
            <slot :data="todo">{{todo.text}}</slot>
        </li>
     </ul>`
	})

<!--使用作用域插槽，通过slot-scope实现-->
<todo-list :todos="todos">
    <template slot-scope="slotProps">
        <span v-if="slotProps.data.isTrue">√</span>
        {{slotProps.data.text}}
    </template>
</todo-list>
```



#### 封装-作用域插槽组件

普通做法：使用$emit层层传递自定义事件，但是组件和业务逻辑耦合度高

使用作用域插槽目的： 组件和业务的剥离

![img](D:\typora-img\d4e88ac23aa6c4d5f5e037874fecae6d.png)

```vue
//3层组件 columnList--> commodityList--> commodity
//通过作用域插槽将本应该由CommodityList处理的商品卡片点击业务onCommodityClick提升到ColumnList处理
//columnList.vue
<el-row :gutter="20">
        <el-col :span="12" v-for="(column, index) in columnList" :key="index">
            <el-card class="box-card card-column">
                <div slot="header" class="clearfix">
                    <span>{{column.columnName}}</span>
                </div>
                <commodity-list :commodities="column.commodityList">
                    <template slot-scope="scope">
   <!-- 这里只需要给Commodity组件传入数据，响应Commodity组件的clickCommodity事件即可。事件不必携带参数，完全符合父到子的数据流向，而不会发生子组件又给父组件反向发数据的情况 -->
                        <commodity :modityData="scope.row" 		                        						@clickCommodity="onCommodityClick(scope.row)">
                        </commodity>
                    </template>
                </commodity-list>
            </el-card>
        </el-col>
</el-row>


<!-- CommodityList.vue  slot接收来自父组件的商品卡片组件 -->
<el-row :gutter="20">
        <el-col :span="8" v-for="(item, index) in commodities" :key="index" style="margin-top:20px;">
            <slot :row="item"></slot>
        </el-col>
</el-row>


<!--原commodity-list.vue 逻辑-->
<commodity v-for="(item,index) in commodities" @clickCommodity="onCommodityClick"></commodity>
```





#### 独占默认插槽(v-slot可以写在组件标签上)

当被提供的内容**只有默认插槽**时，组件的标签才可以被当作插槽的模板来使用。可以把 `v-slot` 直接用在组件上

**不能和具名插槽混用**，会导致作用域不清楚。混用时依然要写在Template上

```html
<current-user v-slot:default="slotProps">
	{{slotProps.user.firstName}}
</current-user>
```



#### 插槽缩写: v-slot可以缩写成#  

```html
<current-user>
	<template #header>
    	{{user.firstName}}
    </template>
</current-user>
```



#### filters过滤器

过滤器可以用在2个地方：{{ }}内 或 v-bind表达式

```html
<!--1.双花括号内-->
<div>{{number | filterNumber}}</div>

<!--2.v-bind表达式内-->
<div v-bind:time="formatTime"></div>
```



#### 解构赋值

```js
let node = {
    type: 'hahaha',
    name:'david'
}
let {type, name} = node 
console.log(type)  //hahaha
console.log(name) //david

//name重命名为localName
let {type, name: localName} = node
console.log(localName) //david
```

#### 多层对象解构

```js
let obj = {
    person: {
        name: 'david',
        age: '34'
    }
}
let {person: {name, age}} = obj
```



#### JSONP跨域

jsonP本身就是一个get请求，而script节点本身也是一个get请求，这个思想是通过后端的配合（后端输出的 response text必须符合js语法）更好的利用了get请求而已。  

 而前端封装一个方法，通过这个方法把请求注册的回调指向全局的一个具名函数，同时把具名函数的函数名和参数通过get请求传递给后端而已。

**前端**

```html
<!--通过src发送请求-->
<script>
    //提前定义要执行的函数 通过<script>标签回调执行指向的这个函数
    function getData(data){
        const res = document.getElementById('result')
        res.innerHTML = data.name
    }
    //点击时触发，创建script发送请求给后端
    xx.onClick = function(){
        let script = document.creatElement('script')
        script.src = "http://xxxx/jsonp-server"
        document.body.append(script)
    }
</script>
```

**后端**

```js
app.all('/jsonp-server',(request,response) => {
    const data = {name: 'david'}
    let str = JSON.stringify(data)
    //后端返回前端函数的调用，就是jsonp的实现原理
    response.end(`getData(${data})`) 
})
```





#### 跨域的几种解决方案

```js
//1.原生跨域
var script = document.createElement('script')
//传参给服务器，里面包含了服务器要执行的回调函数
script.src = 'https://www.domain2.com:8080/login?user=admin&callback=getData'
document.head.appendChild(script)
//回调执行函数
function getData(res){
    alert(JSON.stringify(res))
}
//服务端把data传进去
getData({'status': true, 'user': 'admin'})


//2.jquery+jsonp跨域
$.ajax({
    url: 'http://www.domain2.com:8080/login',
    type: 'get',
    dataType: 'jsonp',
    jsonpCallback: 'handleCallback', //回调函数名称 传给后端用
    data: {},
    success: function(response,status,xhr){
        console.log('状态为'+status+,'状态是'+xhr.statusText)
        console.log(response)
    }
})

//3.vue跨域配置代理
module.exports ={
    dev: {
        proxyTable: {
            //把所有的接口统一规范为一个入口，在一定程度上会解决冲突
            '/api': {
                target: 'http://localhost:3000',
                changeOrigin: true //是否允许跨域的配置
                //pathRewrite: {'^/api' : ''} //后面可以使重写的新路径，一般不做更改
            }
        }
    }
}
```



#### BFC机制

合理利用bfc机制可以解决**margin塌陷**，**float导致父元素高度塌陷**等问题

**BFC概念**

每一个BFC区域只包括其子元素，不包括其子元素的子元素。(这1点比较容易理解)

每一个BFC区域都是独立隔绝的,互不影响!(这点不太好理解，但是后续会使用代码验证)

**触发BFC的条件**

·body根元素

·设置浮动，不包括none

·设置定位，absoulte或者fixed

·行内块显示模式，inline-block

·**设置overflow(常用)，即hidden，auto，scroll**

·表格单元格，table-cell

·弹性布局，flex

```html
<!--#HM_bfc1是一块BFC区域，这块区域包含了box2、box3、box4、box5，也就是所有#HM_bfc1的子元素。同时#HM_bfc2也创造了一块BFC区域，包含了box6，box7，box8。注意，第一个box1的BFC，只包括box1的子元素box2345，不包括box678。#HM_bfc2这个BFC同样也仅仅是包括自己的子元素box678。-->
<div class="box1" id="HM_bfc1">
    <div class="box2">div>
    <div class="box3">div>
    <div class="box4">div>
    <div class="box5" id="HM_bfc2">
        <div class="box6">div>
        <div class="box7">div>
        <div class="box8">div>
    </div>
</div>
```



### webpack配置优化

#### build发布时 删除所有console代码

```js
//babel.config.js
const prodPlugin = []
//proccess.env.NODE_ENV 获取当前环境常量
if(proccess.env.NODE_ENV === 'production'){
    prodPlugin.push('transform-remove-console')//发布阶段删除console代码的插件
}
module.exports = {
    presets: ['@vue/app'],
    plugins: [
        [
             'component',
        {
            libraryName: 'element-ui',
            styleLibraryName: 'theme-chalk'
        }
        ],
        ...prodPlugin  //配置要生效的插件
       
    ]
    
}
```

#### 据开发环境配置不同的入口文件main-prod.js / main-dev.js

```js
//vue.config.js
//chainWebpack和configureWebpack是一样的效果
module.exports = {
    chainWebpack: config => {
        //发布模式
        config.when(proccess.env.NODE_ENV === 'production', config => {
			config.entry('app').clear().add('./src/main-prod.js')
            //发布模式把所有依赖包都通过CDN模式引入，压缩发布包大小
            //此时main-prod.js文件内的import文件都可以删除了
            config.set('externals',{//externals加载外部CDN资源
                vue: 'Vue',
                'vue-router': 'VueRouter',
                axios: 'axios',
                lodash: '_',
                echarts: 'echarts',
                nprogress: 'NProgress'
            })
        })
        //开发模式
        config.when(proccess.env.NODE_ENV === 'development', config => {
			config.entry('app').clear().add('./src/main-dev.js')
        })
    }
}
```

```html
<!--public/index.html 发布包文件内引入上面externals配置要引入的依赖包-->
<html>
    <head>
       <!--引入css依赖文件--> 
        <link rel="styleSheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css"></link>
    <!--引入js依赖文件 等等-->
    <scrpit src="https://cdn.staticfile.org/vue/2.5.22/vue.min.js"></scrpit>
    <scrpit src="https://cdn.staticfile.org/vue-router/3.0.1/vue-router.min.js"></scrpit>
    <scrpit src="https://cdn.staticfile.org/lodash.js/1.0.2/lodash.min.js"></scrpit>
    </head>
</html>
```



### Object.assign 合并对象

将源对象（source）的所有可枚举属性，复制到目标对象（target）。

```js
const target = { a: 1 };

const source1 = { b: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}

//实际用法
//将多个对象合并到某个对象 注意这里...是不定参数，不是解构
const merge = (target, ...sources) => Object.assign(target, ...sources);

//合并多个对象并返回一个新对象
const merge = (...sources) => Object.assign({}, ...sources);

//将属性x,y添加到对象point类对象实例中
class Point {
  constructor(x, y) {
    Object.assign(this, {x, y});
  }
}

//给对象添加方法
Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});

// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) {
  ···
};
SomeClass.prototype.anotherMethod = function () {
  ···
};
```

### Object.keys()

方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。

```js
var anObj = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.keys(anObj)); // console: ['2', '7', '100']

var arr = ['a', 'b', 'c'];
console.log(Object.keys(arr)); // console: ['0', '1', '2']

var obj = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.keys(obj)); // console: ['0', '1', '2']

// getFoo is a property which isn't enumerable
var myObj = Object.create({}, {
  getFoo: {
    value: function () { return this.foo; }
  }
});
myObj.foo = 1;
console.log(Object.keys(myObj)); // console: ['foo']
```



### Object.values()

返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用[`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in)循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。

```js
var obj = { foo: 'bar', baz: 42 };
console.log(Object.values(obj)); // ['bar', 42]

// array like object
var obj = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.values(obj)); // ['a', 'b', 'c']

// array like object with random key ordering
// when we use numeric keys, the value returned in a numerical order according to the keys
var an_obj = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.values(an_obj)); // ['b', 'c', 'a']

// getFoo is property which isn't enumerable
var my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });
my_obj.foo = 'bar';
console.log(Object.values(my_obj)); // ['bar']

// non-object argument will be coerced to an object
console.log(Object.values('foo')); // ['f', 'o', 'o']
```



### Object.create()

用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）

```js
// 底层实现
Object.create =  function (o) {
    var F = function () {};
    F.prototype = o;
    return new F();
}

// o的prototype指向obj
let obj = {a:1};
let o = Object.create(obj);
obj.hasOwnProperty('a'); // true
o.hasOwnProperty('a'); // false 不检测原型上的属性
obj.a // 1
o.a // 1
```



### 字符串转数字，数字转字符串快捷方法

```js
//字符串转数字, 字符串-0
let str = '123'
console.log(str - 0) // 123

//数字转字符串，后面+ ''
let str2 = 123
console.log(str2 + '') //'123' 
```



### css常用样式

```css

.cate-name{
  display: inline-block;
  position: relative;
  font-size: 34rpx;
  line-height: 1;
  margin: 32rpx 0rpx 20rpx 0rpx;
}
/*利用after伪元素给文字添加背景色*/
.cate-name::after{ 
  position: absolute;
  top: 0rpx;
  left: 0rpx;
  right: 0rpx;
  content: '';
  z-index: -1;
  bottom: 0rpx;
  border-radius: 50%;
  background: rgba(248, 182, 44, 1);
}

/*阴影样式*/
.card{
  padding: 30rpx 28rpx;
  width: 686rpx;
  box-sizing: border-box;
  box-shadow:0px 4px 6px 0px rgba(0,0,0,0.1); /*关键语句*/
  border-radius:8rpx;
  background: #fff;
  margin: 10rpx auto 26rpx auto;
}

/*两边横线中间文字*/
.title {
    display: table;
    width: 100%;
    line-height: 32px;
    color: #969696;
    font-size: 12px;
    white-space: nowrap;
    border-spacing: 10px 0;
    /* 伪元素设置前后横线 */
    &:before,&:after {
        display: table-cell;
        content: '';
        width: 50%;
        background: -webkit-linear-gradient(#969696, #969696) repeat-x left center; /*渐变+背景重复+left center定位在中间*/
        background: linear-gradient(#969696, #969696) repeat-x left center;
        background-size: auto 0.3px; /* 必须设置背景size高度 否则渐变会占满容器 */
    }
}
```



#### 

### line-height: 1

line-height：1 ，相当于line-height：100%，会根据该元素本身的字体大小设置行高，比如字体大小是15px，行高就是15px

line-height：1.5，相当于line-height：150%；
line-height：0.5，相当于line-height：50%。

### 负margin

![1.gif](D:\typora-img\1537328821879881.gif)

一个static元素是一个没有使用过float的元素。上面的图片展示了一个static的元素使用负边距之后的情况。

当一个static元素在top/left使用负边距时，它把元素向这个特定的方向拉，

但是当你将负边距设置为相对bottom/right时，它并不会把元素向下或右拉，相反，它会把后面的元素往里面拉，从而覆盖自己。

margin为负且盒子static时：

- 若属性为top、left，盒子将被拉进指定的方向;
- 若属性为bottom、right,将后续的元素拖拉进来，覆盖本来的元素。
- 若width没有被设置，设定负margin-left/right会将元素拖向对应的方向，并增加宽度，此时的margin的作用就像padding一样



### margin居中

**margin auto**对于不同的元素类型有不同的取值。但是在任何情况下，**auto都为以下两种取值之一**：

1、父元素剩余空间的值 

​	普通块级元素(static / relative) 设定 width 值时的 margin-left 和 margin-right

2、0px

- 行内元素(inline), float 以及 position 值为 absolute 或 fixed
- 元素的 margin-top 和 margin-bottom
- 普通块级元素未设定 width 值时的 margin-left 和 margin-right

**特殊情况:absolute 元素 margin: auto 水平垂直居中**

水平居中：(W3C规定)

1、left,  right 和width都没有设置(即取默认值 auto)，在这种情况下 margin-left 和 margin-right 的 auto 值为 0

2、left, right和 width的值都设定了，此时如果 margin-left 和 margin-right 都为 auto， 即 (parent_width - width - left - right) / 2平分剩余空间

垂直居中：(W3C规定)

1、top, bottom和 height都没有设置(即取默认值 auto)，在这种情况下 margin-top 和 margin-bottom 的 auto 值为 0

2、top, bottom和 height的值都设定了，此时如果 margin-top 和 margin-bottom 都为 auto， 即 (parent_height - height - top - bottom) / 2 平分剩余空间

```css
.container {
    position: absolute;
    left: 0;
    right: 0;
    width: 100px;
    margin: 0 auto; // 绝对定位后，left,right为0，且设置宽度后，可以使用margin居中
}
```



### filter源码

```js
 Array.prototype.my_filter = function (callback) {
        if (!Array.isArray(this) || !this.length || typeof callback !== 'function') {
            return []
        } else {
            let result = [];
            for (let index = 0; index < this.length; index++) {
                const element = this[index];
                if (callback(element, index, this)) {
                    result.push(element)
                }
            }
            return result
        }
    }

    let arr = [1, 2, 3, 4, 5]
    let res = arr.my_filter((ele, i) => {
        return ele % 2 === 0
   	})
        console.log(res)//[2,4]
```





### break、return区别

1、break：是立即结束循环语句，并跳出循环语句，进行下个语句执行。

2、continue：是停止当前循环语句，并开始一次新的循环。

3、return：只能出现在函数中，用来停止函数。

4、使用的语句环境不一样，break和continue是用在循环或switch语句中，return是用在函数语句中。

### 

### 构造函数的本质

定义：用**new**关键词来调用的函数，就是构造函数

```js
// 创建函数时，并不知道是不是构造函数
function Animal(color){
	this.color = color
}
// 当用new调用时，才是构造函数
var dog = new Animal('black') // 创建一个新的内存空间 #dog
```

构造函数创建过程：

1.当以new关键词调用时，会创建一个新的内存空间，标记为Animal的实例

2.函数体内部this指向该实例

3.执行函数体内代码

4.默认返回this, 由于函数体内部的this指向新创建的内存空间，默认返回 this ，就相当于默认返回了该内存空间，也就是#dog。此时，#dog的内存空间被变量dog所接受。也就是说 dog 这个变量，保存的内存地址就是 #dog，同时被标记为 Animal 的实例。

```js
//伪代码表示构造函数创建过程
function Person(name){
  // 创建this变量，指向空对象
  var this = {}; 
  // 属性和方法被加入到this引用的对象中
  this.name = name;
  this.say = function(){
    return "I am " + this.name;
  }
  // 返回this对象
  return this;
}
// 直接调用函数，this指向window,并且不会返回任何对象
var person1 = Person('nicole');
person1; // undefined
window.name; // nicole
```

tips: 指定了返回值时，this对象可能会丢失

```js
// 测试：手动添加一个基本类型返回值，最终还是返回this
function Person(age){
	this.age = age
    return 100
}
let p1 = new Person(34)
console.log(p1) // Person{age: 34} 返回Person实例，不会返回100

// 添加对象类型返回值，则会返回该对象,this丢失
function Person2(){
    this.height = '1.88'
    return {gender: '男'}
}
let p2 = new Person2()
console.log(p2) // {gender: '男'}
```



```js
// 为了防止因为忘记使用new关键字而调用构造函数，可以加一些判断条件强行调用new关键字
function Person(name){
  if (!(this instanceof Person)) {
    return new Person(name);
  }
  this.name = name;
  this.say = function(){
    return "I am " + this.name;
  }
}

var person1 = Person('nicole');
console.log(person1.say()); // I am nicole
var person2 = new Person('lisa');
console.log(person2.say()); // I am lisa
```



### class关键字创建构造函数

constructor是构造函数初始化时自动执行的方法

**(1)constructor是一个构造函数方法，创建对象时自动调用该方法**
 **(2)constructor是类必须的一个属性，少了他类的创建会报错，如果我们不写的话js会给他自动加上**
 (3)this指的是实例化对象,就相当于构造函数中的this，指向的是当前创建的对象
 (4)类中声明函数不需要function关键字，直接函数名即可
 (5)方法之间不需要逗号分割，加了会报错

```js
//使用class关键字创建一个类
    class test {
        constructor(val) {  //初始化函数，创建对象时自动调用该方法
            this.name = val
        }
        sayName(){
            console.log(this.name)
        }
    }
    let o = new test('小猫')
    o.sayName() //小猫
```





### prototype和原型链

**首先：只有函数对象有prototype属性，普通对象只有proto属性**

#### proto

class本质还是一个function 因此它就会拥有一个prototype属性，**当new一个class时，会把class的porototype属性赋值给这个新对象的 proto属性**

所以当创建一个函数，并用该函数作为构造函数创建对象时，创建的实例对象会拥有proto属性

proto属性指向构造函数的prototype(实例对象继承的本质)

```js
function Person(){}
let p1 = new Person()
p1.__proto__ === Person.prototype //true

// 构造函数本身的proto属性直接指向Fucntion.prototype
Person.__proto__ === Function.prototype

// prototype也是一个对象，也有__proto__属性
Person.prototype.__proto__ === Object.prototype
```

#### constructor

constructor返回创建此对象的函数的引用

它存在于每一个function的prototype属性中

在创建一个函数对象function Fn1(){}时做了2件事：

**1.给该函数添加一个原型属性prototype**

**2.给prototype对象添加一个constructor属性，该属性保存对Fn1自己的引用(指向自己)**

```js
let arr = new Array()
arr.constructor === Array //true
Array.prototype.constrcutor === Array // true

// 构造函数本身也是函数，是Function构造函数的实例对象
// 和prototype上的constructor不是同一个对象
Array.constructor === Function // true
String.constructor === Function //true
```



①所有**`引用类型`**都有一个`__proto__(隐式原型)`属性，属性值是一个普通的对象 
②所有**`函数`**都有一个`prototype(显式原型)`属性，属性值是一个普通的对象 
③所有**引用类型**的__proto__属性`指向`它**构造函数**的**prototype**

```js
var a = [1,2,3];
//实例对象的隐式原型 指向 构建该实例对象的类的显式原型
a.__proto__ === Array.prototype; // true
// 实例的构造函数指向创建这个实例的类
a.constructor === Array //true
// 类的构造函数指向这个类本身
Array.prototype.constructor === Array //true
a.constructor.prototype === Array.prototype // true

// 获取原型的3种方法
Object.getPrototypeOf(one) // 官方推荐
a.__proto__
a.constrcutor.prototype
```

![è¿éåå¾çæè¿°](D:\typora-img\20180620134143385)

![img](D:\typora-img\850375-20190708153139577-2105652554.png)



### 设置cookie

```js
//设置cookie
function setCookie(name,value,days){
    var date = new Date();
    date.setTime(date.getTime()+days*24*3600*1000);
    var expire = ';epxires=' + date.toDateString();
    document.cookie = name + '=' + value + expire + ';/path'
}
//常规获取value写法
function getCookie(name){
    var cookieStr = $('#cookieName').val() + '=';
    var cArr = document.cookie.split(';');
    for(var i=0;i<cArr.length;i++){
        var cookie = cArr[i];
        //去掉每个cookie字段前面的空格
        while(cookie.charAt(0)==' '){
            cookie = cookie.substring(1,cookie.length);
        }
        //匹配到要获取的cookie值
        if(cookie.indexOf(cookieStr)==0){
            //截取value
           $('#cookieVal').val(cookie.substring(cookieStr.length,cookie.length))
        }
    }
}

//善语代码
export const setCookie = (name, value, expiredays) => {
	var exdate = new Date();
	exdate.setDate(exdate.getDate() + expiredays);
	document.cookie = name + "=" + escape(value) + ((expiredays == null) ? "" : ";expires=" + exdate.toGMTString()) + ";path=/";
}

export const getCookie = (name) => {
    //正则匹配设置了多个匹配规则，会返回多个匹配项
	var arr, reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)");
    //此处match匹配会返回一个数组，数组第3个是value
	if(arr = document.cookie.match(reg)) {
		return unescape(arr[2]);//第3个就是value
	} else {
		return null;
	}
}
```



### 基于发布订阅模式的事件绑定机制

![img](D:\typora-img\910389-4d24c83c29727ec2.png)



### vue-provide/inject机制

这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。

provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。

inject 选项应该是：
 一个字符串数组，或
 一个对象，对象的 key 是本地的绑定名，value 是：
 在可用的注入内容中搜索用的 key (字符串或 Symbol)，或
 一个对象，该对象的：
 from 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol)
 default 属性是降级情况下使用的 value

**使用场景：由于vue有$parent属性可以让子组件访问父组件。但孙组件想要访问祖先组件就比较困难。通过provide/inject可以轻松实现跨级访问祖先组件的数据**

```js
// 父组件中返回要传给下级的数据
  provide () {
    return {
      reload: this.reload
    }
  },
 methods: {
    reload () {
      this.isRouterAlive = false
      this.$nextTick(() => {
        this.isRouterAlive = true
      })
    }
  }

//子组件inject调用
//引用vue reload方法
  inject: ['reload'],
  methods: {
    // ...mapActions(['freshList']),
    async successHandle () {
      this.reload()
    }
  }
```



### vuex相关概念

```vue
<script>
export default {
// computed内放state和getters
computed: {
    ...mapState({
      paperlesssSignNo: state => state.operator.signNo,
      operatorData: state => state.operator.data,
      collectionRelationKinds: state => state.collectionRelation.kinds,
      collectionRelationKindIndex: state => state.collectionRelation.kindIndex,
      customerList: state => state.customer.list,
      customerIndex: state => state.customer.index,
      collectionRelationList: state => state.collectionRelation.list,
      collectionRelationIndex: state => state.collectionRelation.index,
      pageSelectTabKey: state => state.page.selectTabKey
    }),
    ...mapGetters({
      ENUMS_GET_NAME,
      ENUMS_GET_KEY_VALUE,
      COLLECTION_RELATION_GET_KINDS
    })
},
// methods内放action和mutation
methods: {
    ...mapMutations({
      COLLECTION_RELATION_SET_KIND_INDEX,
      ORDER_PARAM_SET_INFOS
    }),
    ...mapActions({
      BANK_SIGN_GET_AUTH_CODE,
      BANK_SIGN_UNSIGN,
      BANK_SIGN_SUBMIT_AUTH_CODE,
      BANK_SIGN_QUERY_ENTRUST,
      BANK_SIGN_GET_PRODINSTID
    }),
}
}
</script>
```



state常规用法

用data接收state值不能及时响应更新,用**computed**就可以

```js
//state.js
let state = {
    count: 1,
    name: 'xxx',
    age: 33,
    from:'china',
    sex: 'male'
}
export default state
```



```js
const Counter = {
  template: `<div>{{ count }}</div>
			 <div>{{ dataCount }}</div>`,
    
  //data接收state值是无法实时刷新页面数据的
   data(){
     return {
         dataCount: this.$store.state.count
     } 
  },
    //computed内接收state值才可以及时响应
  computed: {
    count () {
      return this.$store.state.count
    }
  }
}
```

#### mapState

当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 `mapState` 辅助函数帮助我们生成计算属性

```js
// 在单独构建的版本中辅助函数为 Vuex.mapState
import { mapState } from 'vuex'

export default {
  // ...
  computed: mapState({
    // 箭头函数可使代码更简练
    count: state => state.count,

    // 传字符串参数 'count' 等同于 `state => state.count`
    countAlias: 'count',

    // 为了能够使用 `this` 获取局部状态，必须使用常规函数
    countPlusLocalState (state) {
      return state.count + this.localCount
    }
  })
}


```

```js
//当映射的计算属性的名称与 state 的子节点名称相同时，可以给 mapState 传一个字符串数组
computed: mapState([
  // 映射 this.count 为 store.state.count
  'count'
])
```

#### 展开运算符

```js
//mapState 函数返回的是一个对象,可以使用展开运算符与局部计算属性混合使用
computed: {
  localComputed () { /* ... */ },
  // 使用对象展开运算符将此对象混入到外部对象中
  ...mapState({
    // ...
  })
}
```



#### getters

getters相当于store的计算属性，接受state作为第一个参数

```js
const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: '...', done: true },
      { id: 2, text: '...', done: false }
    ]
  },
  getters: {
    doneTodos: state => {
      return state.todos.filter(todo => todo.done)
    }
  }
})
//Getter 会暴露为 `store.getters` 对象，你可以以属性的形式访问这些值：
store.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]

//Getter 可以接受其他 getter 作为第二个参数：
getters: {
   // ...
  doneTodosCount: (state, getters) => {
    return getters.doneTodos.length
  }
}
store.getters.doneTodosCount // -> 1

/*
通过方法访问
你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。
*/
getters: {
  // ...
  getTodoById: (state) => (id) => {
    return state.todos.find(todo => todo.id === id)
  }
}
store.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }
```



##### 延伸：函数柯里化 传额外参数

官方解释:是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，

并且返回接受余下的参数而且返回结果的新函数的技术

```js
//ES5实现
function add(x){
  return function(y){
    return y + x;
  };
}

var addTwo = add(2);
addTwo(3);          // => 5
add(10)(11);        // => 21
//add函数接受x，返回一个函数接受y返回y＋x。如何用箭头函数实现同样功能呢？我们知道：

//箭头函数体是表达式，并且箭头函数隐式返回表达式，所以为了实现高阶函数，我们可以使箭头函数的函数体为另一个箭头函数：
const add = x => y => y + x;
// outer function: x => [inner function, uses x]
// inner function: y => y + x;


//柯里化的作用：
//1.参数复用
// 正常正则验证字符串 reg.test(txt)
// 函数封装后
function check(reg, txt) {
    return reg.test(txt)
}

check(/\d+/g, 'test')       //false
check(/[a-z]+/g, 'test')    //true

// Currying后
function curryingCheck(reg) {
    return function(txt) {
        return reg.test(txt)
    }
}
//将第一个参数reg进行复用，这样别的地方就能够直接调用hasNumber，hasLetter等函数，让参数能够复用，调用起来也更方便。
var hasNumber = curryingCheck(/\d+/g)
var hasLetter = curryingCheck(/[a-z]+/g)

hasNumber('test1')      // true
hasNumber('testtest')   // false
hasLetter('21212')      // false
```



#### `mapGetters` 

**mapGetters映射到组件的computed**

mapGetters辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：

```js
//组件内
import { mapGetters } from 'vuex'   //导入映射函数模块
import cartListItem from './cartListItem'

export default {
  name: 'cartList',
  computed: {
      // 数组形式: 利用辅助映射函数导入vuex--store-getters内的cartList
    ...mapGetters(['cartList']) 
      
    ...mapGetters({
      doneCount: 'doneTodosCount'  // 对象形式: getter方法重命名
  	})
  },
    
 //--store/getters.js
export default {
  cartLength(state){
    return state.cartList.length
  },
  cartList(state){
    return state.cartList
  }
}


// store/index.js
import Vue from 'vue'
import Vuex from 'vuex'
import getters from './getters'   //导入getter模块

// 1.安装插件
Vue.use(Vuex)

// 2.创建store对象
const store = new Vuex.Store({
  state: {
    cartList: ['商品1','商品2','商品3']   //购物车商品列表
  },
  //mutations唯一的目的：修改state中数据的状态
  mutations: {  
    /**
     * mutations内是同步操作，addCart应该放在异步操作
     */
   //mutations唯一目的就是修改state中的数据
    //这里把判断的条件分解成2个事件，保证mutation内每个事件只处理一件事的原则
    addCart(state, payload) {     //1.商品添加到购物车的事件
      payload.checked = true   //商品选中状态  默认为选中
      state.cartList.push(payload)
    },

    addCounter(state, payload) {   //2.商品已存在，数量+1事件    
      payload.count++
    }
  },
  getters ,  //导入被抽离的getters模块
  actions: {
    //****actions内是异步操作
    addCart(context,payload){   //payload 即传过来的商品
      /** 放在promise内，这样调用addCart函数时，可以通过then()获取到resolve内容
       *  方便别人知道你是否完成了这个操作*/ 
      return new Promise((resolve,reject) => {
        let oldProduct = null;
      for(let item of this.state.cartList){ //遍历购物车列表
        if(item.id === payload.id){  //如果有该商品
          oldProduct = item    //则给oldProduct赋值
        }
      }
      //判断oldProduct是否有值
      if(oldProduct){
        context.commit('addCounter', oldProduct) //分发: 调用mutation内的addCounter事件
        resolve('当前商品数量+1')
      }else{
        /**购物车没有该商品，count属性直接在这里定义，payload数量=1，且push到购物车*/
        payload.count = 1
        context.commit('addCart', payload)  //分发: 调用mutation内的addCart事件
        resolve('商品成功添加到购物车')
       }
      })
    }
  }
})
```



#### action

Action 类似于 mutation，不同在于：

- Action 提交的是 mutation，而不是直接变更状态。
- Action 可以包含任意异步操作。

Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 `context.commit` 提交一个 mutation，或者通过 `context.state` 和 `context.getters` 来获取 state 和 getters。

```js
const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment (context) {
      context.commit('increment')
    }
  }
})

actions: {
    //参数解构  解构context对象
    // context对象全部属性{commit, dispatch, state, getters, rootState, rootGetters}
  increment ({ commit }) {
    commit('increment')
  }
}

//actions分发
store.dispatch('incrementAsync', {
  amount: 10
})

//购物车示例，涉及到调用异步 API 和分发多重 mutation
actions: {
           //把入参context 参数解构
  checkout ({ commit, state }, products) {
    // 把当前购物车的物品备份起来
    const savedCartItems = [...state.cart.added]
    // 发出结账请求，然后乐观地清空购物车
    commit(types.CHECKOUT_REQUEST)
    // 购物 API 接受一个成功回调和一个失败回调
    shop.buyProducts(
      products,
      // 成功操作
      () => commit(types.CHECKOUT_SUCCESS),
      // 失败操作
      () => commit(types.CHECKOUT_FAILURE, savedCartItems)
    )
  }
}

```

组合action

```js
//通过包一层promise处理actionA异步操作返回的promise对象
actions: {
  actionA ({ commit }) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        commit('someMutation')
        resolve()
      }, 1000)
    })
  }
}

//外部调用
store.dispatch('actionA').then(() => {
  // ...
})

//另一个action
actions: {
  // ...
  actionB ({ dispatch, commit }) {
    return dispatch('actionA').then(() => {
      commit('someOtherMutation')
    })
  }
}

//利用 async / await (opens new window)，我们可以如下组合 action
//假设 getData() 和 getOtherData() 返回的是 Promise
actions: {
  async actionA ({ commit }) {
    commit('gotData', await getData())
  },
  async actionB ({ dispatch, commit }) {
    await dispatch('actionA') // 等待 actionA 完成
    commit('gotOtherData', await getOtherData())
  }
}
//一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。
```



#### mapActions   

**mapActions映射到methods**

使用 `mapActions` 辅助函数将组件的 methods 映射为 `store.dispatch` 调用

```js
import { mapActions } from 'vuex'

export default {
  // ...
  methods: {
    ...mapActions([
      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`

      // `mapActions` 也支持载荷：
      // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`
      'incrementBy' 
    ]),
    ...mapActions({
      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`
    })
  }
}
```

#### modules

Vuex 允许我们将 store 分割成**模块（module）**。每个模块拥有自己的 state、mutation、action、getter

```js
const moduleA = {
    //注意模块内的state通过函数返回，和data一样
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})

store.state.a // -> moduleA 的状态
store.state.b // -> moduleB 的状态
```

#### 命名空间

默认情况下，模块内部的 action、mutation 和 getter 是注册在**全局命名空间**的——这样使得多个模块能够对同一 mutation 或 action 作出响应。

如果希望你的模块具有更高的封装度和复用性，你可以通过添加 `namespaced: true` 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：

```js
const store = new Vuex.Store({
  modules: {
    account: {
      namespaced: true,

      // 模块内容（module assets）
      state: () => ({ ... }), // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响
      getters: {
        isAdmin () { ... } // -> getters['account/isAdmin']
      },
      actions: {
        login () { ... } // -> dispatch('account/login')
      },
      mutations: {
        login () { ... } // -> commit('account/login')
      },

      // 嵌套模块
      modules: {
        // 继承父模块的命名空间
        myPage: {
          state: () => ({ ... }),
          getters: {
            profile () { ... } // -> getters['account/profile']
          }
        },

        // 进一步嵌套命名空间
        posts: {
          namespaced: true,

          state: () => ({ ... }),
          getters: {
            popular () { ... } // -> getters['account/posts/popular']
          }
        }
      }
    }
  }
})
```



### promise重要测试

```js
function test(){
	return new Promise((resolve,reject) => {
        resolve('333')
    })
}
test() // Promise {<fulfilled>: "333"}
	   //[[PromiseState]]: "fulfilled"
       //[[PromiseResult]]: "333"
await test()  // "333"

test().then(res => {   
    return '888'     //Promise {<fulfilled>: "888"}
})

```





### async/await

**注意：await后面如果不是一个promise对象，会按同步任务执行**

async 是一个修饰符，async 定义的函数会**默认的返回一个Promise对象resolve的值**，因此对async函数可以直接进行then操作,返回的值即为then接收的参数

如果 async 函数没有返回值，又怎么样呢？很容易想到，它会返回 Promise.resolve(undefined)。

联想一下 Promise 的特点无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。

```js
async function fun0() {
    console.log(1)
    return 1
}
fun0().then( x => { console.log(x) })  //  输出结果 1， 1

async function funp() {
    console.log('Promise')
    return new Promise(function(resolve, reject){
        resolve('Promise')
    })
}

funp().then( x => { console.log(x) })   // 输出promise  promise
```

await 也是一个修饰符，

await 关键字 只能放在 async 函数内部， **await关键字的作用 就是获取 Promise中返回的内容**， **获取的是Promise函数中resolve值**

**注意：**

**1.await无法直接获取reject值，必须通过.catch方法捕获err后才能获取到（从源码看本质也是resolve）**

**2.await后面的表达式如果没有返回值，会阻塞代码执行**

// 如果await 后面并不是一个Promise的返回值，则会**按照同步程序返回值处理**

```js
// 如果await 后面并不是一个Promise的返回值，则会按照同步程序返回值处理
const bbb = function(){ return 'string'}

async function funAsy() {
   const a = await 1
   const b = await new Promise((resolve, reject)=>{
        setTimeout(function(){
           resolve('time')
        }, 3000)
   })
   const c = await bbb()
   console.log(a, b, c)
}

funAsy()  //  运行结果是 3秒钟之后 ，输出 1， time , string
```



#### async/await全局执行顺序

```js
//若全局有多个要执行，函数体内await会让出线程，给函数体外执行,进行循环
async function async1() {
        //1
        console.log('start')
    	//2
        await async2()
    	//5 最后执行
        console.log('end')
    }
async function async2() {
    console.log('async2 start')
    console.log('async2 end')
}

async1()
//3,4执行
console.log('script start')
console.log('start') 

//执行顺序
start
async2 start //执行函数体内await
async2 end  //执行函数体内await 

script start //执行函数体外
start   	//执行函数体外
end     	//最后执行函数体内


//例2
async function async1() {
    // 2
    console.log("async1 start");
    await async2();
    // 6
    console.log("async1 end");
}
async function async2() {
    // 3
    console.log("async2");
}
// 1
console.log("script start");

setTimeout(function () {
  console.log("setTimeout");
}, 0);

async1();

new Promise(function (resolve) {
    // 4
    console.log("promise1");
    resolve();
}).then(function () {
    // 7
    console.log("promise2");
});
// 5
console.log("script end"); 

//执行顺序
script start
async1 start
async2
promise1
script end
async1 end
promise2
undefined
setTimeout
```

#### await函数体内.then顺序测试

```js
//测试1
function test1(){
	return new Promise(resolve=>{
        setTimeout(()=>resolve('我是then的数据'),1000)
    })	
}
async function test2(){
    console.log('第一条测试') //1
    await test1().then(res => console.log(res)) //2 
    console.log('第二条测试') //3
}
test2()

//测试2 跟上面执行顺序一样
function test1(){
	return new Promise(resolve=>{
        setTimeout(()=>resolve('我是then的数据'),1000)
    })	
}
async function test2(){
    console.log('第一条测试') //1
    const xx = await test1()   
    console.log(xx)  //2
    console.log('第二条测试') //3
}
test2()

//测试3 多个异步请求在同一函数内的执行顺序
function test1(){
	return new Promise(resolve=>{
        setTimeout(()=>resolve('我是test1的异步数据'),1000)
    })	
}
function test3(){
    return new Promise(resolve=> {
        setTimeout(()=>resolve('我是test3的异步数据'),500)
    })
}
// 结论: 1.加了await 所有代码按顺序执行 
//      2.异步请求不加await，会先执行同步最后执行异步
async function test2(){
    console.log('第一条测试') 
    await test1().then(res => console.log(res)) 
    console.log('第二条测试') 
    await test3().then(res => console.log(res))
    console.log('第三条测试') 
}
test2()


//测试4 不加setTimeout
function test1(){
	return new Promise(resolve=>{
        resolve('test1数据')
    })	
}
function test3(){
    return new Promise(resolve=> {
        resolve('test3数据')
    })
}
// 结论: 1.加了await 所有代码按顺序执行 
//      2.异步请求不加await，会先执行同步，最后执行异步的test1和test3
async function test2(){
    console.log('第一条测试') 
    test1().then(res => console.log(res)) 
    console.log('第二条测试') 
    test3().then(res => console.log(res))
    console.log('第三条测试') 
}
test2()
```



### vue render渲染函数

```js
new Vue({
    el: '#app',
    render: function(h){   //使用render函数 
        return h(App)
    }
    // h实际是createElement这个函数简写,其实等于下面:
    render: function(createElement){
        //用法1：createElement('标签',{标签的属性},['标签的内容'])
        //创建一个<h2>标签，替换了app挂载的内容
        return createElement('h2',{class: 'box'},['hello world'])   
       
        //用法2：传入一个组件对象
        render:function(createElement){
            return createElement(cpn)  //传入一个组件
        }
    }
})

```



高效地更新所有这些节点会是比较困难的，不过所幸你不必手动完成这个工作。你只需要告诉 Vue 你希望页面上的 HTML 是什么，这可以是在一个模板里：

```vue
<h1>{{ blogTitle }}</h1>
```

或者一个渲染函数里：

```js
render: function (createElement) {
  return createElement('h1', this.blogTitle)
}
```

```vue
//重要例子！使用render函数创建组件
<blog-post>
  <template v-slot:header>
    <h1>About Me</h1>
  </template>

  <p>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.</p>

  <template v-slot:footer>
    <p>Copyright 2016 Evan You</p>
  </template>

  <p>If I have some content down here, it will also be included in vm.$slots.default.</p>.
</blog-post>

<scrpit>
Vue.component('blog-post', {
  render: function (createElement) {
    var header = this.$slots.header
    var body   = this.$slots.default
    var footer = this.$slots.footer
    return createElement('div', [
      createElement('header', header),
      createElement('main', body),
      createElement('footer', footer)
    ])
  }
})
</scrpit>
```

#### JSX实例

```vue
//要渲染的模板
<anchored-heading :level="1">
  <span>Hello</span> world!
</anchored-heading>

//render标准写法 (函数声明式)
createElement(
  'anchored-heading', {
    props: {
      level: 1
    }
  }, [
    createElement('span', 'Hello'),
    ' world!'
  ]
)


//要渲染的模板
<anchored-heading :level="1">
  <span>Hello</span> world!
</anchored-heading>


//jsx映射写法
import AnchoredHeading from './AnchoredHeading.vue'
new Vue({
  el: '#demo',
  // h就是createElement简写
  render: function (h) {
    return (
      <AnchoredHeading level={1}>
        <span>Hello</span> world!
      </AnchoredHeading>
    )
  }
})
```

#### RenderDom组件封装

```vue
<script lang="tsx">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'RenderDom',
  props: {
    data: {
      type: Object,
      default: () => {}
    },
    render: {
      type: Function,
      default: () => {}
    }
  },
  render () {
    return this.render(this.data)
  }
})
</script>
```

#### render函数应用$slots实例

父组件对子组件传入插槽

```js
//子组件helloWorld.vue 
import {h} from 'vue'
export default {
    render(){
        return h('div', null, [
            h('h2', null, 'helloworld'),
            // 在这里接收父组件传过来的插槽，用三元运算符判断,同时可以进行Props作用域插槽传参 
            this.$slots.default ? this.$slots.default({name: 'david'}) : h('span', null, '我是插槽默认值')
        ])
    }
}

// 父组件app.vue 对子组件使用插槽
import helloWorld from './helloWorld.vue'
import {h} from 'vue'
export default {
    render(){
        // 穿插槽 第3个参数是一个对象(1个插槽)或数组(多个插槽)
        return h(helloWorld, null, {
            // default即默认插槽，对应的是一个函数, 接收一个props参数，其实就是作用域插槽的传参
            // 返回值就是要插入的内容，一个vnode
            default: (props) => h('span', null, `${props.name}我是父组件内容`)
        })
    }
}
```

#### JSX应用$slots实例

```jsx
//子组件helloWorld.vue
export default {
    data(){
        return {
            counter: 0
        }
    }
    render(){
        const increment = () => this.counter++
        const decrement = () => this.counter--
        return (
        	<div>
            	<h2>当前计数: {this.counter}</h2>
                <button onClick={increment}>+1</button>
                <button onClick={decrement}>-1</button>
                {this.$slots.default ? this.$slots.default() : <span>我是默认值</span>}
            </div>
        )
    }
}

// 父组件app.vue
import helloWorld from './helloWorld.vue'
export default {
    render() {
        return (
            <helloWorld>
                <!--这个双括号外层是jsx语法{}，内层是要传的对象{} 并不是mastach语法-->
                {{default: props => <span>我是父组件插入的</span>}}
            </helloWorld>
        )
    }
}
```



#### JSX在组件内绑定自定义事件

```js
//自定义组件内触发自定义事件
context.emit('search')
//父级内接收用
onSearch={ fetchData }
//props有错误提示
on-search={ fetchData } 
//可用写法
{ ...{  onSearch: fetchData } }
```





### 跨域pathRewrite原理

```js
//不配置pathRewrite 请求就被转发到 http://XX.XX.XX.XX:8083 并把相应uri带上。比如：localhost:8080/api/xxx 会被转发到http://XX.XX.XX.XX:8083/api/xxx
dev: {
    // Paths
    assetsSubDirectory: 'static',
    assetsPublicPath: '/',
    proxyTable: { // 代理从指定的target后面开始匹配
      '/api': {   // 访问/api === target + '/api'
        target: 'http://XX.XX.XX.XX:8083', 
        changeOrigin: true,
        pathRewrite: {
          '^/api': '/api'   // 这种接口配置出来  http://XX.XX.XX.XX:8083/api/login
          '^/api': '/'      // 这种接口配置出来  http://XX.XX.XX.XX:8083/login
        }
      }
    }
  }
```



### isNaN用法

isNaN() 函数用于检查其参数是否是非数字值。

如果参数值为 NaN 或字符串、对象、undefined等非数字值则返回 true, 否则返回 false。



### ??用法

```js
let message: string|null = null
const content = message ?? '我是默认值'
//等价于条件运算符
const content = message ? message : '我是默认值'
```



### vue全局注册过滤器filters

```js
//过滤器文件 common.js
/* 格式化：钱/分转元 */
let formatMoneyOfF2Y = value => {
  if (isNaN(value)) {
    return value
  }
  return value / 100
}

/* 格式化：保留几位小数 */
let formatFixed = (value, num) => {
  if (isNaN(value)) {
    return value
  }
  return Number(value).toFixed(num)
}

/* 格式化：日期 */
let formatDate = (value, pattern) => {
  if (isEmpty(value)) {
    return value
  }
  return moment(value).format(pattern)
}

export {
	formatMoneyOfF2Y,
    formatFixed,
    formatDate
}


//主文件 main.js
import * as filters from './filters/common.js'

Object.keys(filters).forEach(key => {
  Vue.filter(key, filters[key])
})
```

### vue-cli 3.0配置环境

1.根目录创建环境配置文件

.env.production

.env.development

```js
// .env.production
NODE_ENV: 'production',
VUE_APP_TITLE: 'production'

// .env.development
NODE_ENV: 'development',
VUE_APP_TITLE: 'development'
```

2.创建index.js 导出用

```js
const modeUrlObj = {
    //正式环境
    'production': {
        baseURL: 'xxxx',
        upLoadBaseURL: 'xxx',
    },
    // 本地环境
    'development': {
        baseURL: 'xxxx',
        upLoadBaseURL: 'xxx'
    },
    // 测试环境
    'test': {
        baseURL: 'xxxx',
        upLoadBaseURL: 'xxx'
    }
}
export default modeUrlObj[process.env.VUE_APP_TITLE] //根据环境动态导出其中的变量
```

3.package.json配置文件 添加命令 --mode development || production

```json
"scripts": {
    "dev": "vue-cli-service serve --mode development",
    "build": "vue-cli-service build --mode production"
  }
```

4.使用

```js
import config from './index.js'
import axios from 'axios'
const instance = axios.create({
    baseURL: config.baseURL
})
```



### router相关概念

#### component/components区别

```vue
<script>
 const routes = [
    {
        path: '/recharge/index',
        // 一个路由若有多个组件使用components
        components:{
            // 键名就是组件的名字recharge, router-view name传参使用也是这个值
            recharge: () => import('@/views/pay/recharge/Index')
        }
    },
     {
         path: 'recharge/order',
         // 一个路由对应一个组件使用component 该组件没有名字
         component: () => import('@/views/pay/recharge/order')
     }
]
</script>

<template>
	<!--渲染recharge组件-->
	<router-view name="recharge"></router-view>
</template>


```

#### vue-router中name属性作用

1.不同页面下渲染的内容根据components所对应的组件进行渲染，和name无关

2.name相当于给path起了一个别名

3.当要用params传参时，要配置name属性

```vue
// router.js
const routes = [
	{	
		name: 'abc', // 和router-link的name， $router.push传参中的name对应
		path: '/xxx/index/:fav/:age',
		components: { home: home} // components可配置多个组件，用于同路由下显示多个组件
	}
]
// router-link的name绑定路由配置中的name 将跳转到 /xxx/index/zzz/333
<router-link :to={name: 'abc', params:{fav: 'zzz', age: 33}}>跳转页面</router-link>
// router-view的name绑定components中的home组件
<router-view name="home"></router-view>

// 编程式跳转
this.$router.push({
	name:'abc',
	params: {fav: 'zzz', age: 33}
})
```



<router-link :to={name: 'xx', params: {id: '123'}}> 链接 </router-link>

4.获取组件的name值 $route.name

**router-view的name 和 vue-router的name无关，是2个概念**

#### router-view

单页面中有多个router-view时，必须绑定name属性，否则无法正常渲染



#### route可配置属性

```js
const routes = [
    {
        path: '/home',
        name: 'home', //路由名，可根据路由名进行跳转
        component: () => import('../views/home.vue'),
        meta: { //元数据，也叫自定义数据 可在路由对象$route.meta 或 导航守卫内取到，
        	name: 'david',
            age: 33
    }
    }
]
```

#### import懒加载

其实就是在build时对文件进行分包，懒加载的文件会打包成chunk.xxx.js

```js
// import是webpack的方法，返回一个promise对象 可使用语法:import('./xxx').then()
const routes = [
    										// magic comment魔法注释 给分包自定义名
    {path: '/home', component: () => import(/* webpackChunkName: "home-chunk "*/'../views/home.vue')}
]
```



#### 动态路径匹配

```js
const User = {
  template: '<div>User {{ $route.params.id }}</div>'
}


const router = new VueRouter({
  routes: [
    // 动态路径参数 以冒号开头
    { path: '/user/:id', component: User }
  ]
})


```

```vue
<!--使用动态路径匹配-->
<router-link :to="/user/ + 'id'"></router-link>
<!--to也可以绑定对象 使用name属性时 对应route必须要配置name属性-->
<router-link :to="{name: 'home', params: {name: 'david'}}"></router-link>
<router-link :to="{path: '/home', query:{name: 'david'}}"></router-link>
```

#### 不存在路径的默认页匹配

```js
{  //当没有匹配到对应的路由时，默认显示该页面
    path: '/:pathMatch(.*)',
    component: () => import('../views/notFound.vue')
}
```

#### 子路由children

```js
{
    path: 'home',
    component: () => import('../views/home.vue'),
   	children: [ // home页配置子路由
        {path: 'children1', component: import('../views/children1.vue')},
        {path: 'children2', component: import('../views/children2.vue')},
    ]
}
// home页记得配置<router-view/>占位符显示子路由
```

#### 路由传参、取参

```js
// 编程式导航 通过query传参
this.$router.push({
    path: '/home',
    query: { // 查询字符串传参: /home?name=david 
        name: 'david'
    }
})
// 通过params传参
this.$router.push({
    name: 'home', //route须配置name
    params: {  // 动态路径传参: /home/david
        name: 'david',
    }
})
// 取参
{{$route.query.name}}
```

#### router-link的作用域插槽

```vue
<!--1.href: 跳转的链接 2.route对象 3.navigate跳转函数 -->
<!--custom表示自定义样式，取消router-link默认的a标签样式-->
<router-link to="/home" v-slot="props" custom>
    <!--router-link默认插槽-->
	<button @click="props.navigate">{{props.href}}</button>
</router-link>
```

#### 动态组件component+动画效果

```vue
<router-view v-slot="props">
    <!--动画组件包裹 实现组件切换的动画效果-->
	<transition name="anime">
        <!--作用域插槽会传过来一个component，表示当前组件-->
    	<component :is="props.component"></component>
    </transition>
</router-view>

<style>
	.anime-enter-from,
    .anime-leave-to{
        opacity: 0;
    }
    .anime-enter-from,
    .anime-leave-to{
        opacity: 1;
    }
    .anime-enter-active,
    .anime-leave-active{
        trasition: opacity 1s ease;
    }
</style>
```

#### 添加动态路由核心方法addRoute

```js
const categoryRoute = {
    path: '/category',
    component: () => import('../views/category.vue')
}
const router = createRouter({
    routes,
    history: createWebHistory()
})
// 添加顶层路由
router.addRoute(categoryRoute)
// 添加二级路由
router.addRoute('home', categoryRoute)
```

#### 导航守卫

导航守卫函数很多，最常用的是前置守卫beforeEach, 其他方法使用上都是雷同的

```js
/**
 router4.0开始不推荐使用第3个参数next, 通过函数返回值控制跳转
 返回值:
 1. return false不导航 
 2. 返回undefined或者无返回值，默认导航
 3. 返回字符串， 跳转到相应路径
 4. 对象：{path: '/login', query:{...}}
*/
router.beforeEach((to, from)=> {
    if(to.path !== '/login'){
        let token = localStorage.getItem('token')
        if(!token){
            return '/login'
        }
    }
})
```



#### 善语-动态路由（难点）

```js
 // store层/user模块  定义创建动态路由的方法generateRoutes
actions: {
    generateRoutes: function(context, str) {
      return new Promise((resolve, reject) => {
        const menu = [];
        /*判断本地缓存是否有菜单数据*/
        let rolelist = getSessionStorage('rolelist');
        let routerlist = null;
        if (rolelist) {
          /*本地缓存有数据，直接获取缓存里的数据*/
          let auth = getSessionStorage('authlist');
          if (!auth) {
            let authlist = {}
            // 创建路由路径表的方法
            createdAuth(auth, authlist);
            setSessionStorage('authlist', authlist);
          }
          let list = cearedRoute(rolelist);
          routerlist = menu.concat(list, errpage);
          context.commit("setState", {
            key: 'roles',
            val: rolelist
          });
          resolve(routerlist);
        } else {
          /*本地缓存没有数据，去掉菜单接口*/
          getRolelist().then(res => {
              // 核心方法 创建路由组件
              let list = cearedRoute(res);
              routerlist = menu.concat(list, errpage);
              setSessionStorage('rolelist', res);
              let authlist = {}
              createdAuth(res, authlist);
              setSessionStorage('authlist', authlist);
              context.commit("setState", {
                key: 'roles',
                val: rolelist
              });
              resolve(routerlist);
            })
            .catch(error => {
              reject(error);
            });
        }
      })
    }

  }

import Main from '@/views/layout/main'


/*把数据列表生成vue路由*/
function cearedRoute(list, flag) {
  let routelist = [];
  for (let i = 0; i < list.length; i++) {
    let item = list[i];
    if (item.is_route == 1) {
      // 构造路由组件
      let obj = {
        path: item.path,
        meta: {
          title: item.name
        },
        name: createAlias(item.path),
        component: item.parent_id===0? Main:loadView(item.path)
      }
      /*判断是否重定向*/
      if(item.redirect_name&&typeof(item.redirect_name)!='undefined'&&item.redirect_name!=''){
        obj['redirect']=item.redirect_name;
      }
      /*判断子路径是否是数组*/
      if (Object.prototype.toString.call(item.children) == '[object Array]' && item.children.length > 0) {
        let num = null;
        if (flag != null) {
          num = flag;
          num++;
        } else {
          num = 0;
        }
        let child = cearedRoute(item.children, num);
        if (num >= 1) {
          let temp = routelist.concat(child);
          routelist = temp;
        } else {
          obj.children = child;
        }
      }
      routelist.unshift(obj);
    }else if(item.is_route == 2){
      let obj = {
        path: item.path,
        meta: {
          title: item.name
        },
        name: createAlias(item.path),
        component: loadView(item.path)
      }
       routelist.unshift(obj);
    }
  }
  return routelist;
}

/*生成别名*/
function createAlias(str){
   return str.replace(/\//g,'_');
}

/*引入对应的组件文件*/
function loadView(view)
{
  /*将后台传过来的组件地址改成小写*/
  view=view.toLowerCase();
  /*判断第一个是不是斜杠，如果不是加上斜杠*/
  if(view.substr(0,1)!='/'){
    view+='/'+view;
  }
  /*路由懒加载，如果报错需要下载 syntax-dynamic-import 本系统使用了Babel*/
  return () => import(`@/views${view}`);
}

export {
  cearedRoute
}


// permission.js 调用加载动态路由的方法 在main.js内引入该方法
router.beforeEach(async (to, from, next) => {
  const isLogin = getCookie('isLogin');
  if (to.meta.title) {
    let title='';
    let shop_name=getCookie('shop_name');
    if(shop_name&&typeof(shop_name)!='undefined'){
      document.title = to.meta.title + '-'+shop_name;
    }else{
      document.title = to.meta.title + '-商城管理系统';
    }
  }
   //判断是否登录
  if (isLogin) {
    NProgress.start();
    let hasRoles = store.state.user.roles && store.state.user.roles.length > 0;
    if (hasRoles) {
      next();
      NProgress.done();
    } else {
      try {
        //参数暂时无效
        const roles = Math.random();
        const accessRoutes = await store.dispatch('user/generateRoutes', roles);
        resetRouter();
        router.addRoutes(accessRoutes);
        next({ ...to,
          replace: true
        });
      } catch (error) {
        next('/login');
      }
      NProgress.done();
    }
  } else {
    if (whiteList.indexOf(to.path.toLowerCase()) !== -1) {
      next();
      NProgress.done();
    } else {
      next('/login');
    }
  }
})
```



### img标签引入静态图片资源时要使用require方法

```vue
<div class="wrapper-item" v-for="(item,index) in wrappers" :key="index">
    <img :src="item.img" alt="" style="width: 292px; height: 480px;">
</div>

wrappers: [
        { img: require('../assets/p1.png') },
        { img: require('../assets/p2.png') },
        { img: require('../assets/p3.png') },
        { img: require('../assets/p4.png') }
      ]
    }
```



### elementui自定义样式

1.修改组件样式不影响全局

```css
//使用 >>> 进行样式穿透
.grid-content >>> .el-dialog {
  width: 1092px;
  height: 638px;
}
.grid-content >>> .el-dialog__body {
  padding: 0;
}
.grid-content >>> .el-dialog__header {
  padding: 0;
}
```

2.配置全局样式

```css
.el-pagination span {
  color: #656565;
  width: 50px;
  border: 1px solid #EAEAEA;
  height: 34px;
  line-height: 34px;
  box-sizing: border-box;
 }
.el-pagination.is-background .btn-next, .el-pagination.is-background .btn-prev, .el-pagination.is-background .el-pager li {
  margin: 0 5px;
  background-color: #fff;
  /* color: #606266; */
  border: 1px solid #ccc;
  color: #999;
  border-radius: 4px;
  min-width: 40px;
  height: 40px;
  line-height: 40px;
  font-size: 24px;
  /* border-radius: 2px; */
}
.el-pagination.is-background .el-pager li:not(.disabled).active {
  background-color: #f68b1f;;
  color: #FFF;
}
```



### 函数内的函数需要return才能拿到返回值

```js
// 对david()函数来说，他需要有一个return才能有返回值
function david(val){
    if(val == 1){
    //关键!!对执行函数加了return 才能在外部函数执行时拿到返回值
    return t1() 
}else{
    //关键!!对执行函数加了return 才能在外部函数执行时拿到返回值
    return t2()
	}
}

function t1(){
    console.log('t1哈哈哈')
    return true
}

function t2(){
    console.log('t2嘿嘿嘿')
    return false
}
//外部函数执行
david(1) //true 能拿到内部函数的返回值
```





### Mock用法

mock get方法传参: 1.接口，2.请求方法，3.响应数据

请求方法是get时，可以省略

**Mock.mock( rurl, rtype, template )**

```js
//1. 正常get请求
get() {
  axios.get('/user/login')
    .then(res => console.log(res))
    .catch(err => console.log(err))
}
//对应mock
import Mock from 'mockjs'

// get  默认请求方法为get，第二个参数可不写  Mock.mock( rurl, rtype, template )
Mock.mock('/user/login','get', {
  "status": 200,
  "data": {
    "id|1-9999": 0,
    "username": "@cname",
    "age|1-100": 0,
    "email": "@email",
  }
})


//2. 携带params的get请求
get() {
  axios.get('/user/login', {
    params: {
      id: 1
    }
  }
  )
    .then(res => console.log(res))
    .catch(err => console.log(err))
}

// get + params  例如 /user/login?id=1  用正则过滤掉
Mock.mock(RegExp("/user/login" + ".*"), 'get', {
  "status": 200,
  "data": {
    "id|1-9999": 0,
    "username": "@cname",
    "age|1-100": 0,
    "email": "@email",
  }
})


//3. post请求
post() {
  axios.post('/products/params', {
    id: 0,
    price: 4399
  })
    .then(res => console.log('res响应成功',res))
    .catch(err => console.log(err))
}
// post-mock
// options是mock接收到的post参数
Mock.mock('/products/params', 'post', function (options) {
  console.log('mock接收到到参数为：', options)
  if (options.body === '{"id":0,"price":4399}') {
    return {
      status: 200,
      products: 'iphone4S'
    }
  }
})


// 4.post 增加数据操作
axios.post('/params/list', {
    product: 'iphone5',
    id: 4
  })
    .then(res => console.log(res))
    .catch(err => console.log(err))

// mock 增加数据
const paramsList = [
  { product: 'iphone3G', id: 1 },
  { product: 'iphone4', id: 2 },
  { product: 'iphone4S', id: 3 },
]

Mock.mock('/params/list', 'post', options => {
  let body = JSON.parse(options.body) // 获取请求参数
  let id = parseInt(body.id)
  let flag = true

  for (let item of paramsList) {
    if (item.id === id) flag = false // 判断id是否已经存在
  }
  // 如果id不存在
  if (flag) {
    paramsList.push(
      {
        product: body.product,
        id
      }
    )
    return {
      paramsList,
      status: 200,
      msg: '添加成功'
    }
  }
  // 如果id已存在
  return {
    status: 400,
    msg: '添加失败，id已存在'
  }
})
```



电网项目mock配置

```js
// 两个mock模拟接口数据
// 1. mock/project/addProject.js
export default {
  url: '/dndcm-project/dndcm-project/project/createProject',
  method: 'post',
  response: {
    success: true,
    code: '99990000',
    message: '操作成功',
    data: true
  }
}
// 2. mock/project/detailProject.js
export default {
  url: '/dndcm-project/dndcm-project/projectCategory/queryDetail',
  method: 'post',
  response: {
    success: true,
    code: '99990000',
    message: '操作成功',
    data: {
      categoryInstruction: '123123',
      categoryName: 'qui sed sit',
      chargeLeader: -20294645,
      createId: -8717333,
      deployId: -15048698,
      id: 44047940,
      parentId: 1,
      showYn: 1,
      status: 1,
      updateId: -5032834
    }
  }
}

// 统一导出:mock/project/index.js
import addProject from './addProject'
import treeProjectCategory from './treeProjectCategory'
import detailProjectCategory from './detailProjectCategory'

export default [
  addProject,
  treeProjectCategory,
  detailProjectCategory,
]


// mock主文件：mock/index.js
import Mock from 'mockjs'
import MockCommon from './common'
import MockProject from './project'
import MockStream from './stream'

// 解构所有导入的数组，即模拟数据
const mockArray = [
  ...MockCommon,
  ...MockProject,
  ...MockStream
]

if (JSON.parse(process.env.VUE_APP_OPEN_MOCK)) {
  for (const mockItem of mockArray) {
    Mock.mock(process.env.VUE_APP_BASE_URL + mockItem.url, mockItem.method, mockItem.response)
  }
}

```



### ''展开收起''按钮小技巧

```vue
<!--stretchNum=3 始终渲染前3条数据，当index>3时，根据点击展开按钮，取反collapse状态是否渲染更多-->
v-show="index < config.stretchNum || collapse"
```



### scss 相关

####  &符号意义()

本质就是父元素的占位符

```scss
//不使用&占位符，编译后的问题
.text a {
  color: blue;
  :hover { color: red }
}

//编译成css后 
.text a {
  color: blue;
}
// 注意:hover前产生了空格, 变成了所有a后代的hover效果
.text a :hover {
  color: red;
}
```

这个时候就可以使用&父选择器标识符，它的作用就相当于一个父选择器的占位符。可以实现class为text的所有后代a标签的元素，当鼠标悬浮时，字体颜色都会变为红色。

```scss
.text a {
  color: blue;
  &:hover { color: red }
}

//上面的代码编译的时候，会将&替换为父选择器a，编译后的css代码如下:
.text a {
  color: blue;
}
.text a:hover { //变成想要的效果 a:hover
  color: red;
}
```



```scss
//&父选择器标识符并不仅仅用于链接伪类选择器，看如下scss代码实例:
//&会替换成嵌套外层的父选择器
#content aside {
  color: red;
  body.ie & { color: green }
}
//编译为css代码如下:
#content aside {color: red};
body.ie #content aside { color: green }


//&会层层传递出去
#main {
  color: black;
  a {
    font-weight: bold;
    &:hover { color: red; }
  }
}

//编译为
#main {
  color: black; }
  #main a {
    font-weight: bold; }
	//&会层层传递出去
    #main a:hover {
      color: red; }
```

　　

```scss
//& 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如
#main {
  color: black;
  &-sidebar { border: 1px solid; }
}
//编译为css
#main {
  color: black; 
}
#main-sidebar {
    border: 1px solid; 
}

//& 用在嵌套的scss代码里，来引用父元素
.dashboard {
  &-container {
    margin: 30px;
  }
  &-text {
    font-size: 30px;
    line-height: 46px;
  }
}
//编译为css 原本在scss的嵌套结构被展平了
.dashboard-container {
  margin: 30px; }
.dashboard-text {
  font-size: 30px;
  line-height: 46px; }


```



#### @mixin/@include 

```scss
//定义一个名为important-text混入
@mixin important-text {
  color: red;
  font-size: 25px;
  font-weight: bold;
  border: 1px solid blue;
}

//使用混入
.danger {
  @include important-text;
  background-color: green;
}

//混入中也可包含混入
@mixin special-text {
  @include important-text;
  @include link;
  @include special-border;
}

//混入传递变量
/* 混入接收两个参数 */
@mixin bordered($color, $width) {
  border: $width solid $color;
}

.myArticle {
  @include bordered(blue, 1px);  // 调用混入，并传递两个参数
}

.myNotes {
  @include bordered(red, 2px); // 调用混入，并传递两个参数
}
```



### 统一导出(模块导出规范)

相关功能模块文件夹内新建一个Index.js文件 用于统一导出的出口

```js
/*	
目录结构: 
api/
	api.common.js
	api.project.js
	api.stream.js
	index.js
*/
// index.js 统一出口文件 导入所有相关模块接口，并导出
export { default as ApiCommon } from './api.common' 
export { default as ApiProject } from './api.project' 
export { default as ApiStream } from './api.stream' 

// 要使用的地方 路径直接写/api即可， 无需写成/api/api.common
import { ApiCommon } from '@/api'
```



### $emit(update:xxx)子组件通知父组件更新写法

子组件通知父组件更新

普通写法:

```vue
<!--父组件-->
<!--父组件需要传一个绑定值（message）同时需要设置一个更新触发函数（func）给子组件修改绑定值的时候调用-->。
<parent :message="bar" @update:message="func">

<!--js定义函数-->
func(val){
    this.bar = val
 }
<!--子组件触发更新-->
func2(){
    this.$emit('update:message',valc)
}
```

.sync简化写法，父组件不需要定义更新触发函数

```vue
<!--父组件-->
<comp :message.sync="bar"></comp>

<!--子组件-->
this.$emit('update:message',valc)
```



### 工具类

把传入的对象转化成字符串形式

```js
const json2url = (obj: any) => {
  let result: any[] = []
  for (let key in obj) {
    if (!isN(obj[key])) {
      result.push(key + '=' + encodeURI(obj[key]))
    }
  }
  return (result.length ? '?' : '') + result.join('&') // ?name=david&age=19 这种字符串
}
```

### 不定参数(...args)

**三个点(...)在es6中，有两个含义:**

- 用在形参中， 表示传递给他的参数集合， 类似于arguments, 叫不定参数. 语法格式:  在形参面前加三个点( ... )
- 用在数组前面，可以把数组的值全部打散，展开，叫展开运算符. 语法格式:  在数组面前加三个点( ... )

```js
// ...values取代了以前arguments的作用
function add(...values){
    console.log(values) //[10,20,30]
    let sum = 0
    for(let i=0,len=values.length; i<len; i++){
        sum += values[i]
    }
    return sum
}

var res = add(10,20,30) // 60
```



### axios拦截对象和响应对象实例

```js
// 请求拦截对象config
config = {
    adapter: ƒ xhrAdapter(config)
    arguments: [Exception: TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them at Function.r (<anonymous>:1:83)]
    caller: [Exception: TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them at Function.r (<anonymous>:1:83)]
    length: 1
    name: "xhrAdapter"
    prototype:
    constructor: ƒ xhrAdapter(config)
    [[Prototype]]: Object
    [[FunctionLocation]]: xhr.js:12
    [[Prototype]]: ƒ ()
    [[Scopes]]: Scopes[3]
    baseURL: "/api"
    data: "{}"
    headers:
    Accept: "application/json, text/plain, */*"
    Content-Type: "application/json;charset=utf-8"
    accessToken: "d5de8c51f5d342af0dde453effd41442054994cf43bd63ca5ec5b2a7987604f5"
    [[Prototype]]: Object
    maxBodyLength: -1
    maxContentLength: -1
    method: "post"
    timeout: 0
    transformRequest: [ƒ]
    transformResponse: [ƒ]
    url: "/user/area/tree"
    validateStatus: ƒ validateStatus(status)
    xsrfCookieName: "XSRF-TOKEN"
    xsrfHeaderName: "X-XSRF-TOKEN"
}


// 响应对象response 其中的config属性就是请求的config对象
// 常用属性config, data, status
response = {
	config: {
        url: '/user/area/tree', 
        method: 'post', 
        data: '{}', 
        headers: {
            Accept: "application/json, text/plain, */*"
			Content-Type: "application/json;charset=utf-8"
			accessToken: "d5de8c51f5d342af0dde453effd41442054994cf43bd63ca5
        }, 
        baseURL: '/api', 
        url: "/user/area/tree"
    },
    // 接口返回的数据都在data里
    data: {code: '000000', message: '成功', data: Array(35)}
    headers: {access-control-allow-origin: '*', connection: 'close', content-type: 'application/json;charset=UTF-8', date: 'Mon, 13 Sep 2021 09:12:03 GMT', transfer-encoding: 'chunked'}
    request: XMLHttpRequest {readyState: 4, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, onreadystatechange: ƒ, …}
    status: 200
    statusText: "OK"    	
}
```



### new FileReader()

主要涉及在前端处理图片上传时候回显、接收后端文件

1.FileReader : 读取文件内容

readAsText() 读取文本文件，(可以使用Txt打开的文件)
readAsBinaryString(): 读取任意类型的文件，返回二进制字符串

readAsDataURL(): 方法可以将读取到的文件编码成DataURL ，可以将资料(例如图片、excel文件)内嵌在网页之中

2.FileReader 提供一个完整的事件模型，用来捕获读取文件的状态
onabort:读取文件断片时触发
onerror:读取文件错误时触发
onload:文件读取成功时触发
onloadend:文件读取完毕之后，不管成功还是失败触发
onloadstart: 开始读取文件时触发
onprogress:读取文件过程中触发

```html
<!--使用Data URL加载图片资源-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blob Test</title>
  <script>
    function handleFile(e) {
      var file = e.files[0];
      var fileReader = new FileReader();
      var img = document.getElementByTagName("img")[0];
      fileReader.onload = function(e) {
        img.src = e.target.result;
      }
      fileReader.readAsDataURL(file);
    }
  </script>
</head>
 
<body> 
  <input type="file" accept="image/*" onchange="handleFile(this)" />
  </br>
  <img style="width:200px;height:200px;">
</body>
  
</html>
```

```html
<!--使用Blob URL 回显图片-->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Blob Test</title>
  <script>
    function handleFile(e) {
      var file = e.files[0];
      var blob = URL.createObjectURL(file);
      var img = document.getElementByTagName("img")[0];
      img.src = blob;
      img.onload = function(e) {
        URL.revokeObjectURL(this.src); //释放createObjectURL创建得对象
      }
    }
  </script>
</head>

<body>
  <input type="flie" accept="image/*" onchange="handleFile(this)" />
  <br/>
  <img style="width:200px;height:200px;">
</body>

</html>
```



```js
function add(f) {
			// console.log(f.files[0].type)    //图片格式
			// console.log(f.files[0].size)    //图片大小做判断
			// 解析预览
			let reader = new FileReader()
			reader.readAsDataURL(f.files[0])
			reader.onload = function () {
			  // console.log( reader.result)  //base64格式的图片
			  myimg.src=reader.result
			}
			//上传时候也是传的f.files[0]文件。
	}

// 上传图片回显实例 jsx写法
{ label: '图标', prop:'icon', colSpan: 24, render: (data: any) => {
      const fileUploadChange = (file: any) => {
        let reader = new FileReader()
        reader.readAsDataURL(file.raw)
        reader.onload = function () {
          data.formData.icon = reader.result
        }
      }
      let dom = <i class="el-icon-plus avatar-upload-icon"></i>
      if (data.formData.icon) {
        dom = <img src={data.formData.icon} class="avatar"></img>
      }
      return (
        <el-upload
          class="avatar-upload"
          on-change={fileUploadChange}
          auto-upload={false}
          show-file-list={false}>
          {dom}
        </el-upload>
      )
    }, },
```

### blob对象

blob就是类似文件对象的二进制大数据

可以像操作File对象一样操作Blob对象，实际上，**File继承自Blob**

构造: new Blob([blobparts], options)

参数：**blobparts** : 数组类型 数组中每项连在一起构成blob数据

**options**: 可选项 字典格式类型 

可指定: 

1. **type**   默认值为`""`，代表被放入到blob中的数组内容的MIME类型

2. **endings**   默认值为"transparent"，用于指定包含行结束符`\n`的字符串如何被写入

Blob([blobparts1, blobparts2], options)

```js
// 通过new Blob() 构造一个Blob实例
// 入参
const blob = new Blob()
```

#### 文件下载

```js
function download (data, fileName) {
  if (!fileName) {
    let dis = data.headers['content-disposition']
    fileName = decodeURIComponent(dis.split('attachment;filename=')[1])
  }
  const blob = new Blob([data.data || data], {
    type: 'application/octet-stream'
  }) // 处理文档流
  const urlObject = window.URL || window.webkitURL || window
  let blobURL = urlObject.createObjectURL(blob)
  const tempLink = document.createElement('a')
  tempLink.style.display = 'none'
  tempLink.href = blobURL
  tempLink.setAttribute('download', fileName)
  if (typeof tempLink.download === 'undefined') {
    tempLink.setAttribute('target', '_blank')
  }
  document.body.appendChild(tempLink)
  tempLink.click()
  urlObject.revokeObjectURL(blobURL) // 释放URL对象
  document.body.removeChild(tempLink)
}
```



#### Blob URL

Blob URL是blob协议的URL    格式：`blob:http://xxx`

通过`URL.createObjectURL(blob)`创建

通常作为文件的下载地址和作为图片资源地址

```typescript
const convertRes2Blob = (response: AxiosResponse) => {
  // 获取文件名
  const filename = response.config['filename']
  // 将二进制流转为blob
  const blob = new Blob([response.data], { type: 'application/octet-stream' })
  const blobURL = window.URL.createObjectURL(blob)
  const tempLink = document.createElement('a')
  tempLink.style.display = 'none'
  tempLink.href = blobURL
  tempLink.setAttribute('download', decodeURI(filename))
  if (typeof tempLink.download === 'undefined') {
    tempLink.setAttribute('target', '_blank')
  }
  document.body.appendChild(tempLink)
  tempLink.click()
  document.body.removeChild(tempLink)
  // 释放blob URL地址
  window.URL.revokeObjectURL(blobURL)
}



//文本转语音实例
audioAPI.getShortAudio({
    config: {
      format: 'mp3',
      sampleRate: 16000,
      pitch: 0,
      volume: 0,
      speed: -250,
      digitMode: 0,
      puncMode: false
    },
    text: text // 要播报的内容
  }, null, data => {
    console.log(data)
    loadingInstance.close()
    // 1.接口返回blob类型文件，转化为blobURL
    const url = URL.createObjectURL(data.data)
    // 2.传入转化后的url,创建audio实例
    self.n = new Audio(url)
    self.n.play()
  })
```

#### Blob URL和Data URL区别

1.Blob URL得长度一般比较短，但Data URL因为直接存储图片base64编码后得数据，往往很长。当显示大图片时，使用Blob URL更优。

2.Blob URL可以方便的使用XMLHttpRequest获取源数据

3.**Blob URL只能在当前应用内部使用**，把Blob URL复制到浏览器的地址栏中，是无法获取数据的。Data URL相比之下，就有很好的移植性，你可以在任意浏览器使用。

除了可以用作图片资源的网络地址，Blob URL也可以用作其他资源的网络地址，例如html文件、json文件等，为了保证浏览器能正确的解析Blob URL返回的文件类型，需要在创建Blob对象时指定相应的type：

```js
var data = "<div style='color:red;'This is a blob</div>";
var blob = new Blob([data], {type: 'text/html'}); // 'application/json'
var blobUrl = URL.createObjectURL(blob);
```

### File对象

File指本地文件系统中的文件。File对象提供有关文件的信息，并允许网页中的 JavaScript 访问其内容。

File是一个具有名字同时可能也有一个修改日期的Blob。可以从一个由 <input type="file"/> 元素组成的 files 数组中，或者从一个由与 drop 事件的 Event 对象关联的 DataTransfer 对象组成的 files 数组中，取得一个用户选择的文件。

可以通过 FormData 对象或者将 File 传入 XMLHttpRequest.send() 来将一个文件的内容上传到服务器，除此之外 File 对象本身不支持别的操作。可以使用 FileReader 来读一个 File（或者任意 Blob）的内容。

```js
// bits：ArrayBuffer，ArrayBufferView，Blob，或者 DOMString 对象的 Array — 或者任何这些对象的组合
// name: 文件名称或文件路径
// options: 可选配置属性 {type: 文件中的内容的 MIME 类型, lastModified: 文件最后修改时间}
var myFile = new File(bits, name[, options]);

// 示例
var file = new File(["foo"], "foo.txt", {
  type: "text/plain",
});
```





### 时间格式化库 dayjs

npm install dayjs



### $event

#### 场景1：获取原生DOM事件的事件对象

在DOM事件的回调函数中传入参数`$event`，可以获取到该事件的事件对象

#### $event子组件传参

在子组件中通过`$emit`注册事件，将数据作为参数传入，在父组件中通过`$event`接收

```vue
//子组件hello.vue
<button @click="$emit('btnClick', 'hello')">hello</button>

//父组件接收
<template>
	<hello @btnClick="btnClick($event)"></hello>
</template>

<script>
	export default {
        methods: {
            btnClick(e){
                console.log(e)
            }
        }
    }
</script>
```





#### vue监听方法时加不加括号区别

@click=handler($event)  加了括号需要手动传入原生事件对象$event, 不传会报undefined

@click="handler"  不加括号 默认第一个参数是$event

加与不加括号的区别在于事件对象参数 event 的处理。不加括号时，函数第一个参数为 event，加了括号后，需要手动传入 $event 才能获得事件对象。

```vue
<template>
<button @click="getData($event)">按钮</button>
</template>

<script>
export default {
    setup() {
        const getData = (e) => {
            console.log(e)
        }
        return {
            getData
        }
    }
}
</script>
```

 



#### 场景2：事件注册所传的参数(子组件向父组件传值)

在子组件中通过`$emit`注册事件，将数据作为参数传入，在父组件中通过`$event`接收

```vue
<!-- 父组件 -->
<template>
<Hello @hello="showData($event)" />
<h4>{{data}}</h4>
</template>

<script>
import Hello from '@/components/Hello.vue'
import {
    ref
} from 'vue'
export default {
    components: {
        Hello
    },
    setup() {
        const data = ref(null)
        const showData = (e) => {
            data.value = e
        }
        return {
            showData,
            data
        }
    }
}
</script>

<!-- 子组件 -->
<template>
<button @click="$emit('hello', 'hello')">Hello</button>
<!-- $emit()的第一个参数是定义的事件名，第二个参数是要传入的数据 -->
</template>

<script>
export default {

}
</script>
```



### 动态路由注册

后端返回路由表

```js
{
  "data": {
    "router": [
      {
        "path": "",
        "redirect": "/home",
      },
      {
        "path": "/home",
        "component": "Home",
        "name": "Home",
        "meta": {
          "title": "首页",
          "icon": "example"
        },
        "children": [
          {
            "path": "/xitong",
            "name": "xitong",
            "component": "xitong/xitong",
            "meta": {
              "title": "系统",
              "icon": "table"
            }
          }
        ]
      },
      {
        "path": "*",
        "redirect": "/404",
        "hidden": true
      }
    ]
  }
}
```

注意其中的component字段，他是字符串，我们需要把这个字符串转化为我们前端定义的组件

```js

function filterRouter(routers) { // 遍历后台传来的路由字符串，转换为组件对象
    const accessedRouters = routers.filter(route => {
        if (route.component) {
            if (route.component === 'Home') { // Home组件特殊处理
                route.component = Home
            } else {
                route.component = _import(route.component)
            }
        }
        if (route.children && route.children.length) {
            route.children = filterRouter(route.children)
        }
        return true // filter方法执行到最后返回true 既符合条件的route
    })
    return accessedRouters
}

//这个函数的主要作用就是把后台传过来的字符串型的component转化为真正的组件
function _import (file) {
    return () => import('@/components/views/' + file + '.vue')
}
```



### Mock配置相关

```js
// vue_cli项目 配电网
// 在.env.devlopment文件内配置: VUE_APP_OPEN_MOCK = true 
import Mock from 'mockjs'
import MockCommon from './common'
import MockProject from './project'
import MockStream from './stream'

const mockArray = [
  ...MockCommon,
  ...MockProject,
  ...MockStream
]

// vue_cli利用VUE_APP_OPEN_MOCK配置文件进行mock开关设置
if (JSON.parse(process.env.VUE_APP_OPEN_MOCK)) {
  for (const mockItem of mockArray) {
    Mock.mock(process.env.VUE_APP_BASE_URL + mockItem.url, mockItem.method, mockItem.response)
  }
}

// vite项目 湖南中台 mock.js
import { MockMethod } from 'vite-plugin-mock'  //MockMethod是mock插件
import commonMock from './modules/common/index'
import applicationMock from './modules/application/index'

export default [
  ...commonMock,
  ...applicationMock,
  ...categoryMock,
] as MockMethod[]   


// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import vueJsx from '@vitejs/plugin-vue-jsx'
import { viteMockServe } from 'vite-plugin-mock' //控制台显示mock请求的插件
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  base: './',
  plugins: [vue(), vueJsx(), viteMockServe({
    localEnabled: false // 模拟数据开关
  })],
  resolve: { 
    alias: {
      '~': path.resolve(__dirname, './'),
      '@': path.resolve(__dirname, 'src')
    }
  },
  server:{
    proxy:{
      '/api': {
        target: 'http://10.1.192.38:18084/', // 杭州测试环境网关
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  }
})

```

### 浏览器线程概念

　js是单线程的，但是浏览器是多线程的，多个线程相互配合以保持同步，浏览器下的线程有

- JavaScript引擎线程，用于解析JavaScript代码 
- GUI渲染线程，（它与javaScript线程是互斥的）
- 事件线程(onclick,onchange,…)
- 定时器线程(setTimeout, setInterval)
- 异步http线程(ajax)，负责数据请求
- EventLoop轮询处理线程，事件被触发时该线程会把事件添加到待处理队列的队尾

### JS的事件循环和任务队列

**事件循环(event loop):** 同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入任务队列。主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop (事件循环)。

在事件循环中，每进行一次循环操作称为tick，通过阅读规范可知，每一次 tick 的任务处理模型是比较复杂的，其关键的步骤可以总结如下：

1.在此次 tick 中选择最先进入队列的任务( [oldest task](https://www.zhihu.com/search?q=oldest+task&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A87684858}) )，如果有则执行(一次)

2.检查是否存在 Microtasks ，如果存在则不停地执行，直至清空Microtask Queue

3.更新 render

4.主线程重复执行上述步骤

注：如此循环就形成了event loop，其中，每轮执行**一个宏任务**和**所有的微任务**

**任务队列(task queue):** 

当遇到计时器(setTimeout)、DOM事件监听或者是网络请求的任务时，JS引擎会将它们直接交给 webapi，也就是浏览器提供的相应线程（如定时器线程为setTimeout计时、异步http请求线程处理网络请求）去处理，而JS引擎线程继续后面的其他任务，这样便实现了 异步非阻塞。

定时器触发线程也只是为 setTimeout(…, 1000) 定时而已，时间一到(1s过后)，还会把它对应的回调函数(callback)交给 任务队列 去维护，JS引擎线程会在适当的时候去任务队列取出任务并执行。

所以我们可以说：任务队列存储了来自webapi的回调函数，这些函数等待被系统调用到执行栈（也就是主线程）上去运行。

所有的任务分为**同步任务**和**异步任务**，任务进入执行栈后，同步任务直接进入主线程执行，异步任务会被放入**微任务队列或宏任务队列**中挂起

异步任务又分为**微任务microTask**和**宏任务macroTask**

1、微任务优先级永远高于宏任务

2、宏任务的优先级按照谁先达到执行的时间

宏任务主要包含：script( 整体代码)、 ajax异步请求、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)

微任务主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)

```js
setTimeout(()=> console.log(20))
new Promise(resolve => {
    resolve(40)
}).then(res => {
    console.log(res)
    return new Promise(resolve => resolve('OKKKK'))
}).then(res => console.log(res))

new Promise(resolve => {
    resolve(10)
}).then(res => {
    console.log(res)
    return new Promise(resolve => resolve('GOOD!'))
}).then(res => console.log(res))

setTimeout(() => console.log(30))

console.log(60)          // 执行顺序 60 40 10 OKKKK GOOD! 20 30
```



#### setTimeout本质

setTimeout(()=>console.log('XXX'), 1000)

1. **主线程**运行到setTimeout函数，交给**webAPI**处理
2. webAPI对定时器函数处理, 1秒后延时任务完成
3. 1秒后将setTimeout回调函数推给**任务队列**，在任务队列中排队
4. 当**主线程**全部任务完成后，将任务队列中第一个任务拿出来放到**执行栈(主线程)**执行
5. 执行完后继续检查任务队列，当任务队列不为空，则继续步骤4，形成**事件循环(Event Loop)**

#### async / await 执行问题

```js
async function async1() {
  await async2()
  console.log('async1 end')
}
async function async2() {
  console.log('async2 end')
}
async1()

// 等价ES5写法
new Promise((resolve, reject) => {
  async2() 
  ...
}).then(() => {
 // 执行async1()函数await之后的语句
  console.log('async1 end')
})
```

**async**将你的函数返回值转换为promise对象，不需要显式地返回promise对象，async关键字自动将函数的返回值变为promise对象

**await** 只能在async函数内部使用，等待的是右侧[表达式结果]，如果右侧是一个函数，等待的是右侧的函数返回值, 若右侧不是函数则直接是右侧的表达式。await在等待时会让出线程阻塞后面的执行。await的执行顺序为从右到左，会阻塞后面的代码执行，但并不是直接阻塞await的表达式。

await之后如果不是promise，await会阻塞后面的代码，会先执行async外面的同步代码，等外面的同步代码执行完成在执行async中的代码。

如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。

 **async 函数中，遇到 await 会跳出当前函数，并让出线程，再将await后面的代码放到 微任务（microtask）队列中。**



### DOM0级和DOM2级事件处理程序区别

DOM0级

分为2个：一是在标签内写onclick事件

　　　　  二是在JS写onclick = function（）{}函数

**DOM0级相同的事件只能绑定一个，后一个会覆盖前一个事件**

DOM2级

只有一个：监听方法，有两个方法用来添加和移除事件处理程序：addEventListener()和removeEventListener()。

**DOM2级可以同时绑定几个事件（相同或不同），然后顺序执行，不会覆盖。**

它们都有三个参数：第一个参数是事件名（如click）；

　　　　　　　　　第二个参数是事件处理程序函数；

　　　　　　　　  第三个参数如果是true则表示在捕获阶段调用，为false表示在冒泡阶段调用。

```html
<!--dom0级事件处理程序，绑定的函数后面要加括号，因为其本质是一个字符串，执行时解析字符串中的函数-->
<!--写法1： 绑定在html上-->
<button id="btn1" onclick="demo()">按钮</button>
<script>
    //写法2：写在js中
	document.getElementById('btn1').onclick = function(){
        demo()
    }
</script>

<!--dom2级事件处理程序, addEventListener
	函数名的本质是指针，指向函数地址，绑定函数名，不需要加括号(带参数函数，需包裹匿名函数)
-->
<script>
	document.getElementById('btn1').addEventListener('click', demo, false)
</script>
```

#### 原生事件对象event

```html
<button id="btn1" onclick="demo(this)">按钮</button>
<button id="btn2" onclick="demo3(event)">按钮2</button>
<button id="btn3">按钮3</button>
<script>
    // dom0级绑定写法1：这个参数source就是htmlElement元素,也就是event.target
	function demo(source){
        console.log(source) // 获得source就是this, 当前元素对象
    }
    function demo3(e){
        console.log(e)  //获得事件对象event
    }
    // dom0级绑定写法2： 默认传入事件对象e
    document.getElementById('btn3').onclick = function(e){
        console.log(e)
        console.log(this)
    }
</script>
```



### decodeURI和decodeURIComponent区别

encodeURI/decodeURI对特殊字符(/ * # &)没有编码解码能力, 在返回查询体时容易被截断导致错误

```js
// encodeURI
let codeVal = encodeURI('202112#abc')
let url = 'http://www.baidu.com?code=' + codeVal
console.log(url) // http://www.baidu.com?code=202112#abc
// 使用location.search获取查询体，不能编码特殊字符，导致#被截断
location.search // ?code=202112
decodeURI('?code=202112')  // ?code=202112 错误的返回，因为#后的参数没有返回

// encodeURIComponent
var codeVal = encodeURIComponent('20180711#abc');
var url = 'http://www.baidu.com?code=' + codeVal;
// 使用encodeURIComponent编码 特殊字符#不会被截断
console.log(url)   // "http://www.baidu.com?code=20180711%23abc"
location.search // ?code=20180711%23abc
decodeURIComponent('?code=20180711%23abc') // "?code=20180711#abc"
```

### flex布局混淆点

```
flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto
flex属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)

flex-grow: 项目的放大比例，默认为0，如果存在剩余空间，不放大
flex-shrink: 项目的缩小比例，默认为1，如果空间不足，会适当缩小
flex-basis: 在分配空间之前，项目的主轴空间，相当于我们设置的width

```

flex: 1 === flex: 1 1 0%  

flex: auto === flex: 1 1 auto

auto 表示项目本身的大小, **如果设置为 auto, 那么这三个盒子就会按照自己内容的多少来等比例的放大和缩小**, 所以出现了上图中三个盒子不一样大的情况



### vscode关闭es-lint

文件-首选项-设置搜索"eslint.enable"  关闭



### ES11可选链 操作符 ?.

```js
//语法
obj?.prop
obj?.[expr]
arr?.[index]
func?.(args)
//使用方括号与属性名的形式来访问属性时
let nestedProp = obj?.['prop' + 'Name'];
// 访问数组
let arrayItem = arr?.[42];
//调用函数
adventurer.someNonExistentMethod?.()
```

### 执行上下文和堆栈

递归调用是如何工作的。为此，我们会先看看函数底层的工作原理。

有关正在运行的函数的执行过程的相关信息被存储在其 **执行上下文** 中。

[执行上下文](https://tc39.github.io/ecma262/#sec-execution-contexts) 是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置，当前的变量，`this` 的值（此处我们不使用它），以及其它的一些内部细节。

一个函数调用仅具有一个与其相关联的执行上下文。

当一个函数进行嵌套调用时，将发生以下的事儿：

- 当前函数被暂停；
- 与它关联的执行上下文被一个叫做 **执行上下文堆栈** 的特殊数据结构保存；
- 执行嵌套调用；
- 嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从停止的位置恢复外部函数。

```js
// 递归例子
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
      // 递归函数会创建新的执行上下文，并记录到堆栈顶部
      // 当这个调用结束时，会被弹出堆栈，并继续执行下去
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) );



// 任何递归都可以用循环来重写，通常循环变体更有效，循环算法更节省内存：
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```



![image-20220121170117082](D:\typora-img\image-20220121170117082.png)



### 关于img父容器的高度会比img的高度多几像素的问题

基线问题，div是块级标签，img是行内块元素，在块元素里默认有3px或者4px空白（其实就是和文本的基线对齐不管有没有文本）

解决方案： 1.设置图片 display:block  2.设置父容器:display: flex  3.设置图片vertical-align: top



### 文档注释插件

vscode安装 document this

快捷键：选中方法ctrl+alt+D 连按两次

### 文档注释规范

```js
/**
 * 方法说明
 * @method 方法名
 * @for 所属类名
 * @param {参数类型} 参数名 参数说明
 * @return {返回值类型} 返回值说明
 */

```

### class中的extends继承

class本质还是一个function 因此它就会拥有一个prototype属性，当new一个class时，会把class的porototype属性赋值给这个新对象的 **proto**属性。（prototype是函数的一个属性，它是一个指针。对于构造函数来说，prototype是作为构造函数的属性。prototype也可以是一个对象，prototype是对象实例的原型对象。所以prototype即是属性，又是对象。在new一个对象时,可以理解为一个对象没有ptototype属性，所以把ptototype给一个对象的 **proto**

```js
class Person{
    constructor(skin,language){
        this.skin=skin;
        this.language=language;
    }
    say(){
        console.log('I am a Person')
    }
}
console.log(typeof Person); // function
let p = new Person('unkown','unknown');
console.log(p); // Person {skin: "unkown", language: "unknown"}
console.log(p.__proto__ === Person.prototype); // ture

```

子类American继承父类Person，子类没定义constrcutor,则默认添加一个，并且在constrcutor中调用super函数,相当于调用父类的构造函数。**调用super函数是为了在子类中获得父类的this**，调用之后this指向子类。也就是父类.prototype.constructor.call(this)。

子类有constructor时，子类必须在constructor方法中调用super方法，否则new实例时会报错。因为子类没有自己的this对象，而是继承父类的this对象。如果不调用super函数，子类就得不到this对象。super()作为父类的构造函数，只能出现在子类的constructor()中；但是super指向父类的原型对象，可以调用父类的属性和方法。

```js
// 1.子类没有constructor时
class American extends Person{
    aboutMe(){
        console.log(this.skin+' '+this.language)
    }
}
// 2.子类有constructor时
class Chinese extends Person{
    constructor(skin,language,positon){
        //console.log(this);//报错
        super(skin,language);
        //super();
        //console.log(this);调用super后得到了this，不报错
        this.positon=positon;
    }
    aboutMe(){
        console.log(this.skin+' '+this.language+' '+this.positon);
    }
}
```

实例化子类

实例化子类对象时，子类对象可以拥有父类的属性和方法，子类对象还可以拥有自己的属性和方法。比如chinese 继承了父类的say方法，还拥有自己的chinese say方法。最后两行代码表示
 1）子类的**proto**属性,表示构造函数的继承，总是指向父类。
 2）子类的prototype属性的**proto**属性表示方法的继承，总是指向父类的prototype属性

```js
let american = new American('white','English');
let chinese =new Chinese('yellow','chinese','changsha');
chinese.say();//I am a Person
chinese.chinesesay();//I am a Person   I am a Chinese
console.log(American.__proto__ === Person);//true 
console.log(American.__proto__);//父类对象
console.log(American.prototype.__proto__ === Person.prototype);//true
```



### class类中的super关键词

作用：

super用于访问父对象上的函数

语法：

1. super([arguments]) // 访问父对象上的构造函数
2. super.functionOnParent([arguments]) //访问对象上的方法

#### 1.  super作为函数调用时

```js
// 1. super 作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次 super() 函数。
class A {}
class B extends A {
  constructor() {
    super(); //类似函数的call， 相当于执行了A的constructor，并且让方法中的this指向B的实例
  }
}
// super 作为函数调用时，内部的 this 指的是子类实例
class A {
  constructor() {
    this.show();
  }
}
class B extends A {
  constructor() {
    super();
  }
  show(){
    console.log('实例');
  }
  static show(){
    console.log('子类');
  }
}
new B() 　//输出 '实例' ，new B 时触发了 B 的构造函数，所以触发了 super 方法，即触发了父类 A 的构造函数，此时的 this.show 的 this 指的是子类 

```

####  2.1 super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。	

```js
//super在普通方法中（即非静态方法）及此时的 this 关键字指向
class A {
  p() {
    return 2;
  }
}
class B extends A {
  constructor() {
    super();
    console.log(super.p()); // 2  此时的super指向父类原型对象，即 A.prototype
  }
}
let b = new B();　　//2


//由于在普通方法中的 super 指向父类的原型对象，所以如果父类上的方法或属性是定义在实例上的，就无法通过 super 调用的。如下所示：
class A {
  constructor() {  //在构造函数上定义的属性和方法相当于定义在父类实例上的，而不是原型对象上
    this.p = 2;
  }
}
class B extends A {
  get m() {
    return super.p;
  }
}
let b = new B();
console.log(b.m) // undefined


//在子类普通方法中通过 super 调用父类的方法时，方法内部的 this 指向的是当前的子类实例。
class A {
  constructor() {
    this.x = 1;
  }
  print() {
    console.log(this.x);
  }
}
class B extends A {
  constructor() {
    super();
    this.x = 2;
　　 super.y = 123;　　//如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。
  }
  m() {
    super.print();
  }
}
let b = new B();
b.m() // 2
console.log(b.y);  //123
```

#### 2.2 super在静态方法中及此时的 this 关键字指向

```js
//super作为对象，用在静态方法之中，这时 super 将直接指向父类，而不是父类的原型对象。
class Parent {
  static myMethod(msg) {
    console.log('static', msg);
  }
  myMethod(msg) {
    console.log('instance', msg);
  }
}
class Child extends Parent {
  static myMethod(msg) {
    super.myMethod(msg);
  }
  myMethod(msg) {
    super.myMethod(msg);
  }
}
Child.myMethod(1); // static 1
var child = new Child();
child.myMethod(2); // instance 2



//在子类的静态方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类，而不是子类的实例。
class A {
  constructor() {
    this.x = 1;
  }
  static print() {
    console.log(this.x);
  }
}
class B extends A {
  constructor() {
    super();
    this.x = 2;
  }
  static m() {
    super.print();
  }
}
B.x = 3;
B.m() // 3
```



### class类的静态属性和静态方法 static

如果在一个方法前加上[static](https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020)关键字，就表示该方法不会被**实例**继承，而是直接通过类来调用，这就称为“静态方法”

静态方法只能写在class内，constructor外。通过static关键字声明

静态属性通过 类名.属性名 = 属性值 声明

```js
//静态属性与静态方法(ES6明确规定，Class内部只有静态方法，没有静态属性 )
            
//1.不会被类实例所拥有的属性与方法,只是类自身拥有
//2.只能通过类调用

//通过static关键字声明一个静态方法

class Car{
    constructor(){
        Car.totalCar += 1;
        this.speed = 0;
    }

    speedUp(){
        this.speed += 1;
    }

    static repair(car){
        if(!car.speed){
            car.speed = 0;
        }

        console.log(car);
    }
}

//静态方法只能通过类去访问,不能通过实例去访问的
Car.repair({
    color:'#f00'
});
//静态方法跟普通方法可以重名


//静态属性只能通过 类名.属性名 = 属性值;
//静态属性可以增加一些配置项等等
Car.totalCar = 0;  //记录生成了多少个Car对象
//直接挂在类上面,跟程序的耦合性降低
Car.config = {
    wheel:4,
    color:'#000'
}

//直接方法静态属性： 类名.属性名
new Car()
console.log(Car.totalCar);
```

### 为什么不能在data中使用this

因为此时的 data 初始化正在进行，即在取值步骤（参考上面初始化的解释），还未进行代理和监听（此时 newId 未代理到 this 上），所以 this.newId 等于 undefined

https://blog.csdn.net/u012557814/article/details/120963056



### replace 第二个参数$1, $2..切割正则

```js
//把 "Doe, John" 转换为 "John Doe" 的形式：
var str = "Doe, John";
str.replace(/(\w+)\s*, \s*(\w+)/, "$2 $1");
//说明：$1,$2上就是按顺序对应小括号里面的小正则 捕获到的内容。 
```

###  replace高级用法 

```js
//第二个参数使用函数 该函数有多个入参
function replacer(match,p1,p2,p3,offset,string){
    //打印结果:abc12345#$%* abc 12345 #$%* 0 abc12345#$%*
    console.log(match,p1,p2,p3,offset,string)
    return [p1,p2,p3].join('-')
}
// str = 'abc-12345-#$%*'
var str = 'abc12345#$%*'.replace(/([^\d]*)(\d*)([^\w]*)/, replacer)

// 匹配的手机号码高亮
function lightPhoneNumber (origin, search) {
  if (isEmpty(search)) return origin
  return origin.replace(new RegExp(search, 'ig'), function (match) { // 第一个参数是匹配到的字符
    return `<span style="color: #1C84FD;">${match}</span>`
  })
}

// 格式化手机号码
export function toFormatPhoneNumber (origin) {
  return isEmpty(origin) ? '' : origin.replace(/(\d{3})(\d{0,4})(\d{0,4})/, '$1 $2 $3')
}

```



## 服务器相关概念

### nginx概念

Nginx是一个高性能http和反向代理服务器 （或叫web服务器）

Nginx不仅能做反向代理，实现负载均衡；还能可以作正向代理来进行上网等功能。

### web服务器

负责处理和响应用户请求，一般也称为http服务器，如 Apache、IIS、Nginx

应用服务器：存放和运行系统程序的服务器，负责处理程序中的业务逻辑，如 Tomcat、Weblogic、Jboss（现在大多数应用服务器也包含了web服务器的功能）

### tomcat概念

Tomcat是web容器，Tomcat 服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应HTML页面的访问请求。实际上Tomcat是Apache 服务器的扩展。

在做web项目时，多数需要http协议，也就是基于请求和响应，比如你在百度输入一行内容搜索，
那么百度服务器如何处理这个请求呢，他需要创建servlet来处理，servlet其实就是java程序，只是在服务器端的java程序，
servlet通过配置文件拦截你的请求，并进行相应处理，然后展示给你相应界面，那么servlet如何创建？ 这时候tomcat用到了，
它就是帮助你创建servlet的东西，所以也称web容器，没有它，没法运行web项目。相对应的web容器有很多，
比如JBOSS,WEBLOGIC等。

### Nginx 和 Tomcat的逻辑关系

Nginx和Tomcat都是服务器，或者说，都可以作为服务器。

但是有点区别：

　　1.粗略来说，Tomcat是针对Java环境运行的服务器，而Nginx是PHP和静态资源常用的服务器。

　　　　专业点讲，Tomcat是一个Servlet/JSP容器。也就是说，Java代码编写的服务端代码，

　　　　要运行在Tomcat里面才行。

　　2.Nginx的优点是反向代理，也就是，为服务器做代理。让所有访问，都经过Nginx分发给服务器。

　　　　换句话说，Nginx充当集散中心的角色，所有访问都统一经过Nginx，

　　　　然后通过配置Nginx来实现多台服务器共同处理某项业务，或者不同的服务器处理不同的业务。

　　　　也就是负载均衡(可能不准确)。

实际使用时，为了提高服务端的处理能力，可以搭建多个Tomcat实例，来处理不同的业务，

然后使用Nginx的反向代理这些实例。

![img](D:\typora-img\v2-e1826bab1d07df8e97d61aa809b94a10_720w.webp)

### servlet

servlet是Server Applet的简称，翻译过来就是服务程序．好吧，这么说你可能还是不太懂，简单的讲，这个servlet是运行在服务器上的一个小程序，用来处理服务器请求的．进一步讲，我们知道，一般的网页程序，是由我们通过浏览器访问来实现的，在这个过程中，我们的浏览器发送访问请求，服务器接收请求，并对浏览器的请求作出相应的处理．这就是我们熟悉的B/S模型(浏览器－服务器模型)．而servlet就是对请求作出处理的组件，运行于支持Java的应用服务器中

### dubbo

分布式服务框架

1.透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。
2.软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。

3.服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。

### SOA

**Service-Oriented Architecture**是面向服务的架构，它是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型，将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来

### 正向代理和反向代理

正向代理

隐藏了真实请求的客户端，客户端的请求通过代理服务器，服务端不知道真实的客户端是谁，某些科学上网工具就是正向代理服务器，比如访问google.com 就可以通过正向代理，让代理请求，再把请求返回给我

反向代理

反向代理隐藏了真实的服务器，当请求baidu.com时，背后可能是N个服务器为我们服务，但具体是哪一台并不知道，baidu.com就是我们的反向代理服务器，反向代理把请求转发到真实的服务器，nginx就是一个反向代理服务器，用来做负载均衡

![image-20220311102725898](D:\typora-img\image-20220311102725898.png)

两者的区别在于代理的对象不一样：**正向代理**代理的对象是客户端，**反向代理**代理的对象是服务端







### css逗号选择器混淆点

```css
/* 有逗号，表示给xxx zzz 2个类设置样式 */
.xxx,.zzz {
    color: red;
}
/* 没有逗号没有空格，表示给同时拥有xxx zzz 样式的元素设置样式 */
.xxx.zzz {
    color: red;
}
/* 有空格，表示后代选择器 */
.xxx .zzz {
    color: red;
}
```

### 渐变属性linear-gradient参数

**语法：**

**<linear-gradient>** = linear-gradient([[<angle>| to <side-or-corner>],]? <color-stop>[<color-stop>]+)

**<side-or-corner>** = [left | right] || [top | bottom]

**<color-stop>** = <color>[<length>|<percentage>]



**取值：**



**下述值用来表示渐变的方向，可以使用角度或者关键字来设置：**

angle:用角度值指定渐变的方向（或角度）。

to left：

设置渐变为从右到左。相当于: 270deg

to right：

设置渐变从左到右。相当于: 90deg

to top：

设置渐变从下到上。相当于: 0deg

to bottom：

设置渐变从上到下。相当于: 180deg。这是默认值，等同于留空不写。



<color-stop> 用于指定渐变的起止颜色：

<color>指定颜色。

<length>用长度值指定起止色位置。不允许负值

<percentage>用百分比指定起止色位置。

linear-gradient(to right, #000 **6px**, transparent **6px**) repeat-x,

回到自己的理解 就是#000到**6px**，前都是纯#000，**6px**之后都是透明

**重复不渐变**： 红色渐变到红色 蓝色渐变到蓝色

background: linear-gradient(to right, red, red 2px, blue 2px, blue) 

### white-space/word-break/word-wrap区别

**word-wrap: normal | break-word**

- normal：单词太长，剩余空降不足则挪到下一行显示，在下一行中超过一行就溢出显示。
- break-word：<u>单词太长，剩余空降不足则挪到下一行显示，在下一行中超过一行就在单词内换行</u>。

**word-break: normal | break-all | keep-all**

- normal：单词太长，剩余空降不足则挪到下一行显示，在下一行中超过一行就溢出显示。
- break-all：<u>单词太长，剩余空间不足就直接在单词内换行显示。</u>
- keep-all：单词太长，不会换行，直接溢出显示，只有在半角空格或连字符处才会换行。

**white-space: normal | nowrap | pre | pre-wrap | pre-line | inherit**

**空白是指“空白字符”,包括空格、制表符等， white-space就是对空白字符的处理**

- normal：默认。合并空格，多个相邻空格合并成一个空格，在源码中的换行作为空格处理，只会根据容器的大小进行自动换行。

- nowrap：文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。

- pre：空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签。

- pre-wrap：保留空白符序列，但是正常地进行换行。

- pre-line：合并空白符序列，但是保留换行符。

- inherit：规定应该从父元素继承 white-space 属性的值。

  | white-space属性 | 源码空格 | 源码换行 | <br>换行 | 容器边界换行 |
  | --------------- | -------- | :------- | -------- | ------------ |
  | normal          | 合并     | 忽略     | 换行     | 换行         |
  | nowrap          | 合并     | 忽略     | 换行     | 不换行       |
  | pre             | 保留     | 换行     | 换行     | 不换行       |
  | pre-wrap        | 保留     | 换行     | 换行     | 换行         |
  | pre-line        | 合并     | 换行     | 换行     | 换行         |




### setMonth获取过去12个月

```js
getLastYearMonth () {
  let dateArr = []
  let date = new Date()
  for (let i = 0; i < 12; ++i) )
  // setMonth等方法会返回时间戳参与计算 每次循环getMonth都会-1
    date.setMonth(date.getMonth() - 1)
    let m = date.getMonth() + 1
    m = m < 10 ? '0' + m : m
    dateArr.push(date.getFullYear() + '-' + m)// date的getFullYear也会字段
  }
  return dateArr
}
```



### Error对象

#### 2个属性

**name**: 设置回返回一个错误名

**message**: 设置或返回一个错误信息(字符串)

```js
try{
	new Error('im Error') // 创建Error类型错误对象
}catch(e){
    console.log(e) //无法捕获，只是创建一个错误对象，要捕获错误必须throw主动抛出
}
// 抛出错误
try{
    throw 'im error too'
}catch(e){
    console.log(e) // 可以捕获
}
```

#### Error常见错误类型

SyntaxError  语法错误

ReferenceError 引用错误

TypeError 类型错误

RangeError 范围错误



### vue中this作用域问题

```js
//babel编译采用严格模式，全局环境下this是undefined
//vue-methods中 this默认绑定vm组件实例
import {outerFn} from './Modules'
methods:{
    fn1(){
        this.fn2() // 可调用，this绑定vm实例
    },
   	fn2(){
        function fn3(){
            this.fn1()
        }
        
        fn3() //子函数fn3无法调用fn1，因为fn3是直接执行的等于是全局环境，this指向undefined
        let fn4 = () => {
            this.fn1()
        }
        fn4() // 子函数fn4可以调用到fn1, 因为箭头函数this捕获上下文，this指向上一层，即vm实例
    },
    fn8(){
        // 调用外部函数本质也是fn3的子函数， 接收一个函数作为参数
        outerFn(function(){
          // 这里无法调用fn1, 原理同fn3，函数作为参数在执行时没有任何绑定，指向undefined
            this.fn1() 
        })
        outerFn(()=> {
            this.fn1() //可以调用，箭头函数捕获了上层环境，this即指向vm实例
        })
    }  
}
```



### this指向测试

```js
var name = "window";
var person = {
  name: "person",
  sayName: function () {
    console.log(this.name);
  }
};
function sayName() {
  var sss = person.sayName;
  // 独立函数调用，没有和任何对象关联
  sss(); // window
  // 关联
  person.sayName(); // person
  (person.sayName)(); // person
 //(b = person.sayName) 表达式的结果是function(){console.log(this.name)} 即直接执行了这个函数
  (b = person.sayName)(); // window  
}

sayName();

```

### js中()的作用

小括号的作用就是**执行单个或多个表达式**，并返回最后一个表达式的值,多个表达式之间需要用逗号“,”分隔开。

```js
var a= (1,2,3,4,5)
console.log(a) // 打印5
```



### 高级css技巧

手写单选“点”特效 需把样式绑定到vux-checker组件的default-item-class和selected-item-class属性

![image-20220607103300064](D:\typora-img\image-20220607103300064.png)

```less
/*未选中 外层圈*/
.aui-radio-inner {
  padding-right: 3px;
  border: 1px solid #dcdfe6;
  border-radius: 100%;
  width: 14px;
  height: 14px;
  background-color: #fff;
  position: relative;
  cursor: pointer;
  display: inline-block;
  box-sizing: border-box;
/*内层小点，利用scale(0)先隐藏*/
  &::after {
    width: 4px;
    height: 4px;
    border-radius: 100%;
    background-color: #fff;
    content: "";
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%) scale(0);
    transition: transform .15s ease-in; //对transform的scale实现过渡效果
  }
}
/*选中状态*/
.aui-radio-selected {
  .aui-radio-inner {
    border-color: #1C84FD;
    background: #1C84FD;
/*scale(1)显示内层小点*/
    &::after {
      transform: translate(-50%, -50%) scale(1);
    }
  }
}
```



### window全局属性挂载

```js
// 暴露第三方接口能力
(function (root) {
    var SENGRUI = {
        // 读取证件
        readCard: function (callback) {
            service.readCard(callback)
        },
        // 打开摄像头
        openCamera: function (params, callback) {
            service.openCamera(params, callback)
        },
        // 关闭摄像头
        closeCamera: function (params, callback) {
            service.closeCamera(params, callback)
        },
        // 拍摄照片
        takePhoto: function (params, callback) {
            service.takePhoto(params, callback)
        },
        // 小键盘
        keyboard: function (callback) {
            service.keyboard(callback)
        }
    }
    root.SENGRUI = SENGRUI  // window.SENGRUI = SENGRUI 挂载到全局window对象上暴露出去
})(window)
```



### 组件使用v-model

```vue
<!--默认情况v-model 使用 modelValue 作为 prop 和 update:modelValue 作为事件。
可以通过向 v-model 传递参数来修改这些名称：-->
<my-component v-model:title="bookTitle"></my-component>

<!--子组件将需要一个 title prop 并发出 update:title 事件来进行同步：-->
app.component('my-component', {
  props: {
    title: String
  },
  emits: ['update:title'],
  template: `
    <input
      type="text"
      :value="title"
      @input="$emit('update:title', $event.target.value)">
  `
})
```



### v-bind v-on指令使用动态参数

```vue
<a v-bind:[attributeName]="url"> ... </a>
<a v-on:[eventName]="doSomething"> ... </a>

//缩写
<a :[key]="url"> ... </a>
<a @[event]="doSomething"> ... </a>
```



### Math.pow()

Math.pow(底数, 几次方)

Math.pow(a, 3) 即等于求a的3次方

### JS数值储存原理

**明确概念：将数字转换为科学计数法，科学计数法小数点前必是1，所以不占位，小数部分即为尾数位，表示该数字的精度**

![image-20230228152656773](D:\typora-img\image-20230228152656773.png)

JS的Number类型是双精度浮点型,  64位的二进制**(1个符号位，11个指数位，52个有效数字位（尾数位）)**

举个例子，对于数-10.625来说，如果用单精度浮点型来存储它**（1个符号位，8个指数位，23个有效数字位（尾数位））**：
① 先把10.625转为二进制数 = 1010.101
② 科学计数法：1010.101 = 1.010101 * 2^3 ----这里的3就对应指数位E，有效数字位M对应010101
(这里需要说明，因为是二进制存储，所以每位的数字只会是0或1，在用科学计数法表示时，第一位必是1，所以有效数字位M不记录小数点前面的那个数字1)
③ 符号位为1bit，为1是代表负数，为0代表正数

也就是说：
S–1
E–1000 0010
M–0101 0100 0000 0000 0000 000

这里特别说明一下E的取值，在②中已经得到指数为3，但指数的值有正有负(比如0.0001的指数就为负)。E为8bit，存储数组范围是0-255。

这里在存储时，将0-127的值用来代表负值，128-255的值来代表正值——比如指数值=-1，表现为E=127-1=126(0111 1110)，指数值为1，E=127+1=128(1000 0000)。所以指数为3时，E=127+3=130(1000 0010)。



例：存储8.8125

8.8125 二进制=> 1000.1101 => 科学计数法 =>  1.0001101 * 2^3

符号位S: 0 表示正数

指数位E: 3 双精度指数范围0~2047 (2^11)  1023是中间数 所以指数位是1023+3 = 1026 二进制后等于10000000010

尾数位M: 0001101

![image-20230228161340817](D:\typora-img\image-20230228161340817.png)

### JS精度丢失问题

原因：JS的Number类型是双精度浮点型，即64位二进制(1个符号位，11个指数位，52个有效数字位)

储存小数时，是把十进制转化为二进制储存的，当有无穷小数时，计算机会舍去部分，造成精度丢失

可以发现，0.1和0.2转成二进制之后都是一个无限循环的数，前面提到尾数位只能存储最多53位有效数字，这时候就必须来进行四舍五入了，最终的这个二进制数转成十进制就是0.30000000000000004。

用一句话来概括就是，计算机中用二进制来存储小数，而大部分小数转成二进制之后都是无限循环的值，因此存在取舍问题，也就是精度丢失。

 十进制(0.1) =>二进制 (00011001100110011001(1001)...)

 十进制(0.2) => 二进制(00110011001100110011(0011)...)

```js
0.1 + 0.2 // 0.300000000004
```



二进制的第一位有效数字必定是1，因此这个1不会被存储，可以节省一个存储位，因此尾数部分可以存储的范围是1 ~ 2^(52+1)，也就是说Number能表示的最大数字绝对值范围是 2^-1074 ~ 2^(53+971)  => 5e-324~1.7976931348623157e+308，可以通过Number.MAX_VALUE和Number.MIN_VALUE来得到证实。同样可以通过Number.MIN_SAFE_INTEGER和Number.MAX_SAFE_INTEGER 证实安全整数的范围。

```js
// 0.58*100 = 0.57999999 浮点型数据精度丢失问题
// 解决方案：两数去小数点后相乘,再除以两数的平方数之和 
function mul (arg1, arg2) {
    let m = 0
    let s1 = arg1.toString()
	let s2 = arg2.toString()
    // 求2个数的小数点后位数之和
	try {m += s1.split('.')[1].length} catch(e) {} 
    try {m += s2.split('.')[1].length} catch(e) {}
    // 两数去掉小数点相乘， 再除以两数的平方和
    return Number(s1.replace('.', '')) * Number(s2.replace('.', '')) / Math.pow(10, m)
}
```



### 复杂三元运算符顺序

```js
// 核心思想是先计算出左侧表达式是true//false，最后再用三元进行判断 
let x = false
// 1. 先计算123===456结果  2.再计算||结果 即： ( true || false) ? 'ddd' : 'xxx'  
let y = x || 123 === 456 ? 'ddd' : 'xxx'  // 结果：y='xxx'

let z = true
let res = z || 123 === 456 ? 'hhh' : 'kkk' // res = 'hhh'

// sessionStorage实例
get(key) {
    return !sessionStorage.getItem(key) || sessionStorage.getItem(key) === 'undefined' ? undefined : JSON.parse(sessionStorage.getItem(key))
}
```



### new Set()

类似于数组，它的一大特性就是所有元素都是唯一的，没有重复的值，我们一般称为集合，Set本身是一个构造函数，用来生成 Set 数据结构

使用场景：
**数组去重、字符串去重、实现并集、交集、和差集**

```js
// 增删改查
// 1.添加元素---add()
let list = new Set([1,2,3,3,3,4])
list.add(3)
list.add(5).add(6) //  Set对象：{1,2,3,4,5,6}  3只被添加1次

// 2.删除元素---delete()
let list = new Set([30,40])
list.delete(30) // true 有返回true,没有返回false
console.log(list) // {40}

// 判断元素存在---has()
let list=new Set([1,2,3,4])
list.has(2)   // 有返回true，没有返回false

// 清除所有元素---clear()
let list=new Set([1,2,3,4])
list.clear()
console.log(list)    // {}

// 3.遍历--- keys()/values()/entires() / forEach()
let list2 = new Set(['a','b','c'])
// 返回键名的遍历，相当于返回键值遍历values()
for (let key of list2.keys()) {
    console.log(key) // a,b,c
}
for (let value of list2.values()) {
    console.log(value) // a,b,c 
}
// 返回键值对遍历器
for (let item of list2.entires()) {
    console.log(item) // ['a','a'], ['b','b'], ['c','c']
}
// forEach函数遍历每个成员
list2.forEach((value, key) => console.log(key + ':' + value)) // a:a b:b c:c


// 使用场景1： 数组去重
let arr = [1,2,3,4,5,5,5]
let setArr = new Set(arr)
let arr2 = [...setArr] // 解构转数组
// 方法2
let arr2 = Array.from(setArr) //使用from()解析类数组为数组

// 字符串去重
let str = 'davidddddd'
let setStr = new Set()
let str2 = [...setStr].join('') //davi
```



### new Map()

map是键值对的有序列表，**键和值都可以是任意类型**

map和set区别：set是一种类数组的数据结构， map是一种字典的数据结构

Set集合是以**[值，值]**的形式存储元素，
Map字典是以**[键，值]**的形式存储

```js
// 声明赋值
const person = new Map([['name', 'david'], ['age', '34']]) // 必须是二维数组
// 声明后赋值--set()
const person = new Map()
person.set('name', 'david')
// 获取数据--get()
person.get('name')
// 删除数据--delete()
person.delete('name')
// 删除所有数据--clear()
person.clear()
// 判断是否包含数据--has()
person.has('name') // true
// 遍历数据
person.forEach((item, key) => {
    console.log(item, key) // david name '34' age
})
for (let [key, value] of person.entires()) {
    console.log(key,value)
}

// 使用场景
const fruitColor = new Map()
    .set('red', ['apple', 'strawberry'])
    .set('yellow', ['banana', 'pineapple'])
    .set('purple', ['grape', 'plum']);
 
function printFruits(color) {
  return fruitColor.get(color) || [];
}
 
// 调用
printFruits('red')  // ['apple', 'strawberry']
```



### JSON字符串转义符“\”

```js
// js编译器会默认把字符串的双引号变成单引号
let str = "david" // str -> 'david'
```

结论：JSON.stringify()方法总会把js字符串最外层单引号变成双引号

'aaa"bbb"ccc' 本质上等于 "aaa\\"bbb\\"ccc" ，所以JSON后会有'\\\\'双转义符

```js
// 为什么会出现“\\”双斜杠转义符? --> 外单内双：字符串外层使用了单引号
let str1 = 'aaa"bbb"ccc'
// 1. str1最外层单引号会被转化为双引号变成-->"aaa\"bbb\"ccc"
// 2. "aaa\"bbb\"ccc" ---> '"aaa\\"bbb\\"ccc"'
let json1 = JSON.stringify(str1)
// 全双引号 上同
let str2 = "aaa\"bbb\"ccc" // 解析：'aaa"bbb"ccc'  JSON--> '"aaa\\"bbb\\"ccc"'

// 外双内单
let str3 = "aaa'bbb'ccc" // 解析: "aaa'bbb'ccc" JSON--> `"aaa'bbb'ccc"` 
// 全单引号 上同
let str4 = 'aaa\'bbb\'ccc' // 解析: "aaa'bbb'ccc" JSON--> `"aaa'bbb'ccc"` 
```

### scoped标签作用

```vue
<style scoped>
	.a .b .c { //多层
	   color:red
	 }
</style>
// 上述代码将编译成 
.a .b .c[data-v-2311c06a]{
  color:red
}

<style scoped>
	.a >>> .b { /* ... */ }
</style>
// 上述代码将编译成 
.a[data-v-f3f3eg9] .b { /* ... */ }
```



### 生成代码片段

方便直接生成反复要写的代码

1.复制要生成代码片段的代码

2.https://snippet-generator.app/ 网站生成代码片段

3.在vsCode中配置代码片段(**文件-首选项-配置用户代码片段**)



### webpack易混淆路径

- **assetsRoot**:打包后文件存放的路径
- **assetsSubDirctory**：除了index.html之外的静态资源要存放的路径
- **assetsPublicPath**: 代表打包后，index.html里面引用资源的相对地址



### __dirname含义

指向当前文件执行的所在路径，**是一个绝对路径**

例: 

文件test.js存放在C:\Users\yoki\Desktop  当使用node test.js运行该文件时，**__dirname = C:\Users\yoki\Desktop** 

![image-20230117094351679](D:\typora-img\image-20230117094351679.png)

![image-20230117094418531](D:\typora-img\image-20230117094418531.png)



### process.env含义

在node中，全局变量process表示的是当前的node进程
process.env包含着关于系统环境的信息，但是process.env中并不存在NODE_ENV这个东西

NODE_ENV是一个用户自定义的变量，在webpack中它的用途是**判断生产环境或开发环境**

如何查看process

1.打开cmd，输入node，进入node编辑模式

2.输入process，就会展示process的所有属性



### process.env.NODE_ENV

npm run-script <command> [-- <args>...]

语法糖 npm run <command> [-- <args>...]

**npm执行命令 npm run build -- prod** 

-- 后面代表给npm run 传参, 这个参数会放到node全局变量process.argv数组中

```js
// webpack打包时对NODE_ENV赋值的关键语句 获取argv中的参数
const args = process.argv.splice(2)
const env = args[0]
process.env.NODE_ENV = env
```

**传多个参数**

**npm run build -- david kashin **

process.argv会返回一个数组，这个数组包含了启动Node.js进程时的命令行参数

例如：

输入命令: node scripts/build.js "web-runtime-cjs,web-server-renderer"

console.log(process.argv[0])   // C:\nodeJs\node.exe

console.log(process.argv[1])   // C:\yoki\desktop\scripts\build.js

console.log(process.argv[2])   //  web-runtime-cjs,web-server-renderer



**方法2:使用npm_config环境变量传参(适合传键值对)**

```js
// npm run build --abc=sit


//vue.config.js
console.log(process.env.npm_config_abc) // sit
```





### 闭包高级

fn.apply本质上是用来给传入的**fn**回调函数传参的

```js
// 定义闭包函数
const limitFunction = (fn, timeout) => {
  let lastExec = 0
  return function () {
    let now = +new Date()
    if (now - lastExec < timeout) return
    lastExec = now
      // 闭包返回函数的参数arguments，绑定到回调fn上
    fn.apply(this, arguments)
  }
}

// 定义闭包返回函数  回调fn的入参arg123在Fn2()执行时会被apply绑定到fn上
const Fn2 = limitFunction((arg1, arg2, agr3) => {
    // 此处定义回调函数fn
}, 1000)

// Fn2()执行时传入的参数，会被绑定到fn回调函数中执行
Fn2('aaa', 'bbb', 'ccc')
```

### 闭包陷阱

```js
function foo(name) {
    return function(){
        console.log(name)
    }
}
const bar1 = foo('david')
bar1() // david

const bar2 = foo('kashin')
bar2() // kashin

bar1() // 此时再调用bar1, 打印的依然是david, 因为第一次定义时bar1捕获的外层作用域值是david
```



### es6模板字符串调用函数

模板字符串也可以调用函数

```js
function foo(...args){console.log(args)}
// 普通函数调用
foo('david', 34) // ['david', 34]


// 模板字符串调用函数
foo``
// 传参调用，会解析传入的模板字符串和动态值 
let name = 'kashin', age = 100
// 字符串会被切割后作为第一个参数，并放在一个数组中，动态值name,age则会依次作为后面的参数传入
foo`name is ${name}, age is ${age}` // [['name is',', age is', ''], 'kashin', 100] 
```



### 纯函数概念

确定的输入，一定会产生确定的输出

函数在执行过程中不能产生副作用



### export （命名导出）

命名导出可以导出多个值，但是导入时命名需要与导出命名相同。

```js
export {myFunction};//命名导出函数

export const value=5;//命名导出原始值

export {object1, object2, ....}; //命名导出对象
```

### export default（默认导出）

**export default <expression>   本质是导出表达式的值，并赋值给default**

**默认导出后面不能跟声明语句**

**一个模块只能有一个默认导出**

****

```js
//module.js
const val = 1;
export default val // 默认导出不能声明变量，例如export default const val = 1 报错！

//invoke.js

import res from 'module.js';
```

### export {Name} from ...(重定向导出)

从某一个文件中导出模块，多用于模块重定向

```js
export * from '../module.js';

export {default} from '../module.js';// 导出默认模块

export {default as XXX} from '../module.js' // 重命名导出默认模块
```



### import * as XX from ...  

导入所有对象，包括默认导出的对象，需要指定命名空间



### 数组解构

```js
//解构赋值都是一一对应的，按照顺序
const arr = [200,300,400]
const [a,b,c] = arr
console.log(a,b,c) // 200,300,400

//也可以取数组的某一项值(结构必须保持一致)
const arr = [200,300,400]
const [, , c] = arr
console.log(c) // 400


const arr = [200,300,400]
const [a,...all] = arr
console.log(all) // [300,400] 会返回得到一个最后所有的数组

const arr = [200,300,400]
const [a] = arr
console.log(a) // 200 按顺序提取第一个
```

### 对象解构

**对象解构和数组解构基本类似，只不过对象解构的取值方式是根据对象的属性名来取值**

```js
const obj = {name:'100',age:'30',size:'M'}
const { name } = obj
console.log(name) // 100

const obj = {name:'100',age:'30',size:'M'}
const name = 'lucy'
const {name} = obj
console.log(name) // 会报错
 
 
// 要么重新命名，要么可以按照下面的写法来避免
const obj = {name:'100',age:'30',size:'M'}
const name = 'lucy'
const {name：nameObj} = obj // 对象属性名称的重新指定
console.log(nameObj) // 100
```

### 号码搜索高亮案例

```js
// 这种方法才能完全匹配137 3222 0969这种有空格的号码，replace只能匹配到子正则
phoneColorLucky (value, match) {
      let result = ''
      let index = value.RES_NUM.indexOf(match)
      for (let i = 0; i < 11; i++) {
        if ([3, 7].indexOf(i) > -1) {
          result += `&nbsp;`
        }
        if (index > -1 && i >= index && i < index + match.length) {
          result += `<span style="color:#409EFF;">${value.RES_NUM.slice(i, i + 1)}</span>`
        } else {
          result += `${value.RES_NUM.slice(i, i + 1)}`
        }
      }
      return result
    }
```



### a标签重要属性

**download:**  h5新增属性，可以使a标签的href属性用来下载，download属性为下载后的文件名

**target：**

_top（在整个窗口打开） | _parent（父窗口打开） | _self(默认，当前框架打开) | _blank（新窗口打开）

**href:**

1.打开指定页面 

2.打开指定文件资源 

3.唤起应用 

4.锚点跳转 

5.打开本地资源目录

```html
<!-- 下载资源 -->
<a href="../../assets/img/213.png" download="img" target="_blank"> 下载图片， 重命名为img</a>
<!-- 打开指定文件资源， 不加download默认为预览 -->
<li><a href="./image/1.jpg">打开指定文件资源 1.jpg</a></li>
<!-- 打开本地资源 -->
<li><a href="file:\\\C:\qingshan\">打开本地资源目录</a></li>
<!-- 唤起QQ -->
<li><a href="tencent://message/?Menu=yes&uin=1434154130" data-type="qq">唤起QQ</a></li>
```



### 打开电脑摄像头/拍摄照片

```js
openCamera: function (params, callback) {
  try {
    // 获取要创建的节点
    const videoDiv = document.getElementById(params.divId)
    const video = document.createElement('video')
    video.width = params.videoW
    video.height = params.videoH
    videoDiv.appendChild(video)
    if (navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices.getUserMedia({
        video: {width: params.videoW, height: params.videoH}
      }).then(MediaStream => {
        // 浏览器兼容处理
        if ('srcObject' in video) {
          video.srcObject = MediaStream
        } else {
          video.src = window.URL.createObjectURL(MediaStream)
        }
        this.MediaStreamTrack = typeof MediaStream.stop === 'function' ? MediaStream : MediaStream.getTracks()[0]
        video.play()
        callback({code: '000000', message: '成功'})
      })
    }
  } catch(err) {
    callback({code: '000001', message: err})
  }
}
// 关闭摄像头
closeCamera: function (params, callback) {
  const videoDiv = document.getElementById(params.divId)
  videoDiv.innerHTML = ''
  this.MediaStreamTrack && this.MediaStreamTrack.stop()
  callback({code: '000000', message: '成功'})
},
// 拍摄照片
takePhoto: function (params, callback) {
  const videoDiv = document.getElementById(params.divId)
  const video = videoDiv.firstElementChild
  const canvas = document.createElement('canvas')
  canvas.width = params.videoW
  canvas.height = params.videoH
  const ctx = canvas.getContext('2d')
  ctx.drawImage(video, 0, 0, params.videoW, params.videoH)
  callback({code: '000000', message: '成功', data: canvas.toDataURL('image/jpeg')})
}
```





### activated生命周期

**这个生命周期只在包裹了keep-alive属性的组件内生效**

切换路由时，有缓存的时候created和mounted不会执行， activated钩子会执行



### SSR(服务器端渲染Server Side Rendering)

含义：服务端渲染好整个html页面，浏览器请求的index.html是一个完整的页面

当前主流是客户端渲染(CSR Client Side Rendering)，即SPA（单页面富应用），但SPA有2个缺点

**1.SEO优化问题**

单页应用在请求服务器时返回的是一个index.html页面，且里面没有任何内容(一般都是这种：<div id="app"></div>)

而百度这种搜索引擎爬虫一般只会爬index.html， 会导致搜索排位靠后

**2.首屏渲染速度问题**

上面的index.html请求到以后，里面会引用bundle.js， 这时候就会请求bundle.js, 而这个文件通常很大，浏览器需要运行js代码，会导致首屏渲染速度不如ssr



SSR渲染流程

![image-20230129001853943](D:\typora-img\image-20230129001853943.png)

服务端通过node执行js 输出html页面，直接给浏览器返回完整的Html页面

node执行==> Vue/React SSR-API ==> nuxt/next框架

**同构应用（一套代码可以在服务端和客户端都运行）**

同构是一种SSR形态，是现代SSR的一种表现形式

![image-20230129133444509](D:\typora-img\image-20230129133444509.png)

当用户发出请求时，现通过ssr渲染首页内容，ssr渲染的是一个html字符串，仅做展示没有交互能力(例如按钮点击onClick函数绑定)，对应的代码需要客户端同步执行，注入交互能力

![image-20230129133506727](D:\typora-img\image-20230129133506727.png)





### Promise工具函数创建

```js
// 拷贝一个promise对象，并且抽取了promise中的resolve,reject方法，放到自己的属性中
// 作用：可以做一些异步调用，例如登录后要进行的一些逻辑处理
var createCapability = function(){
    var capability = {};
    capability.promise = new Promise(function(resolve,reject){
        capability.resolve = resolve;
        capability.reject = reject;
    });
    return capability;
}
// 使用:
const capability = createCapability()

fn1() {
   	Promise.all([bdeControl.promise]).then(function () {
        return bdeControl.StartFlowManager(xmlStr)
      }).then(function (data) {
        capability.resolve(data) // 调用自己的resolve方法,下面返回的promise就会变成resolve状态
      })
      return capability.promise  // 返回promise 
}

this.fn1().then(data => console.log(data)) // 这里就可以拿到capability对象resolve的data,做一些异步操作

```



### 数组entries方法

entries() 方法返回一个数组的迭代对象，该对象包含数组的键值对 (key/value)。

迭代对象中数组的索引值作为 key， 数组元素作为 value

```js
var fruits = ["Banana", "Orange", "Apple", "Mango"];
var x = fruits.entries();
x.next().value //0,Banana
x.next().value //1,Orange
x.next().value //2,Apple

```



### new WebSocket

是一种服务端和客户端的双向通信协议，解决http请求需要一直轮询，实时性差的缺点

一旦握手后会一直保持连接状态，除非主动断开

服务端可主动下发消息

```js
// 浏览器提供了原生类WebSocke, 使用new进行实例化
// 接收2个参数：1.链接地址， 2.可选参数,一个字符串或数组 用来表示子协议
WebSocket(String url, optional String | [] protocols)
let ws = new WebSocket('ws://echo.websocket.org')
```

**webSocket实例监听的事件：**

**open**：链接打开的回调，这时readyState变为OPEN

**message**: 收到消息的回调，同事回调函数收到一个MessageEvent数据

**close**: 链接关闭的回调，这时readyState变为CLOSED

**error**: 建立连接过程中发生错误的回调



**webSocket的方法**

**send**: 使用链接发送数据

**close:** 关闭连接，一般在页面卸载时调用

```js
//首先触发 open 事件，之后每次发送数据服务端都会回复数据，因此触发了 message 事件
//如果触发 close 事件；这里最后一次发送之后未收到服务端回复也是因为客户端立即断开了连接
//websocket.send()是发送信息方法

// ws完整流程
const ws = new WebSocket('ws://echo.websocket.org')
ws.onopen = function() {
    console.log('websocket open!')
}
// 结束链接
ws.onclose = function() {
    console.log('websocket close!')
}
// 接收信息
ws.onmessage = function(e) {
    console.log(e.data)
}
// 发送信息
var xxDom = document.getElementById('app')
xxDom.onClick = function() {
    ws.send('hello david!')
}

```



### vue实现图片打包下载

利用file-saver和jszip两个插件

```js
import JSZip from 'jszip'
import FileSaver from 'file-saver'

// 前提是已经获得了base64的图片流
download () {
  let zip = new JSZip()
  let imgList = []
  for (let item of this.names) {
    if (!CommonUtils.isEmpty(this.img[item.key])) {
      imgList.push({
        name: `${item.value}(${this.ID_NR}).jpg`,
        data: this.img[item.key]
      })
    }
  }
  for (let item of imgList) {
    zip.file(item.name, item.data, {base64: true})
  }
  let zipName = '反诈实名照片数据' + this.ID_NR + '.zip'
  zip.generateAsync({type: 'blob'}).then(content => {
    FileSaver.saveAs(content, zipName)
  })
}
```



### base64图片转二进制下载

```js
// base64转成二进制， 再转成blob URL下载
saveImg (data, fileName) {
  let bytes = window.atob(data)
  let byteNumbers = new Array(bytes.length)
  for (let i = 0; i < bytes.length; i++) {
    byteNumbers[i] = bytes.charCodeAt(i) // 字符串转ArrayBuffer
  }
  let byteArray = new Uint8Array(byteNumbers) // 创建类型数组的DataView视图，存放二进制数据
  let blob = new Blob([byteArray], {type: undefined})
  let link = document.createElement('a')
  link.style.display = 'none'
  link.href = URL.createObjectURL(blob)
  link.setAttribute('download', fileName)
  link.click()
  URL.revokeObjectURL(blob)
}
```



### 列表回显

```javascript
takePhoto () {
  deviceService.takePhoto({
    ...this.camera,
    photoType: 'jpeg'
  }, res => {
    let bytes = window.atob(res.data.replace('data:image/jpeg;base64,', ''))
    let ab = new ArrayBuffer(bytes.length) // 创建类型数组，分配内存空间
    let ia = new Uint8Array(ab) // 创建ab的数组视图
    for (let i = 0; i < bytes.length; i++) {
      ia[i] = bytes.charCodeAt(i)
    }
    let file = new File([ab], `${sessionService.getLoginOperator().operatorId}${moment().format('YYYYMMDDHHmmssSSS')}.jpeg`, {type: 'image/jpeg'})
    file.status = 'ready'
    file.uid = new Date().getTime()
      // 图片列表回显到upload组件上
    this.$refs.upload.uploadFiles.push({
      name: file.name,
      percentage: 0,
      raw: file,
      size: file.size,
      status: file.status,
      uid: file.uid
    })
  })
},
```





### excel文件回显

```js
handleChange (file, fileList) {
      let self = this
      if (fileList.length > 1) {
        fileList.shift()
      }
      let suffix = file.name.split('.')[1]
      if (suffix !== 'xlsx') {
        this.$message({
          type: 'warning',
          message: '文件格式错误，必须是xlsx格式文件'
        })
        return
      }
      this.MEMBERS = []
      this.fileName = ''
      const reader = new FileReader()
      reader.readAsArrayBuffer(file.raw)
      reader.onload = function () {
        const buffer = reader.result
        const bytes = new Uint8Array(buffer)
        const length = bytes.byteLength
        let binary = ''
        for (let i = 0; i < length; i++) {
          binary += String.fromCharCode(bytes[i])
        }
        const XLSX = require('xlsx')
        const wb = XLSX.read(binary, {type: 'binary'}) // 转换二进制
        const outData = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]])
        if (outData && outData.length > 5000) {
          self.$message({
            type: 'error',
            message: '最多只能上传5000条数据，请修改后重新上传！'
          })
          return
        }
        self.fileName = file.name
        outData.forEach((item) => {
          let obj = {
            NO: item.序号,
            IDEN_TYPE: item.证件类型,
            IDEN_NR: item.证件号
          }
          self.MEMBERS.push(obj)
        })
      }
    }
```



### ArrayBuffer

**HTML5中引入的类型化数组，用来解决JS处理二进制数据的问题**

`ArrayBuffer`对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（`TypedArray`视图和`DataView`视图)来读写，视图的作用是以指定格式解读二进制数据

**简单说：ArrayBuffer代表原始的二进制数据，视图用来读写二进制数据，视图的作用就是用指定的格式来解读二进制数据**

- 每个ArrayBuffer对象表示的只是内存中指定的字节数;
- 但不会指定这些字节用于保存什么类型的数据；
- 通过ArrayBuffer能做的，就是为了将来使用而分配一定数量的字节.



**ArraryBuffer的参数表示字节个数，不是数组长度；**

**类型数组通过长度创建时，参数表示的是数组长度。注意不要混淆**

```js
// 创建一个8byte内存空间的的ArrayBuffer
var b = new ArrayBuffer(8) // b.byteLength=8
// 创建一个指向b的int32类型视图,起始位置0，结束位置在缓冲区尾部
var v1 = new Int32Array(b)
// 创建一个指向b的Uint8类型视图,起始位置2， 结束位置在缓冲区尾部
var v2 = new Uint8Array(b, 2)
// 创建一个指向b的Int16类型视图, 起始位置2，总长度2
var v3 = new Int16Array(b,2,2)
```

ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。

`ArrayBuffer`实例的`byteLength`属性，返回所分配的内存区域的字节长度。

它是一个字节数组，通常在其他语言中称为“byte array”。

你不能直接操作 ArrayBuffer 的内容，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。



### 类型化数组

`Uint8Array`是JavaScript中的一种类型化数组。它提供了一种用于表示8位无符号整数的固定长度的数组，可以让你更轻松，更高效地操作二进制数据。

`Uint8Array`的创建可以使用以下语法：

```javascript
// 通过长度创建一个空数组
var myUint8Array = new Uint8Array(length);

// 通过数组字面量创建
var myUint8Array = new Uint8Array([element0, element1, ..., elementN]);

// 通过TypedArray创建
var myUint8Array = new Uint8Array(typedArray);

// 通过ArrayBuffer创建
var myUint8Array = new Uint8Array(buffer [, byteOffset [, length]]);
```





#### 数组缓冲器视图DataView

**ArrayBuffer可以存放多种类型的数据，而不同类型的存储方式就是DataView**

使用ArrayBuffer（数组缓冲器类型）的一种特别的方式就是用它来创建数组缓冲器视图。
其中，最常见的视图是DataView，通过它可以选择ArrayBuffer中的一小段字节。
为此，可在创建DataView实例的时候传入一个ArrayBuffer、一个可选的字节偏移量（从该字节开始选择）和一个可选的要选择的字节数。

DataView的类型如下：
Int8Array：8位有符号整数，长度1个字节。（-128~127）
Uint8Array：8位无符号整数，长度1个字节。（0~255）
Int16Array：16位有符号整数，长度2个字节。（-32768,32767）
Uint16Array：16位无符号整数，长度2个字节。（0~65535）
Int32Array：32位有符号整数，长度4个字节。（-2147483648~2147483647）
Uint32Array：32位无符号整数，长度4个字节。（0~4294967295）
Float32Array：32位浮点数，长度4个字节。
Float64Array：64位浮点数，长度8个字节。

类型化视图一般也被称为类型化数组，因为它们除了元素必须是某种特定的数据类型外，与常规的数组无异。而且它们**都继承了DataView**。

ArrayBuffer对象并没有提供任何读写内存的方法，而是允许在其上方建立“视图”，从而插入与读取内存中的数据

|          | ArrayBuffer                    | Uint8Array数组                         |
| -------- | ------------------------------ | -------------------------------------- |
| 存储内容 | 放0和1组成的二进制数据         | 放数字、字符串、布尔值以及对象和数组等 |
| 存储位置 | 数据放在栈中（所以取数据较快） | 放在堆中                               |
| 存储大小 | 初始化后固定大小               | 数组则可以自由增减                     |

```js
var arrayBuffer = new ArrayBuffer(8) // 实例化时需要传入字节数
arrayBuffer.byteLength // 8

var int8a = new Int8Array(arraybuffer)
ArrayBuffer.isView(int8a) // return true  类方法，判断某对象是否为视图
```



### window.atob

atob() 方法用于解码使用 base-64 编码的字符串

```js
let str = 'RUNOOB'
let encode = window.btoa(str) // 编码后字符串: UlVOT09C
let decode = widnow.atob(encode) // 解码后字符串: RUNOOB
```



### 重绘16：9图片

```js
// 读取图片文件
const reader = new FileReader();
reader.onload = function(event) {
  const img = new Image();
  img.onload = function() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    // 计算宽高比
    const ratio = img.width / img.height;

    // 如果宽高比小于16:9，则进行填充
    if (ratio < 16 / 9) {
      const targetWidth = img.height * 16 / 9;
      canvas.width = targetWidth;
      canvas.height = img.height;

      // 计算需要填充的宽度
      const padding = (targetWidth - img.width) / 2;

      // 在画布上绘制图片
      ctx.drawImage(img, padding, 0, img.width, img.height);

      // 将画布保存为16:9的图片
      canvas.toBlob(blob => {
        saveBlob(blob, 'image.png');
      });
    }
    // 如果宽高比大于16:9，则进行裁剪
    else if (ratio > 16 / 9) {
      const targetHeight = img.width * 9 / 16;
      canvas.width = img.width;
      canvas.height = targetHeight;

      // 计算需要裁剪的高度
      const clipping = (img.height - targetHeight) / 2;

      // 在画布上绘制裁剪后的图片
      ctx.drawImage(img, 0, clipping, img.width, targetHeight, 0, 0, img.width, targetHeight);

```



### canvas特性

canvas与普通img对比
Canvas是块级元素，img是空元素(canvas标签必须使用 （这里定义替换内容，当不支持canvas时进行显示，可以省略）)
canvas是具有默认宽高的 width:300px，height:150px；
canvas没有src和alt，其实canvas默认只有width和height两个元素

<canvas> 标记和 SVG以及 VML 之间的一个重要的不同是，<canvas> 有一个基于 JavaScript 的绘图 API，而 SVG 和 VML 使用一个 XML 文档来描述绘图。

```js
const canvas = document.getElementById('canvas')
// 大多数 Canvas 绘图 API 都没有定义在 <canvas> 元素本身上，而是定义在通过画布的getContext() 方法获得的一个“绘图环境”对象上。
const ctx = canvas.getContext('2d')
ctx.drawImage()
ctx.fillRect(0,0,80,100)
```



### svg特性

svg:矢量图(进行缩放不失真)
svg用途: SVG 是用于描述矢量图像的XML语言。 它基本上是像HTML一样的标记，只是你有许多不同的元素来定义要显示在图像中的形状，以及要应用于这些形状的效果。 SVG用于标记图形，而不是内容。 非常简单，你有一些元素来创建简单图形，如 和 。更高级的SVG功能包括 （使用变换矩阵转换颜色） （矢量图形的动画部分）和 （在图像顶部应用模板）

**与img对比优点**

将 SVG 内联减少 HTTP 请求，可以减少加载时间
可以为 SVG 元素分配class和id，并使用 CSS 修改样式，无论是在SVG中，还是 HTML 文档中的 CSS 样式规则。 实际上，您可以使用任何 SVG外观属性 作为CSS属性。
内联SVG是唯一可以让您在SVG图像上使用CSS交互（如:focus）和CSS动画的方法（即使在常规样式表中）。
可以通过将 SVG 标记包在a元素中，使其成为超链接。

**与img对比缺点**

- 直接使用svg标签这种方法只适用于在一个地方使用的SVG。多次使用会导致资源密集型维护
- 额外的 SVG 代码会增加HTML文件的大小。
- 浏览器不能像缓存普通图片一样缓存内联SVG





### Blob转json对象

二进制文件请求失败时，因为请求的是blob，所以要获取返回的错误提示，需要把blob转成json对象

```js
const reader = new FileReader();
reader.readAsText(res.data, 'utf-8');
reader.onload = function () {
  const t = JSON.parse(reader.result as string);  // 这里就得到了json
}
```



### 时间前补0小算法

```js
// 时间前补0
function padLeft(time) {
  time = time.toString() // 转成字符串
  return ('00' + time).substring(time.length)
}
```



### script setup 使用模板引用细节

如果一个子组件使用的是选项式 API 或没有使用 `<script setup>`，被引用的组件实例和该子组件的 `this` 完全一致，这意味着父组件对子组件的每一个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，当然也因此，应该只在绝对需要时才使用组件引用。大多数情况下，你应该首先使用标准的 props 和 emit 接口来实现父子组件交互。

有一个例外的情况，使用了 `<script setup>` 的组件是**默认私有**的：一个父组件无法访问到一个使用了 `<script setup>` 的子组件中的任何东西，除非子组件在其中通过 `defineExpose` 宏显式暴露：

```vue
<script setup>
import { ref } from 'vue'

const a = 1
const b = ref(2)

// 像 defineExpose 这样的编译器宏不需要导入
defineExpose({
  a,
  b
})
</script>
```



### Grid布局

**grid-template-columns:定义列宽，grid-template-rows定义行高；**接收repeat()函数，auto-fill 关键字，fr 关键字，minmax()函数，auto

**repeat函数：**接收2个参数，第一个参数是重复次数，第二个是重复的值

**auto-fill关键字：**repeat(auto-fill, 100px) 容器宽度不固定，但每个单元格宽度固定，可以使用auto-fill容纳尽可能多的单元格

**fr关键字：** 长度比例关系

grid-template-columns: 200px,1fr表示第一列200px,剩下都是第二列 

grid-template-columns: 200px,1fr,2fr表示第一列200px,第二列占剩下的1/3，第三列占2/3

**minmax函数：**长度范围，接收2个参数，分别为最小值和最大值

grid-template-columns: 1fr,1fr,minmax(100px,1fr) //表示列宽最小100px,最大1fr

**auto关键字：**grid-template-columns: repeat(2,100px)  auto; 由浏览器决定（基于该列单元格所剩的最大宽度）

**gap:** 设置单元格行间距和列间距

**grid-auto-flow：** 单元格默认按“先行后列”排序，设置为column则为“先列后行”排序，即竖着排



**单元格属性：**

列合并，根据垂直网格线

 grid-column-start

 grid-column-end

简写：

grid-column:  <start-col-line> / <end-col-line>



行合并，根据水平网格线

 grid-row-start

 grid-row-end

简写：

grid-row： <start-row-line> / <end-row-line> 

**span关键字：** grid-column-start: span 2; 表示横跨2列 

```scss
.container {
    // 容器属性
    display:grid; // 设置为网格布局
    
    /* grid-template-columns: 200px 200px 200px; */
    /* grid-template-columns: 200px auto 200px; */
    /* grid-template-columns: auto auto auto; */
    /* grid-template-columns: repeat(3,auto); */
    /* grid-template-columns: repeat(3,100px); */
    grid-template-columns: 1fr 3fr 1fr; // 设置列宽
    grid-template-rows: 1fr 2fr 3fr; // 设置行高
    grid-gap: 20px; // 设置子元素间距 可写2个值，表示行间距和列间距，写一个值则一样
    
    
    // 单元格属性
    // 跨列
    .item:nth-of-type(1) {
        grid-column-start: 1   //列从第1根垂直网格线开始
        grid-column-end: 3  // 到第3根网格线结束
        grid-column: 1 / span 3    //从第一根线开始，合并3个单元格
    }
    
    // 跨行
	li:nth-of-type(1){
        /* 行合并 */
        grid-row-start: 1;
        grid-row-end: 4;
        grid-row: 1 / span 4;
    }
}

```

