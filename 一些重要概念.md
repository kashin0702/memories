### 一些重要概念

#### 基本类型和引用类型

基本类型：string number boolean undefined null

引用类型：function object array

1.基本类型按值访问，比较是值的比较，保存在**栈内存中**

2.基本类型赋值是创建一个新值，保存在不同的内存地址中

```js
var a = 10

var b = a 

a === b  //true  值的比较

a++  

console.log(a);  //11

console.log(b); //10
```

1.引用类型拥有属性和方法，引用类型的副本是指向保存在栈内存和堆内存中的一个指针

2.引用类型的比较是引用在**堆内存中地址的比较**

```js
var a = {};

var b = {};

a === b  //false  ab指向不同的内存地址，这两个都是指针

var a = {};

b = a;   

a === b //true  b和a都指向同一个内存地址，此时修改b的值也会影响到a
```

#### typeof 检测

typeof是检测string , number, boolean,undefined的最佳工具，但检测null的话返回的是object，对function的检测不准确（有可能是正则表达式）。

   \1. 'undefined'       --未定义的变量或值

​    \2. 'boolean'         --布尔类型的变量或值

​    \3. 'string'           --字符串类型的变量或值

​    \4. 'number'         --数字类型的变量或值

​	 \5. 'object'          --对象类型的变量或值，或者null(这个是js历史遗留问题，将null作为object类型处理)

​    \6. 'function'         --函数类型的变量或值



作者：zh2443
链接：https://www.jianshu.com/p/8107d25f54ac
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

作者：zh2443
链接：https://www.jianshu.com/p/8107d25f54ac
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#### for/in for/of区别

for in 遍历数组时是索引值index，遍历对象时是key  

for of 遍历数组的value，**不能遍历对象**   for of适合遍历数组



#### for循环中++i和i++的区别

for(语句1；语句2；语句3){ 被执行的代码块 }

语句1：在循环开始前执行

语句2：定义循环的条件

语句3：在循环已被执行后执行(这就是i++和++i结果一样的原因)

for循环的语法定义 ++i 和 i++的结果是一样的，**都要等代码块执行完毕才能执行语句3**，但是性能是不同的。在大量数据的时候++i的性能要比i++的性能好原因：

i++由于是在使用当前值之后再+1，所以需要一个临时的变量来转存。

而++i则是在直接+1，省去了对内存的操作的环节，相对而言能够提高性能



#### 闭包

**作用：**闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」。

1.可以访问其他函数内变量的函数，叫做闭包。
2.闭包可以用来保存一个需要持久保存的变量，可以模拟命名空间。

```js
function fn(){
    var num1 = 5;
    return function(){ //return出去，让外部调用，同时形成了闭包
        var num2 = 0;
        console.log(++num1)
        console.log(++num2)
    }
}
var fn1 = fn()  //此时fn1 = function(){var num2 = 0 ...}
fn1() //6 1  fn1引用了fn内的num1 所以num1不会销毁 产生了闭包
fn1() //7 1   


for(var i = 0;i<5;i++){
    setTimeout(() => {
        console.log(i)  //输出5个5，js是单线程所以当定时器执行时i已经等于5
    })
}

//通过闭包实现依次输出
for(var i=0;i<5;i++){
    (function(i){ //把i当做参数传入函数保存，形成闭包
        setTimeout(() => {
            console.log(i) //0 1 2 3 4
        },0)
    })(i)
}
```

好处

1. 保护函数内的变量安全 ，实现封装，防止变量流入其他环境发生命名冲突

2. 在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）

3. 匿名自执行函数可以减少内存消耗

坏处

1. 被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用完变量后手动为它赋值为null；

2. 其次由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响

#### && || 参与计算

关键在于条件执行到哪里返回

```js
var result = a && b //a真，此时判断b 不论b真假都返回b
var result = a || b //a真，此时不判断b，直接返回a
var result2 = c && d //c假，此时不判断d 直接返回c
var result2 = c || d //c假,此时判断d,并直接返回d
```

#### 高阶函数( filter方法为例 )

```js
//数组的filter方法源码
Array.prototype.myFilter = function(fn){
  let newArr = [];
  for(let i =0, len = this.length; i < len; i++){
    fn(this[i]) && newArr.push(this[i])  //等价于if(fn(this[i])){ newArr.push(this[i]) }
  }
  return newArr;
}

//调用myFilter方法，以函数为参数的高阶函数
var arr = [2,3,5,23,57]
arr.myFilter(function(item){
  return item > 3;
})
```





#### Promise函数

resolve和reject是promise对象的两种状态，分别代表请求成功或失败时的回调

promise的优势在于可以进行链式回调，使代码可读性更高，不用像普通回调一样嵌套

```js
new Promise((resolve,reject) => {
    setTimeout(() => { //模拟异步请求
        if(xxx){
            resolve('成功的数据')
        }else{
            reject('失败时的数据')
        }        
    })
}).then(res => {
    console.log(res)  //此处是resolve返回的数据
}).catch(err => {
    console.log(err)  //此处是reject返回的数据
})

//链式回调
new Promise(resolve => {
    //xxxxx
}).then(res => {
    return res + 'xxx'
}).then(res => {  //链式调用
    //xxx
})
```



#### call() apply() 用法

两个方法的核心就是改变函数的作用域，都是用来代替另一个对象调用一个方法

区别是传参形式不同

```js
func1.apply(this[,arguments]) //this表示当前作用对象，第二个参数必须是数组
func1.call(this,args1,args2) //可以传N个参数，但必须一个个写入
```

```js
let age = 18;
let obj = {
    name: 'david',
    age: this.age,
    myFn: function(){
        console.log('name is' + this.name + ', age is' + this.age)
    }
}
obj.myFn() //name is david, age is undefined ,this指向obj的获取不到
let obj2 = {
    age: 22
}
obj.myFn.call(obj2) //name is david age is 22
```



#### this指向问题

this的指向在函数创建时是无法决定的，**this仅指向调用它的上一级对象**

```js
var obj = {
    a: 'haha',
    fn: function(){
		console.log(this.a)  
    }
}
obj.fn()   //'haha'  this指向对象obj 因为调用fn()是通过obj.fn()执行的

var obj2 = {
    a: 'keke',
    b: {
        a: 'heyhey',
        fn: function(){
    		console.log(this.a)  //heyhey
		}
    }
}
obj2.b.fn()  //heyhey,由obj2发起调用，但没有指向obj2的a 而指向了b的a 所以仅指向上一级对象

var obj3 = {
    a: 'david',
    b: {
        fn: function(){
            console.log(this.a)  //undefined
        }
    }
}
obj3.b.fn() //undefined,虽然是obj3发起调用，但b内没有a属性，所以调用fn()时提示undefined

//方法赋值给别的对象
var obj4 = {
    a: 'david',
    b: {
        a: 'kashin',
        fn: function(){
            console.log(this.a)
        }
    }
}
var obj5 = obj4.b.fn 
obj5()  //undefined  obj5相当于只是获得了fn这个方法,直接执行fn() 自然就指向了window
```



#### 防抖和节流函数

##### 防抖函数 (规定时间内不触发事件才执行1次，触发就会重新计时)

```js
function debounce(fn,delay){
    let timer = null;
    return function(){
        let context = this;
        let args = arguments;
        if(timer) clearTimeout(timer);
        timer = setTimeout(function(){
            fn.apply(context,args) //apply绑定原作用域
        },delay)
    }
}
function loadSize(){
    console.log('屏幕在动')
}
window.addEventListner('resize',debounce(loadSize,1000))

```

##### 节流函数 (规定时间内仅执行一次，稀释函数执行频率)

```js
function throttle(fn,delay){
    let timer = null;
    return function(){
        let context = this;
        if(!timer){  //如果没有定时器，就设置一个定时器，执行相关操作
            timer = setTimeout(function(){
                timer = null; //并在指定时间后清空，每次触发执行
                fn.apply(context) //apply绑定作用域
            },delay)
        }
    }
}
```



#### localStorage sessionStorage

localstorage以键值对的形式储存在本地中，可以在浏览器application-Local Storage中查看

```js
var local = document.getElementById('username').value
button.onclick = function(){
    localStorage.setItem('username',local)
}
```



#### css定义变量和使用变量

``` css
page {
    /*定义全局颜色*/
    --themeColor: #fff;
}

/*使用变量*/
view {
    color: var(--themeColor);
}
```



#### :nth-of-child 和 :nth-of-type区别

div:nth-of-child(n)   **父元素的第n个子元素** ，前面的同级元素有效，**若第n个不是div则不会生效**

div:nth-of-type(n)   **父元素的第n个div类型子元素**，前面的其他元素无效 ，只看同类型div

当用类名时：

.item:nth-of-type(n)  先看标签名再看类名，选择第n个含class类的子元素，前面没有类名的同类元素也被计算在序列内

``` html
<style>
    .item:nth-of-type(5){
        color:  red;
    }
</style>
<div>
    <p class="item">11hahahaha</p>
    <p>没class的ppppPppp</p>
    <p class="item">22hahahaha</p>
    <p>没class的PPPPPPPP</p>
    <!--该行会被渲染，因为是第5个p，前面没有item的P也计算在序列内-->
    <p class="item">333hahahaha</p>
    <p class="item">444hahahaha</p>
    <p class="item">555hahahaha</p>
  </div>
```





#### :nth-child(an+b) n取值范围

an+b中  n>=0   an+b>=1

nth-child(n) nth-child(n+1)   表达式范围都是>=1 选择所有元素

nth-child(n-x)  因为n-x >=-x &an+b>=1 所以 n-x>=1 表示选择所有元素

nth-child(n+2) 表达式范围>=2 选择第二个以及后面所有元素

nth-chidl(-n+2) 表达式范围<=2 结合>=1 所以选择[1,2]  也就是第一，第二个元素



last-of-child(n)   表达式范围>=1 选择所有元素

last-of-child(n+2) 表达式范围>=2 选择倒数第二个以及前面所有元素

last-of-child(-n+2) 表达式范围[1,2]  选择倒数第一个和倒数第二个元素



#### es7异步请求方法async await

```js
//申明请求方法前加async关键词
async getGoods() {
    //使用es7 async/await发送请求。 res就是以前then()返回的数据
    const res = await request({url: '/homeData'})
    this.cates = res.data.message
    //渲染数据
    //.....
}

```



#### es6 findIndex()方法

```js
//findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置
//findIndex() 方法为数组中的每个元素都调用一次函数执行
//当数组中的元素在测试条件时返回 true 时,返回符合条件的元素的索引位置，之后的值不会再查询
//如果没有符合条件的元素返回 -1  findIndex不改变原数组
let arr = [0,3,11,20]
const result = arr.findIndex(function(val){
    return val >= 10    
})
console.log(result)  //输出2  因为arr中的第3项'11'满足条件，返回它的Index=2
```



#### map、forEach、filter注意点

map不会修改原数组，而是返回一个映射的新数组

filter不会修改原数组，需要**链式调用**或者**新建一个变量保存**过滤后的数组

forEach**会修改原数组**,  且没有返回值



#### padding左右边距不能设置auto,会失效



#### flex布局内使用white-space:nowrap要设置固定宽度，否则会挤压左右内容



#### 字体图标大小调整使用font-size属性



### vue重要概念

####  监听属性watch

```js
var watchExampleVM = new Vue({
  el: '#watch-example',
  data: {
    question: '',
    answer: 'I cannot give you an answer until you ask a question!'
  },
  watch: {
    // 如果 `question` 发生改变，这个函数就会运行
    question: function (newQuestion, oldQuestion) {  //监听函数会传入新值和旧值2个参数
      this.answer = 'Waiting for you to stop typing...'
      this.debouncedGetAnswer()
    }
  },
```



#### 绑定class的一些用法

##### 1.绑计算属性

```html
<!--绑计算属性-->
<!--渲染结果class="active text-danger"-->
<div :class="{classObj}"></div>

```

```js
data: {
    isActive: true,
    error: null
},
computed:{
    classObj(){
        return {
            active: this.isActive && !this.error,
            'text-danger': this.error && this.error.type === 'fatal'
        }
    }
}
```

##### 2.绑数组

```html
<!--渲染结果class="active text-danger"-->
<div :class="[activeClass,errorClass]"></div>
<!--三元表达式动态切换-->
<div :class="[isActive ? activeClass : '', errorClass]"></div>
<!--对象语法切换-->
<div v-bind:class="[{ active: isActive }, errorClass]"></div>

```

```js
data: {
    activeClass: 'active',
    errorClass: 'text-danger'
}
```

##### 3.绑style样式

```html
<div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
```

##### 

#### v-show 和 v-if 区别

`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。

`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。

一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。



#### v-for 和 v-if 一起使用（官方不推荐一起用）

v-for优先级比v-if高



#### 绑定key不要用Index 



#### v-for遍历对象

```html
<!--返回object的所有value值-->
<div v-for="value in object">
	{{value}}
</div>
```

```js
data: {
    object: {
        name: 'david',
        age: 33,
        title: 'xxxx'    
    }
}
```

#### v-for遍历计算属性

```html
<!--遍历返回能被2整除的数组-->
<li v-for="n in evenNumbers">{{ n }}</li>
```

```js
data: {
    numbers: [1,2,3,4,5]
},
computed: {
    evenNumbers(){
        return this.numbers.filter(item => {
            return item % 2 === 0
        })
    }
}
```

#### v-for嵌套遍历（计算属性不适用时）

```html
<ul v-for="set in sets">
    <li v-for="n in even(n)">{{n}}</li>
</ul>
```

```js
data: {
    sets: [[1,2,3],[4,5,6]]
},
methods: {
    even(numbers){
        return numbers.filter(item => {
            return item % 2 === 0
        })
    }
}
```



#### v-on绑定事件

有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 `$event` 把它传入方法：

```html
<button v-on:click="warn('Form cannot be submitted yet.', $event)">
  Submit
</button>
```

```js
// ...
methods: {
  warn: function (message, event) {
    // 现在我们可以访问原生事件对象
    if (event) {
      event.preventDefault()
    }
    alert(message)
  }
}
```

#### 事件修饰符

```html
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>
```



#### 修饰符顺序

使用修饰符时，顺序很重要；因此，用 `v-on:click.prevent.self` 会阻止**所有的点击**(阻止了默认事件，也就阻止了click事件)

而 `v-on:click.self.prevent` 只会阻止对元素自身的点击。(阻止click事件，就不会执行阻止默认事件)



#### v-model

v-model : 双向绑定
一般用于绑定表单输入的内容,限制在<input>、<select>、<textarea>、components中使用

v-model其实是语法糖:
<input v-model="test">本质上是
<input :value="test" @input="test = $event.target.value">   //绑定输入框的value值，@input是对输入事件的监听，再把监听到的值放入value

checkbox v-model="checkedNames"

<input type=checkbox  @change="checkedNames=$event.target.value">

##### v-model修饰符

.lazy   将input的实时更新转换为change事件，即改变完后更新

.number v-model默认是字符串，将绑定值转化为Number类型

.trim  过滤用户输入的首尾空格

##### v-model绑定复选框

```html
<!--把复选框的value值传给了checkedNames-->
<input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
<label for="jack">Jack</label>
<input type="checkbox" id="john" value="John" v-model="checkedNames">
<label for="john">John</label>
<input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
<label for="mike">Mike</label>
<br>
<!--span根据checkbox选择显示对应的复选框value值-->
<span>Checked names: {{ checkedNames }}</span>
```

```js
new Vue({
  el: '...',
  data: {
    checkedNames: []
  }
})
```

##### v-model绑定下拉框

```html
<div>
    <select v-model="selected">
    	<option disabled value="">请选择</option>
        <option>A</option>
        <option>B</option>
        <option>C</option>
    </select>
    <!--显示对应选择的A或B或C-->
    <span>selected: {{selected}}</span>
</div>
```

```js
data: {
    selected: ''
}
```



#### prop静态或动态传值

```html
<!--静态传值 子组件获取一个字符串-->
<my-cpn title="my journey"></my-cpn>

<!--动态传值 获取Item的title属性-->
<my-cpn :title="item.title"></my-cpn>
```

##### 子组件变更prop 

prop是单向数据流，父级更新流动到子组件，反向不行

1.**这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。**在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：

```js
props: ['initialName'],
data: function(){
    return {
        name: this.initialName
    }
}
```

2.**这个 prop 以一种原始的值传入且需要进行转换。**在这种情况下，最好使用这个 prop 的值来定义一个计算属性：

```js
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
```

注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身**将会**影响到父组件的状态。

prop指定类型

```js
props: {
    //基础数值类型
    myNumber: Number,
    xxxList: {
        type: Array,  //数组类型  
        default() {   //数组或对象类型必须从一个函数中返回
            return []
        }
    }， 
    //自定义验证函数
    validator: function(value){  
        return ['success','warning','danger'].indexOf(value) !== -1
    }
}
```



#### 将事件绑定到组件 .native

当组件外包一层根元素时，**监听<input>这类特别元素时** .native会失效，需要使用$listeners，将监听器指向组件中的某个特定元素

```html
<!--当父级调用这个组件并使用.native监听事件时会失效，-->
<base-input v-on:focus.native="onFocus"></base-input>

<!--子组件根元素是label-->
<label>
    {{label}}
	<input v-bind="$attrs" :value="value" @input="$emit('input',$event.target.value)" />
</label>
```

```js
//有了这个 $listeners property，你就可以配合 v-on="$listeners" 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 <input> 的你希望它也可以配合 v-model 工作的组件来说，为这些监听器创建一个类似下述 inputListeners 的计算属性通常是非常有用的：
//<base-input>就是一个透明的包裹器了，不必使用.native监听了
Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  computed: {
    inputListeners: function () {
      var vm = this
      // `Object.assign` 将所有的对象合并为一个新对象
      return Object.assign({},
        // 我们从父级添加所有的监听器
        this.$listeners,
        // 然后我们添加自定义监听器，
        // 或覆写一些监听器的行为
        {
          // 这里确保组件配合 `v-model` 的工作
          input: function (event) {
            vm.$emit('input', event.target.value)
          }
        }
      )
    }
  },
  template: `
    <label>
      {{ label }}
      <input
        v-bind="$attrs"
        v-bind:value="value"
        v-on="inputListeners"
      >
    </label>
  `
})
```



#### v-slot 

vue2.6.0以后 **slot  attribute具名插槽**和**slot scope attribute作用域插槽** 已在vue3中废弃， 使用**v-slot**代替

即`<div slot="header">` 这种写法已废弃

```html
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>

<!--v-slot必须用在<template>标签上(只有后面一种例外)-->
<base-layout>
  <template v-slot:header>
    <h1>Here might be a page title</h1>
  </template>

  <p>A paragraph for the main content.</p>
  <p>And another one.</p>

  <template v-slot:footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>
```

#### 作用域插槽

作用域插槽是绑定数据的插槽，可以获取到父组件传递的参数，将这些参数使用到子组件插槽里

```html
<!--<current-user>组件-->
<span>
  <slot>{{ user.lastName }}</slot>
</span>
<!--父组件想改变渲染的值,这种写法是不通的，父组件无法获取子组件的user-->
<current-user>{{user.firsrName}}</current-user>


<!--正确写法-->
<!--把user当做slot的一个属性绑定上去-->
<span>
    <!--这个叫插槽prop-->
    <slot :user="user">{{user.lastName}}</slot>
</span>


<current-user>
    <!--使用带值的v-slot来定义插槽名字,就可以通过slot的属性获取到user-->
	<template v-slot:default="slotProps">
    	{{slotProps.user.firstName}}
    </template>
</current-user>

```

#### 独占默认插槽(v-slot可以写在组件标签上)

当被提供的内容**只有默认插槽**时，组件的标签才可以被当作插槽的模板来使用。可以把 `v-slot` 直接用在组件上

**不能和具名插槽混用**，会导致作用域不清楚。混用时依然要写在Template上

```html
<current-user v-slot:default="slotProps">
	{{slotProps.user.firstName}}
</current-user>
```



##### 插槽缩写: v-slot可以缩写成#  和v-bind v-on一样

```html
<current-user>
	<template #header>
    	{{user.firstName}}
    </template>
</current-user>
```



#### vue根实例：$root

```js
new Vue({
    data: {
        foo: 1
    },
    methods: {
        fn1:function(){}
    }
})


//所有的子组件都可以将这个实例作为一个全局 store 来访问或使用，但是大型应用推荐VueX来管理应用状态
this.$root.foo
this.$root.fn1()
```

#### 

#### 访问子组件实例或子元素 ref 和 $refs

```html
<base-input ref="userNameInput"></base-input>
```

```js
//访问子组件
this.$refs.userNameInput
```



#### filters过滤器

过滤器可以用在2个地方：{{ }}内 或 v-bind表达式

```html
<!--1.双花括号内-->
<div>{{number | filterNumber}}</div>

<!--2.v-bind表达式内-->
<div v-bind:time="formatTime"></div>
```



#### $el 获取vue实例关联的DOM根元素



#### 跨域的几种解决方案

```js
//1.原生跨域
var script = document.createElement('script')
//传参给服务器，里面包含了服务器要执行的回调函数
script.src = 'https://www.domain2.com:8080/login?user=admin&callback=getData'
document.head.appendChild(script)
//回调执行函数
function getData(res){
    alert(JSON.stringify(res))
}
//服务端把data传进去
getData({'status': true, 'user': 'admin'})


//2.jquery+jsonp跨域
$.ajax({
    url: 'http://www.domain2.com:8080/login',
    type: 'get',
    dataType: 'jsonp',
    jsonpCallback: 'handleCallback', //回调函数名称 传给后端用
    data: {},
    success: function(response,status,xhr){
        console.log('状态为'+status+,'状态是'+xhr.statusText)
        console.log(response)
    }
})

//3.vue跨域配置代理
module.exports ={
    dev: {
        proxyTable: {
            //把所有的接口统一规范为一个入口，在一定程度上会解决冲突
            '/api': {
                target: 'http://localhost:3000',
                changeOrigin: true //是否允许跨域的配置
                //pathRewrite: {'^/api' : ''} //后面可以使重写的新路径，一般不做更改
            }
        }
    }
}
```



### Object.assign 合并对象

将源对象（source）的所有可枚举属性，复制到目标对象（target）。

```js
const target = { a: 1 };

const source1 = { b: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}

//实际用法
//将多个对象合并到某个对象
const merge = (target, ...sources) => Object.assign(target, ...sources);

//合并多个对象并返回一个新对象
const merge = (...sources) => Object.assign({}, ...sources);

//将属性x,y添加到对象point类对象实例中
class Point {
  constructor(x, y) {
    Object.assign(this, {x, y});
  }
}

//给对象添加方法
Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});

// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) {
  ···
};
SomeClass.prototype.anotherMethod = function () {
  ···
};
```



### 字符串转数字，数字转字符串快捷方法

```js
//字符串转数字, 字符串-0
let str = '123'
console.log(str - 0) // 123

//数字转字符串，后面+ ''
let str2 = 123
console.log(str2 + '') //'123' 
```



### css常用样式

```css

.cate-name{
  display: inline-block;
  position: relative;
  font-size: 34rpx;
  line-height: 1;
  margin: 32rpx 0rpx 20rpx 0rpx;
}
/*利用after伪元素给文字添加背景色*/
.cate-name::after{ 
  position: absolute;
  top: 0rpx;
  left: 0rpx;
  right: 0rpx;
  content: '';
  z-index: -1;
  bottom: 0rpx;
  border-radius: 50%;
  background: rgba(248, 182, 44, 1);
}

/*阴影样式*/
.card{
  padding: 30rpx 28rpx;
  width: 686rpx;
  box-sizing: border-box;
  box-shadow:0px 4px 6px 0px rgba(0,0,0,0.1); /*关键语句*/
  border-radius:8rpx;
  background: #fff;
  margin: 10rpx auto 26rpx auto;
}
```

### 负外边距

![1.gif](https://img.gxlcms.com//Uploads-s/new/2020-06-01-wenti/1537328821879881.gif)

一个static元素是一个没有使用过float的元素。上面的图片展示了一个static的元素使用负边距之后的情况。

当一个static元素在top/left使用负边距时，它把元素向这个特定的方向拉，

但是当你将负边距设置为相对bottom/right时，它并不会把元素向下或右拉，相反，它会把后面的元素往里面拉，从而覆盖自己。



### break、return区别

1、break：是立即结束语句，并跳出语句，进行下个语句执行。

2、continue：是停止当前语句，并从头执行该语句。

3、return：停止函数。

4、使用的语句环境不一样，break和continue是用在循环或switch语句中，return是用在函数语句中。

### for循环里的可以return跳出循环，forEach里的return只能终止当前循环



### 原型链

①所有**`引用类型`**都有一个`__proto__(隐式原型)`属性，属性值是一个普通的对象 
②所有**`函数`**都有一个`prototype(原型)`属性，属性值是一个普通的对象 
③所有**引用类型**的__proto__属性`指向`它**构造函数**的**prototype**

```js
var a = [1,2,3];
a.__proto__ === Array.prototype; // true
a.constructor === Array //true
Array.prototype.constructor === Array //true
```

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20180620134143385?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9lcm1pbmdu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![img](https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png)