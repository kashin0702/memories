### 一些重要概念

#### vue生命周期

**beforeCreate( 创建前 )**

在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods， data， computed等上的方法和数据。

**created ( 创建后 ）**

实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch/event事件回调，完成了data 数据的初始化，el没有。 然而，挂在阶段还没有开始, $el属性目前不可见，这是一个常用的生命周期，因为你可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也有一些童鞋喜欢在这里发ajax请求，**值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截**的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter中完成

**beforeMount**

挂载开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。

**mounted**

挂载完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。

**beforeUpdate**

在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程

**updated（更新后）**

在由于数据更改导致地虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用

**beforeDestroy（销毁前）**

在实例销毁之前调用，实例仍然完全可用，

1. 这一步还可以用this来获取实例，
2. 一般在这一步做一些重置的操作，比如**清除掉组件中的定时器  和 监听的dom事件**

**destroyed（销毁后）**

在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用

#### 运算符优先级

| 运算符                             | 描述                                         |
| ---------------------------------- | :------------------------------------------- |
| . [] ()                            | 字段访问、数组下标、函数调用以及表达式分组   |
| ++ -- - ~ ! delete new typeof void | 一元运算符、返回数据类型、对象创建、未定义值 |
| * / %                              | 乘法、除法、取模                             |
| + - +                              | 加法、减法、字符串连接                       |
| << >> >>>                          | 移位                                         |
| < <= > >= instanceof               | 小于、小于等于、大于、大于等于、instanceof   |
| == != === !==                      | 等于、不等于、严格相等、非严格相等           |
| &                                  | 按位与                                       |
| ^                                  | 按位异或                                     |
| \|                                 | 按位或                                       |
| &&                                 | 逻辑与                                       |
| \|\|                               | 逻辑或                                       |
| ?:                                 | 条件                                         |
| = oP=                              | 赋值、运算赋值                               |
| ,                                  | 多重求值                                     |

#### 基本类型和引用类型

基本类型：string number boolean undefined null

引用类型：function object array

1.基本类型按值访问，比较是值的比较，保存在**栈内存中**

2.基本类型赋值是创建一个新值，保存在不同的内存地址中

```js
var a = 10

var b = a 

a === b  //true  值的比较

a++  

console.log(a);  //11

console.log(b); //10
```

1.引用类型拥有属性和方法，引用类型的副本是指向保存在栈内存和堆内存中的一个指针

2.引用类型的比较是引用在**堆内存中地址的比较**

```js
var a = {};

var b = {};

a === b  //false  ab指向不同的内存地址，这两个都是指针

var a = {};

b = a;   

a === b //true  b和a都指向同一个内存地址，此时修改b的值也会影响到a
```



#### 包装类型

为了便于操作“基本类型值”，JS 提供了 三个 特殊的引用类型：**Boolean、Number、String**。这些类型和其他引用类型相似，但同时 也具备 与各自基本类型相应的特殊行为。 实际上：每当读取一个基本类型值的时候， “**后台就会创建**一个 对应的**基本包装类型的对象**”，从能能够调用一些方法来操作这些数据。 



#### 获取属性值[]和. 的区别

[] 可以使用字符串作为属性名，.不行

[]可以使用数字作为属性名，.不行

[]可以使用js关键字和保留字作为属性名， .不行

**个人理解：** 

相同：都可以用来给对象添加属性

不同： 获取属性

句点法获取属性时，指向确定的属性名, **如obj.name  这个name只能是obj中名为’name‘的key，不能是变量名**

[]通过传入(变量,字符串,数字)，**变量需要对应对象的key名**，否则是undefined 

```js
let obj = {
    key1: 'xxx',
    key2: 'zzz',
    key3: 'ccc'
}
for(let i=1;i<4;i++){
    let key = 'key' + i
    console.log(obj[key])// 正常输出属性值
    //句点法获取的是obj对象的key,obj对象内并没有'key'这个键名
    console.log(obj.key) // undefined
}

let obj2 = {
    water: 'woo',
    2: 'ww',
    3: 'zzz'
}
let ss = 'water'
console.log(obj2[ss]) // woo 通过变量ss获取到key
console.log(obj2.ss) // undefined 跟上面一样，obj2内并没有ss这个key
```



#### typeof 

typeof是检测string , number, boolean,undefined这些**基本类型**的最佳工具，但检测null的话返回的是object，对function的检测不准确（有可能是正则表达式）。

typeof返回值:

   \1. 'undefined'       --未定义的变量或值

​    \2. 'boolean'         --布尔类型的变量或值

​    \3. 'string'           --字符串类型的变量或值

​    \4. 'number'         --数字类型的变量或值

​	 \5. 'object'          --对象类型的变量或值，或者null(这个是js历史遗留问题，将null作为object类型处理)

​    \6. 'function'         --函数类型的变量或值

**typeof运算符用于判断对象的类型，但是对于一些创建的对象，它们都会返回'object'，有时我们需要判断该实例是否为某个对象的实例，那么这个时候需要用到instanceof运算符**



#### instanceof

语法：object instanceof constructor

`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

````js
// 定义构造函数
function C(){}
function D(){}

var o = new C();

o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototype

o instanceof D; // false，因为 D.prototype 不在 o 的原型链上

o instanceof Object; // true，因为 Object.prototype.isPrototypeOf(o) 返回 true
C.prototype instanceof Object // true，同上

C.prototype = {};
var o2 = new C();

o2 instanceof C; // true

o instanceof C; // false，C.prototype 指向了一个空对象,这个空对象不在 o 的原型链上.

D.prototype = new C(); // 继承
var o3 = new D();
o3 instanceof D; // true
o3 instanceof C; // true 因为 C.prototype 现在在 o3 的原型链上

````



```js
//手写instanceof 方法
function myInstanceof (left, right) {
    // 基本数据类型直接返回false
    if (typeof left !== 'object' || left === null) return false
    // getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象
    let proto = Object.getPrototypeOf(left)
    while (true) {
        // 查找到尽头，还没找到
        if (proto == null) return false
        // 找到相同的原型对象
        if (proto == right.prototype) return true
        proto = Object.getPrototypeOf(proto) //递归 继续判断该对象中是否有原型对象
    }
}
//测试
console.log(myInstanceof("111", String)); //false
console.log(myInstanceof(new String("111"), String));//true
```



#### 判断是否是数组的6种方法

```js
// 1. instanceof
let arr = [];
console.log(arr instanceof Array); // true

//2. 利用构造函数的constructor属性判断
let arr = [];
console.log(arr.constructor === Array); // true

//3. Array 原型链上的 isPrototypeOf
//isPrototypeOf() 用于测试一个对象是否存在于另一个对象的原型链上。
let arr = [];
console.log(Array.prototype.isPrototypeOf(arr)); // true

//4. Object.getPrototypeOf() 方法返回指定对象的原型
let arr = [];
console.log(Object.getPrototypeOf(arr) === Array.prototype); // true

//5. Object.prototype.toString.call(arr) === '[object Array]'
//虽然Array也继承自Object，但js在Array.prototype上重写了toString，而我们通过toString.call(arr)实际上是通过原型链调用了。
let arr = [];
console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true

//6. Array.isArray(arr) es5新增
let arr = [];
console.log(Array.isArray(arr)); // true
```





#### 连续赋值

解答思路：

1、优先级.的优先级高于=，所以先执行a.x，堆内存中的{n: 1}就会变成{n: 1, x: undefined}，改变之后相应的b.x也变化了，因为指向的是同一个对象。
2、赋值操作是从右到左，所以先执行a = {n: 2}，a的引用就被改变了，然后这个返回值又赋值给了a.x，需要注意的是这时候a.x是第一步中的{n: 1, x: undefined}那个对象，其实就是b.x，相当于b.x = {n: 2}

```js
var a = {n: 1}; 
var b = a;
a.x = a = {n: 2};  //关键点a.x优先声明
console.log(a.x)  //undefined
console.log(b.x) //{n: 2}

/*
给a添加属性x，此时a,b都是 { n:1,x:undefined },a.x 运算后的结果即为这个object（可以说也就是b）的x属性值。
把{n:2}赋值给a，此时a是 {n:2},是一个新的对象。 b是{ n:1,x:undefined }。
由于（ .  运算符最先计算）一开始js已经先计算了a.x，便已经解析了这个a.x是对象A的x，所以在同一条公式的情况下再回来给a.x赋值，也不会说重新解析这个a.x为对象B的x。
所以 a.x=a 应理解为对象A的属性x指向了对象B:
（这个时候a.x 已经运算完了，不会再与a产生任何关系，a.x依旧代表那个n为1对象的x属性值，和a已经没关系了。）
把{n:2}赋值给a.x 也就是 { n:1,x:undefined }这个对象的x属性，这个时候b依旧指向这个object，因此此时，a是{n:2}，b是{n:1,x:{n:2}}
*/
```



```js
var box ='Mr.Xiao';     //字面量创建方式 
alert(box.substring(2)); //box 是基本类型，但是也是特殊的引用类型，在后台会创建一个基本包装类型的对象，所以可以调用 系统内置的函数
```

#### substring()/substr()区别

```js
// substring 返回字符串n到m之间的字符串，包括n,不包括m
// substr 返回字符串n开始的m个字符串
let str = 'hello david'
str.substring(2,5) // 'llo'
str.substr(2,5)    // 'llo d'

```

#### Object.defineProperty

`Object.defineProperty()`的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性

1. obj 需要定义属性的当前对象

2. prop 当前需要定义的属性名

3. desc 属性描述符

   属性描述符有2种：数据描述符、存取描述符

```js
//Object.defineProperty(obj, prop, desc)
// 数据描述符 特有的两个属性(value,writable)
let Person = {}
Object.defineProperty(Person, 'name', {
    value: 'jack',
    writable: true //是否可改变 默认值是false
})
Person.name = 'david' //undefined

// 存取描述符 由一对 getter、setter 函数功能来描述的属性
// get: 一个给属性提供getter的方法，如果没有getter则为undefined。该方法返回值被用作属性值。默认为undefined
// set: 一个给属性提供setter的方法，如果没有setter则为undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认值为undefined
let temp = null
Object.defineProperty(Person, 'name', {
    get: function(){
        return temp
    },
    set: function(newValue){  //set会传入一个newValue
        temp = newValue
    }
})
Person.name = 'david'
console.log(Person.name) //'david'
```



#### Object.getPrototypeOf

`Object.getPrototype(obj)`是ES5中用来获取obj对象的原型对象的标准方法。

`obj.__proto__`是获取obj对象的原型对象的非标准方法。

User.prototype`用于建立由 `new User() 创建的对象的原型。

```js
//创建一个User构造函数
function User(name, passwordHash) {
  this.name = name;
  this.passwordHash = passwordHash;
}

User.prototype.toString = function() {
  return '[User ' + this.name + ']';
}

User.prototype.checkPassword = function(password) {
  return hash(password) === this.passwordHash;
}
//创建u实例
var u = new User('Lix', '123456');
//输出都一样
console.log(Object.getPrototypeOf(u)); // User { toString: [Function], checkPassword: [Function] }

console.log(u.__proto__); // User { toString: [Function], checkPassword: [Function] }

console.log(User.prototype); // User { toString: [Function], checkPassword: [Function] }
```

#### if( xx in obj)  判断xx属性是否属于obj对象

判断一个属性是否属于一个对象。有返回true,没有返回false

```js
let names = ['Lily', 'Barry', 'Dendi', 'Boogie', 'Lily'];

    let nameNum = names.reduce((pre, cur) => {
        if (cur in pre) { //pre 中是否有 cur 属性
            pre[cur]++;
        } else {
            pre[cur] = 1; //为 pre 这个对象添加 cur 属性，并且赋值为 1
        }
        return pre;
    }, {})  //关键：这里设置初始值是一个空对象

    console.log(nameNum); //{Barry: 1,Boogie: 1,Dendi: 1,Lily: 2 }

```



#### if if  和 if else if 区别

```c
if (条件1)
{
    //语句1
}

if (条件2)
{
    //语句2
}
```



这种格式中，程序会依次判断条件1和条件2是否成立并根据结果决定是否执行语句1和语句2，也就是说，第一个 if 块和第二个 if 块没有影响（除非在执行第一个 if 块的时候就凶残地 return 了）

```c
if (条件1) 
{
    //语句1
}
else if (条件2)
{
    //语句2
}
```

if 块和 else if 块本质上是互斥的！也就是说，一旦语句1得到了执行，程序会跳过 else if 块，else if 块中的判断语句以及语句2一定会被跳过；同时语句2的执行也暗含了条件1判断失败和语句1没有执行；当然还有第3个情况，就是条件1和条件2都判断失败，语句1和语句2都没有得到执行。





#### for/in for/of区别

for in 遍历数组时是索引值index，遍历对象时是key  

for of 遍历数组的value，**不能遍历对象**   for of适合遍历数组



#### for循环中++i和i++的区别

for(语句1；语句2；语句3){ 被执行的代码块 }

语句1：在循环开始前执行

语句2：定义循环的条件

语句3：在循环已被执行后执行(这就是i++和++i结果一样的原因)

for循环的语法定义 ++i 和 i++的结果是一样的，**都要等代码块执行完毕才能执行语句3**，但是性能是不同的。在大量数据的时候++i的性能要比i++的性能好原因：

i++由于是在使用当前值之后再+1，所以需要一个临时的变量来转存。

而++i则是在直接+1，省去了对内存的操作的环节，相对而言能够提高性能

#### for循环的本质

对于一个for循环，设置循环变量的地方是一个父作用域，而循环体代码在一个子作用域内；别忘了for循环还有条件判断，与循环变量的自增

for循序的执行顺序是这样的：**设置循环变量(var i = 0) ==》循环判断(i<3) ==》满足执行循环体 ==》循环变量自增(i++)**



#### 闭包

**作用：**闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」。

1.可以访问其他函数内变量的函数，叫做闭包。
2.闭包可以用来保存一个需要持久保存的变量，可以模拟命名空间。

```js
function fn(){
    var num1 = 5;
    return function(){ //return出去，让外部调用，同时形成了闭包
        var num2 = 0;
        console.log(++num1)
        console.log(++num2)
    }
}
var fn1 = fn()  //此时fn1 = function(){var num2 = 0 ...}
fn1() //6 1  fn1引用了fn内的num1 所以num1不会销毁 产生了闭包
fn1() //7 1   


for(var i = 0;i<5;i++){
    setTimeout(() => {
        console.log(i)  //输出5个5，js是单线程所以当定时器执行时i已经等于5
    })
}

//通过闭包实现依次输出 其实也是立即执行函数
//这里for循环和立即执行函数同步执行，循环5次产生了5个函数作用域，i也依次保存下来
for(var i=0;i<5;i++){
    (function(i){ 
        setTimeout(() => {
            console.log(i) //i引用了外部函数的i
        },0)
    })(i)  
}

// 使用let建立独立作用域
for(let i=0;i<5;i++){
    setTimeout(function(){
        console.log(i)
    },0)
}
```

好处

1. 保护函数内的变量安全 ，实现封装，防止变量流入其他环境发生命名冲突

2. 在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）

3. 匿名自执行函数可以减少内存消耗

坏处

1. 被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用完变量后手动为它赋值为null；
2. 其次由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响



#### scrollTop、offsetTop 区别

网页可见区域高：document.body.clientHeight
网页可见区域高（包括边线的高）：document.body.offsetHeight
网页被卷去的高：document.body.scrollTop

网页正文全文高：document.body.scrollHeight

屏幕分辨率高：window.screen.height

offsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素

![img](https://img-blog.csdnimg.cn/20210414142501307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDMwMDAw,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210414142441565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDMwMDAw,size_16,color_FFFFFF,t_70)



#### && || 参与计算

关键在于条件执行到哪里返回

```js
var result = a && b //a真，此时判断b 不论b真假都返回b
var result = a || b //a真，此时不判断b，直接返回a
var result2 = c && d //c假，此时不判断d 直接返回c
var result2 = c || d //c假,此时判断d,并直接返回d
```

#### 高阶函数( filter方法为例 )

```js
//数组的filter方法源码
Array.prototype.myFilter = function(fn){
  let newArr = [];
  for(let i =0, len = this.length; i < len; i++){
    fn(this[i]) && newArr.push(this[i])  //等价于if(fn(this[i])){ newArr.push(this[i]) }
  }
  return newArr; //返回新数组
}

//调用myFilter方法，以函数为参数的高阶函数
var arr = [2,3,5,23,57]
arr.myFilter(function(item){
  return item > 3; //此处return值为true,加入了新数组，然后新数组返回
})
```



#### 递归函数

递归函数会先执行递归内的函数，**跟嵌套循环一样，先执行内部再执行外部**

```js
getLeafKeys(node,arr){
    //1.如果当前node节点不包含children属性，则是3级节点，把node的id保存到数组arr中
    if(!node.children){
        return arr.push(node.id)
    }
    //2.不是3级节点，循环children属性，拿到字节点item，对item再次调用函数进行递归
    node.children.forEach(item => {
        this.getLeafKeys(item,arr)
    })
}

//手写instanceof 方法
function myInstanceof (left, right) {
    // 基本数据类型直接返回false
    if (typeof left !== 'object' || left === null) return false
    // getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象
    let proto = Object.getPrototypeOf(left)
    while (true) {
        // 查找到尽头，还没找到
        if (proto == null) return false
        // 找到相同的原型对象
        if (proto == right.prototype) return true
        proto = Object.getPrototypeOf(proto) //递归循环
    }
}
```



#### Promise函数

resolve和reject是promise对象的两种状态，分别代表请求成功或失败时的回调

promise的优势在于可以进行链式回调，使代码可读性更高，不用像普通回调一样嵌套

```js
new Promise((resolve,reject) => {
    setTimeout(() => { //模拟异步请求
        if(xxx){
            resolve('成功的数据')
        }else{
            reject('失败时的数据')
        }        
    })
}).then(res => {
    console.log(res)  //此处是resolve返回的数据
}).catch(err => {
    console.log(err)  //此处是reject返回的数据
})

//链式回调
new Promise(resolve => {
    //xxxxx
}).then(res => {
    return res + 'xxx'
}).then(res => {  //链式调用
    //xxx
})
```



#### Promise.then

**只有当resolve()执行后，才会调用then(fn1,fn2)中的fn1回调函数**

**只有当reject()执行后，才会调用then(fn1,fn2)中的fn2回调函数**

```js
// then的2个回调函数
promise.then(resolvedCallback, rejectedCallback);

promise.then(function(value) {
  // 把这个函数作为promise对象状态变为成功后调用的回调函数
  // 成功时的逻辑
}, function(error) {
  // 把这个函数作为promise对象状态变为失败后调用的回调函数
  // 失败时的逻辑
});
```



Promise实例生成以后，可以用then方法指定两个回调函数。
then方法中的第一个参数，是promise对象的状态由pending变为resolved后会调用的回调函数；then方法中的第二个参数，是promise对象的状态由pending变为rejected后调用的回调函数；
这两个回调函数中，rejectedCallback可选的，不一定要提供。
例一中，如果异步操作成功，就会调用resolve(value)，调用resolve(value)，**当前promise的状态由进行中变为成功，随即调用then方法中的第一个回调函数参数**。
我们在例一中调用resolve(value)的时候其实就可以看作是在调用then方法里传的第一个回调函数。
then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行( 也就是说resolve()后面如果还有其他同步语句(如上面例子中的console.log(1) )，会先执行完这些同步语句， 然后在执行then方法中的回调函数)。（其实这里涉及到的是事件循环的概念，不清楚的可以去了解）

then方法会返回一个**新的**Promise实例。因此可以采用链式写法，即then方法后面再调用另一个then方法。采用链式的then，可以指定一组按照次序调用的回调函数。

**成功时的回调 和 失败时的回调函数 中的return返回值**
第一个回调函数完成以后，会将返回结果作为参数，传入下一级的回调函数。返回结果可能是一个参数或者一个新的promise实例（即有异步操作），这时候一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。
如果then方法中的回调函数(不管是成功的回调还是失败的回调)返回了一个参数(return xxx)，那么这个then方法返回的新的promise的状态会变成fulfilled(同时成功的回调函数也会被调用)。

#### Promise.all

Promise.all可以将**多个Promise实例**包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。

```js
let wake = (time) => {
  // 通过return new Promise包装实例
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(`${time / 1000}秒后醒来`)
    }, time)
  })
}

let p1 = wake(3000)
let p2 = wake(2000)

Promise.all([p1, p2]).then((result) => {
  console.log(result)       // [ '3秒后醒来', '2秒后醒来' ]
}).catch((error) => {
  console.log(error)
})
```



#### call()  apply()  

call()  apply()两个方法的核心就是改变函数的作用域，都是用来代替另一个对象调用一个方法

区别是传参形式不同

bind()方法返回一个函数

```js
func1.apply(this[,arguments]) //this表示当前作用对象，第二个参数必须是数组
func1.call(this,args1,args2) //可以传N个参数，但必须一个个写入
```

```js
let age = 18;
let obj = {
    name: 'david',
    age: this.age,
    myFn: function(){
        console.log('name is' + this.name + ', age is' + this.age)
    }
}
obj.myFn() //name is david, age is undefined ,this指向obj的获取不到
let obj2 = {
    age: 22
}
obj.myFn.call(obj2) //name is undefined age is 22
```

#### bind()

bind会返回一个函数

```js
//this被改变的情况
var a = {
	b : function(){
		var func = function(){
			console.log(this.c);
		}
		func(); //此时this指向了b,报undefined
	},
	c : 'Hello!'
}
a.b();  //undefined


//解决方法1：保存this指向的对象
var a = {
	b : function(){
		var that = this; //这里保存了this指向的对象,即对象a
		var func = function(){
			console.log(that.c); //that == 对象a
		}
		func();
	},
	c : 'Hello!'
}
a.b(); //Hello!

//解决方法2：使用bind绑定作用域
var a = {
	b : function(){
		var func = function(){
			console.log(this.c);
		}.bind(this);
		func();
	},
	c : 'Hello!'
}
a.b(); //Hello!

 
var a = {
	b : function(){
		var func = function(){
			console.log(this.c);
		}
		func.bind(this)();
	},
	c : 'Hello!'
}
a.b(); //Hello!

```



#### [object Object] 

我们的代码中有`+`（加号）运算符，它在这种情况下（字符串 + 其它什么东西），会调用`toString()`方法，将其它类型的东西转化为字符串，再和原始字符串拼接成一个字符串；

- 默认情况下，`toString()`方法被每个`Object`对象继承。如果此方法在自定义对象中未被覆盖，`toString()`返回 "`[object type]`"，其中`type`是对象的类型。

```js
// 对象转字符串 调用了Object的toString()方法 会返回[object Object]
console.log('res:' + res); //res:[object Object]
Object.prototype.toString.call([1,2,3]) // [object Array]
```



#### String match()方法 

先介绍参数为普通字符串的使用方式，此时match方法的返回值是存放首次匹配内容的数组。如果没有找到匹配结果，返回null。语法结构：

1 str.match(searchvalue)
参数解析：
（1）.searchvalue：必需，规定方法要检索的字符串。
代码实例：

```js
let str="antzone"; 
console.log(str.match("n"));
//代码运行效果：
**["n", index: 1, input: "antzone", groups: undefined]**
```

（1）.match方法在有匹配结果的时候返回值是一个数组。
（2）.数组第一个元素是match方法首次匹配到的子字符串，"antzone"虽然有多个"n"，但是返回的数组只存储首次匹配到的"n"，如果match方法的参数是全局匹配的正则，将会存储所有的匹配到的子字符串。
（3）.index属性值返回首次匹配到子字符串的位置。
（4）.input属性值是原字符串"antzone"。
（5）.groups属性当前并不被支持，暂时不做介绍。



#### this指向问题

- 在方法中，this 表示该方法所属的对象。
- 如果单独使用，this 表示全局对象。
- 在函数中，this 表示全局对象。
- **在函数中，在严格模式下，this 是未定义的(undefined)**。
- 在事件中，this 表示接收事件的元素。
- 类似 call() 和 apply() 方法可以将 this 引用到任何对象。

```html
<!--在 HTML 事件句柄中, this指向了接收事件的 HTML 元素-->
<button onclick="this.style.display='none'">点我后我就消失了</button>
```

```js
function foo(){
    console.log(this)
}
//1.对于new 方式，this永远被绑定在c上
const c = new foo()
//2.对于直接调用的函数，this永远指向window
foo()

```

```js
//3. this的指向在方法创建时是无法决定的，this仅指向调用它的上一级对象
var obj = {
    a: 'haha',
    fn: function(){
		console.log(this.a)  
    }
}
obj.fn()   //'haha'  this指向对象obj 因为调用fn()是通过obj.fn()执行的

var obj2 = {
    a: 'keke',
    b: {
        a: 'heyhey',
        fn: function(){
    		console.log(this.a)  //heyhey
		}
    }
}
obj2.b.fn()  //heyhey,由obj2发起调用，但没有指向obj2的a 而指向了b的a 所以仅指向上一级对象

var obj3 = {
    a: 'david',
    b: {
        fn: function(){
            console.log(this.a)  //undefined
        }
    }
}
obj3.b.fn() //undefined,虽然是obj3发起调用，但b内没有a属性，所以调用fn()时提示undefined

//方法赋值给别的对象
var obj4 = {
    a: 'david',
    b: {
        a: 'kashin',
        fn: function(){
            console.log(this.a)
        }
    }
}
var obj5 = obj4.b.fn 
obj5()  //undefined  obj5相当于只是获得了fn这个方法,直接执行fn() 自然就指向了window
```



#### 箭头函数=>

- 箭头函数的 this和**调用时上下文无关**，它不绑定this, 它会捕获其**所在上下文**（即定义的位置）的this值，一旦确定，任何方法都改变不了其指向，如 call() ,  bind() ,  apply() 

- 普通函数的this在**调用时确定**，指向调用它的那个对象

  ```js
  function make () {
    return ()=>{ // 定义时this并没有确定
      console.log(this);
    }
  }
  const testFunc = make.call({ name:'foo' }); // 一旦确定this就不会改变
  testFunc(); //=> { name:'foo' }
  testFunc.call({ name:'bar' }); //=> { name:'foo' }
  ```




```js
var obj = {
  a: 10,
  b: () => {// 不绑定this,沿作用域链向上找this, 没有就指向了window
    console.log(this.a); // undefined
    console.log(this); // Window 
  },

 c: function() {
        console.log(this.a); // 10
        console.log(this); // {a: 10, b: ƒ, c: ƒ}
    }
}

obj.b(); 
obj.c();

```


  ```js
//箭头函数在不写{} 的情况下，可以省略return关键字，而默认return接下来的东西
() => () => ...
//等价于：
() => {return () => {return ...}}
//等价于
function () {
    retunrn function() {
        return ...
    }
}
  ```



#### try/catch错误处理

目前我们可能得到的系统异常主要包含以下6种:

- **EvalError**: raised when an error occurs executing code in eval() 
- **RangeError**: raised when a numeric variable or parameter is outside of its valid range 
- **ReferenceError**: raised when de-referencing an invalid reference 
- **SyntaxError**: raised when a syntax error occurs while parsing code in eval() 
- **TypeError**: raised when a variable or parameter is not a valid type 
- **URIError**: raised when encodeURI() or decodeURI() are passed invalid parameters 

上面的六种异常对象都继承自Error对象。他们都支持以下两种构造方法:

```javascript
new Error();
new Error("异常信息");
```

手工抛出异常的方法如下：

```javascript
try {
 throw new Error("Whoops!");
} catch (e) {
 alert(e.name + ": " + e.message);
}
```

Error具有下面一些主要属性：

- description: 错误描述 (仅IE可用). 
- fileName: 出错的文件名 (仅Mozilla可用). 
- lineNumber: 出错的行数 (仅Mozilla可用). 
- message: 错误信息 (在IE下同description) 
- name: 错误类型. 
- number: 错误代码 (仅IE可用). 
- stack: 像Java中的Stack Trace一样的错误堆栈信息 (仅Mozilla可用). 

如要判断异常信息的类型，可在catch中进行判断：

```javascript
try {
 foo.bar();
} catch (e) {
 if (e instanceof EvalError) {
     alert(e.name + ":" + e.message);
 } 
 else if (e instanceof RangeError) {
     alert(e.name + ": " + e.message);
 } 
 // etc 
}
```

JavaScript中的throw命令事实上可以抛出任何对象，并且我们可以在catch接受到此对象。例如：

```js
try {
 throw new Date(); // 抛出当前时间对象 
} catch (e) {
 alert(e.toLocaleString()); // 使用本地格式显示当前时间 
}
```

菜鸟教程try/catch应用

```js
function myFunction() {
    var message, x;
    message = document.getElementById("message");
    message.innerHTML = "";
    x = document.getElementById("demo").value;
    try { 
        if(x == "")  throw "为空";
        if(isNaN(x)) throw "不是一个数字";
        if(x > 10)   throw "太大了";
        if(x < 5)    throw "太小了";
    }
    catch(err) {
        message.innerHTML = "输入的值 " + err;
    }
}
```

#### axios返回的error对象获取信息

#### error.response

要用**error.response**才能拿到错误信息

#### 防抖和节流函数

##### 防抖函数 (规定时间内不触发事件才执行1次，触发就会重新计时)

```js
function debounce(fn,delay){
    let timer = null;
    return function(){
        let context = this;
        let args = arguments;
        if(timer) clearTimeout(timer);
        timer = setTimeout(function(){
            fn.apply(context,args) //apply绑定原作用域
        },delay)
    }
}
function loadSize(){
    console.log('屏幕在动')
}
window.addEventListner('resize',debounce(loadSize,1000))

```

##### 节流函数 (规定时间内仅执行一次，稀释函数执行频率)

```js
function throttle(fn,delay){
    let timer = null;
    return function(){
        let context = this;
        if(!timer){  //如果没有定时器，就设置一个定时器，执行相关操作
            timer = setTimeout(function(){
            /** 关键语句：
            	必须设置为null,不能用clearTimeout(timer)
            	因为定时器默认会返回一个timerId，clearTimeout只是清除了定时行为，并不会清除timerId
            */
                timer = null; 
                fn.apply(context) //apply绑定作用域
            },delay)
        }
    }
}
```



#### localStorage sessionStorage

localstorage以键值对的形式储存在本地中，可以在浏览器application-Local Storage中查看

```js
var local = document.getElementById('username').value
button.onclick = function(){
    localStorage.setItem('username',local)
}
```





#### css定义变量和使用变量

``` css
page {
    /*定义全局颜色*/
    --themeColor: #fff;
}

/*使用变量*/
view {
    color: var(--themeColor);
}
```



#### :nth-child 和 :nth-of-type区别

div:nth-child(n)   **父元素的第n个子元素** ，前面的同级元素有效，**若第n个不是div则不会生效**

div:nth-of-type(n)   **父元素的第n个div类型子元素**，前面的其他元素无效 ，只看同类型div

当用类名时：

.item:nth-of-type(n)  先看标签名再看类名，选择第n个含class类的子元素，前面没有类名的同类元素也被计算在序列内

``` html
<style>
    .item:nth-of-type(5){
        color:  red;
    }
</style>
<div>
    <p class="item">11hahahaha</p>
    <p>没class的ppppPppp</p>
    <p class="item">22hahahaha</p>
    <p>没class的PPPPPPPP</p>
    <!--该行会被渲染，因为是第5个p，前面没有item的P也计算在序列内-->
    <p class="item">333hahahaha</p>
    <p class="item">444hahahaha</p>
    <p class="item">555hahahaha</p>
  </div>
```





#### :nth-child(an+b) n取值范围

an+b中  n>=0   an+b>=1

nth-child(n) nth-child(n+1)   表达式范围都是>=1 选择所有元素

nth-child(n-x)  因为n-x >=-x &an+b>=1 所以 n-x>=1 表示选择所有元素

nth-child(n+2) 表达式范围>=2 选择第二个以及后面所有元素

nth-chidl(-n+2) 表达式范围<=2 结合>=1 所以选择[1,2]  也就是第一，第二个元素



last-of-child(n)   表达式范围>=1 选择所有元素

last-of-child(n+2) 表达式范围>=2 选择倒数第二个以及前面所有元素

last-of-child(-n+2) 表达式范围[1,2]  选择倒数第一个和倒数第二个元素



#### :last-of-type 和 :last-child区别

p:last-of-type   先看类型，再看这个类型下的最后一个，即最后一个p类的子元素

p:last-child  先看最后一个子元素， 若最后一个子元素不是p 则样式不生效

```html
<body>
    <p>我是p</p>
    <p>我是p</p>
    <p>我是p</p>
    <p>我是最后一个p</p>
    <div>我是最后一个div</div>
</body>
<style>
    //最后一个p生效 因为是父元素body下的最后一个p
    p:last-of-type {
        color: red;
    }
    // 这个p不会生效，因为父元素Body的最后一个子元素不是p
    p:last-child {
        color:blue;
    }
    // 会生效
    div:last-child {
        color: yellow
    }
</style>
```





#### es7异步请求方法async await

```js
//申明请求方法前加async关键词
async getGoods() {
    //使用es7 async/await发送请求。 res就是以前then()返回的数据
    const res = await request({url: '/homeData'})
    this.cates = res.data.message
    //渲染数据
    //.....
}

```



#### es6 findIndex()方法

```js
//findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置
//findIndex() 方法为数组中的每个元素都调用一次函数执行
//当数组中的元素在测试条件时返回 true 时,返回符合条件的元素的索引位置，之后的值不会再查询
//如果没有符合条件的元素返回 -1  findIndex不改变原数组
let arr = [0,3,11,20]
const result = arr.findIndex(function(val){
    return val >= 10    
})
console.log(result)  //输出2  因为arr中的第3项'11'满足条件，返回它的Index=2
```



#### map、forEach、filter注意点

map不会修改原数组(基本类型)，也会修改引用类型，会返回一个映射的新数组 **必须写return**

filter不会修改原数组，**用于筛选数组**，需要**链式调用**或者**新建一个变量保存**过滤后的数组

forEach方法里**修改基本类型不会生效**，**修改对象生效**，想要操作里面的基本数据类型，就用arr[i]的形式直接操作数组。



#### reduce(数组归并)

#### reduce源码

```js
//reduce原理：总的一句，reduce方法主要是把数组遍历，
//然后把数组的每个元素传入回调函数中，回调函数怎么处理，就会的到什么样的效果
Array.prototype._reduce=function(fn,initVal){
    let pre=initVal;//对初始值进行赋值
    let i=0;        //index初始值为0
    if(!pre){//判断是否拥有初始值，若没传初始值，pre从数组第一个值开始,index从1开始
        pre=this[0];
        i=1;
    }
    for(i;i<this.length;i++){
        //关键句：把每次回调函数执行的返回值赋给pre, 并作为下一次执行的值传入给回调
        pre=fn(pre,this[i],i); 
    }
    return pre;//返回回调函数处理的最终结果，
}
```

语法

```js
arr.reduce(function(prev,cur,index,arr){
...
}, init); //init可以设置{} [] 等任意数据
```

**arr** 表示原数组；
**prev** 表示上一次调用回调时的返回值，或者初始值 init;
**cur** 表示当前正在处理的数组元素；
**index** 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；
**init** 表示初始值。 初始值可以设置{} []等任意值

##### 1. 求数组项之和

```js
var arr = [3,9,4,3,6,0,9];
var sum = arr.reduce(function (prev, cur) {
    return prev + cur;
},0);//此处传入init值为0
```

由于传入了初始值0，所以开始时prev的值为0，cur的值为数组第一项3，相加之后返回值为3作为下一轮回调的prev值，然后再继续与下一个数组项相加，以此类推，直至完成所有数组项的和并返回。

##### 2. 求数组项最大值

```
var max = arr.reduce(function (prev, cur) {
    return Math.max(prev,cur);
});
```

由于未传入初始值，所以开始时prev的值为数组第一项3，cur的值为数组第二项9，取两值最大值后继续进入下一轮回调。

##### 3. 基本类型数组去重

```js
var newArr = arr.reduce(function (prev, cur) {
    prev.indexOf(cur) === -1 && prev.push(cur);
    return prev;
},[]);//prev初始值空数组
```

##### 4. 对象类型数组去重

```js
//对象数组去重 
let arr = [
            {
                key:'1',
                name:'林青霞'
            },
            {
                key:'2',
                name:'张三丰'
            },
            {
                key:'1',
                name:'段誉'
            },
        ]
const hash = {};
let res = arr.reduce((obj, next: Object) => {
    const hashId = `${next.topic}_${next.stream_id}`;
    //根据key值去重，若不存在则设置为true,并添加到数组中，若存在则跳过
    if (!hash[hashId]) {
      hash[`${next.topic}_${next.stream_id}`] = true;
      obj.push(next);
    }
    return obj;
}, []); //将返回值的初始值定义为空数组

console.log(res) // 去重后数组:[{key: '1', name: '林青霞'},{key: '2', name: '张三丰'}]



// mill_pad端 reduce去重写法
initListInfo: function(goodList) {
    let arr = [];
    let productPut = 0;
    let putText = '';
    let returnNum = 0;
    for (let i = 0; i < goodList.length; i++) {
        let obj = {};
        obj.category_id = goodList[i].category_id;
        obj.category_name = goodList[i].category_name;
        obj.goodList = [];
        arr.push(obj);
    }
    //根据对象的属性去重，获取新数组
    let hash = {}; 
    let cateArr = arr.reduce(function(arr, current) {
        hash[current.category_id] ? '' : (hash[current.category_id] = true && arr.push(current));
        return arr;
    }, []);

    for (let i = 0; i < goodList.length; i++) {
        if (goodList[i].menu_status.value == 3) {
            //已上菜
            productPut++;
        }
        if (goodList[i].menu_status.value == -2) {
            //已退菜
            returnNum++;
        }
        if (returnNum == goodList.length) {
            putText = '正在上菜(0/0)';
        } else if (productPut >= goodList.length - returnNum) {
            putText = '上菜完毕，待买单';
        } else {
            putText = '正在上菜(' + productPut + ' / ' + Number(goodList.length - returnNum) + ')';
        }
        for (let j = 0; j < cateArr.length; j++) {
            if (goodList[i].category_id == cateArr[j].category_id) {
                cateArr[j].goodList.push(goodList[i]);
            }
        }
    }
    this.setData({
        cateArr: cateArr,
        putText: putText,
        totolGoods: Number(goodList.length - returnNum)
    });
},
```



#### map源码

```js
var arr = [1, 2, 3, 4, 5]
Array.prototype.myMap = function(fn){
    var len = this.length;
    //创建新数组
    var arr = [];
    for(var i = 0; i < len; i ++){
        arr.push(fn(this[i],i)) //将函数的返回值添加到返回数组，注意函数必须有返回值！
    }
    return arr;
}
var aa = arr.myMap(function(ele, index){
    return ele * 2;

```



#### forEach源码

```js
//1. 使用 call 方式
Array.prototype.forEach =function(callback,thisArg){
  varlen =this.length;
  for(vari =0; i < len; i++){
   // callback(this[i], i,this);
   callback.call(thisArg,this[i], i,this);
  }
}
//2. 使用 bind 方式
Array.prototype.forEach =function(callback,thisArg){
 varlen =this.length;
 callback = callback.bind(thisArg);
 for(vari =0; i < len; i++){
  callback(this[i], i,this);
 }
}
```

#### filter源码

```js
Array.prototype.myFilter = function(fn){
  let newArr = [];
  for(let i =0, len = this.length; i < len; i++){
    fn(this[i]) && newArr.push(this[i])  //等价于if(fn(this[i])){ newArr.push(this[i]) }
  }
  return newArr; //返回新数组
}

//调用myFilter方法，以函数为参数的高阶函数
var arr = [2,3,5,23,57]
arr.myFilter(function(item){
  return item > 3; //此处return值为true,加入了新数组，然后新数组返回
})
```



```js
//forEach修改原数组方法
let arr = [1,2,3]
arr.forEach((value, key) => {
 return arr[key] = value * value;  // arr = [1,4,9]
});
//map修改数组方法
let list = arr.map(value => {   
 return value * value;     //list = [1,4,9]
});

```



#### map/forEach区别点

1.都是循环遍历数组中的每一项

2.都不需要初始值和写条件表达式

3.参数都有3个，item循环的每一项，index索引值，arr原数组

4.只能遍历数组,遍历对象会报错

5.map和forEach本身不能终止循环,原因就是map和forEach第一个参数是函数，所以内部不会捕获错误



#### padding左右边距不能设置auto,会失效



#### flex布局内使用white-space:nowrap要设置固定宽度，否则会挤压左右内容



#### 字体图标大小调整使用font-size属性



### 数组splice方法

```js
var fruits = ["Banana", "Orange", "Apple", "Mango"];
// 从索引2处，删除0个元素，并插入2个元素
fruits.splice(2,0,"Lemon","Kiwi"); //fruits输出：Banana,Orange,Lemon,Kiwi,Apple,Mango
```



语法:

*array*.splice(*index*,*howmany*,*item1*,.....,*itemX*)

**注意：splice会默认返回删除的元素数组**

![img](https://www.runoob.com/wp-content/uploads/2013/08/9F673968-EB30-48C7-90F6-8CE14E737BC1.png)

| 参数                  | 描述                                                         |
| :-------------------- | :----------------------------------------------------------- |
| *index*               | 必需。规定从何处添加/删除元素。 该参数是开始插入和（或）删除的数组元素的下标，必须是数字。 |
| *howmany*             | 可选。规定应该删除多少元素。必须是数字，但可以是 "0"。 如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。 |
| *item1*, ..., *itemX* | 可选。要添加到数组的新元素                                   |

### vue重要概念

#### 全局API (常用) 

##### **Vue.set**

Vue.set( target, propertyName/index, value )

向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property 

(比如 `this.myObject.newProperty = 'hi'`)



##### Vue.nextTick

Vue.nextTick( [callback, context\] )

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。



##### Vue.filter

Vue.filter( id,  [definition] )

注册全局过滤器



##### Vue.component

Vue.component(id, [definition])

注册全局组件



#### 实例property

##### vm.$data

读取Vue实例中data的属性，可能包含多个键值对

```js
const vm = new Vue({
    data: {
        list: 'xxxx',
        counter: 'bbbb'
    }
})

//等价
vm.$data.list === vm.list
```



##### vm.$el

$el 获取vue实例关联的DOM根元素

##### vm.$parent / vm.$children

$parent: 父实例，如果当前实例有的话

$children: 当前实例的直接子组件, $children并不是响应式的

##### vm.$root

$root ： Vue根组件实例

```js
new Vue({
    data: {
        foo: 1
    },
    methods: {
        fn1:function(){}
    }
})
//所有的子组件都可以将这个实例作为一个全局 store 来访问或使用，但是大型应用推荐VueX来管理应用状态
this.$root.foo
this.$root.fn1()
```



##### vm.$refs

ref 被用来给元素或子组件注册引用信息， 引用信息将会注册在父组件的 $refs 对象上，如果是在普通的DOM元素上使用，引用指向的就是 DOM 元素，如果是在子组件上，引用就指向组件的实例。

ref 加在子组件上，用this.$refs.（ref值） 获取到的是组件实例，可以使用组件的**所有方法及data的变量**

```html
<base-input ref="userNameInput"></base-input>
```

```js
//访问子组件
this.$refs.userNameInput
```



##### vm.$slots / vm.$scopedSlots

##### vm.$attrs

##### vm.$listeners

#### 实例方法

##### vm.$watch

##### vm.$set /vm.$delete

##### vm.$on

监听当前实例上的自定义事件。事件可以由 `vm.$emit` 触发。回调函数会接收所有传入事件触发函数的额外参数。

```js
vm.$on('test', function (msg) {
  console.log(msg)
})
vm.$emit('test', 'hi')
// => "hi"
```



##### vm.$emit

vm.$emit( eventName, […args\] )]

触发当前实例上的事件。附加参数都会传给监听器回调

#### 动态组件

```vue
<!--根据is传入的值 动态渲染要展示的组件-->
<!--home就是组件name: 'home'对应的名称，动态组件也像普通组件一样传值-->
<component is="home" :data="xxdata"></component>
```



#### vue插件安装

向vue添加全局功能时，通常用插件形式，有2种编写方式

1. 对象类型  一个对象，必须包含一个install函数，会在安装插件时执行
2. 函数类型 一个function 会在安装插件时执行

#### vue跨域配置

```js

//test.config.js文件 给window全局对象添加的额外属性
window.config = {
  mock: false,
  successCode: '0',
  returnCode: 'return_code',
  returnMessage: 'return_message',
  baseUrl: 'http://10.10.100.25:9090/iboss',
  SUCCESS_CODE: '000000',
  RETURN_CODE: 'code',
  RETURN_MESSAGE: 'message',
  PAPERLESS_RETURN_CODE: 'returnCode',
  PAPERLESS_RETURN_MESSAGE: 'returnMsg',
  PAPERLESS_SUCCESS_CODE: '1',
  PAPERLESS_AREA_CODE: '0791',
  APP_ID: 'iboss_hz',
  COLLECT_PATH: 'http://10.10.100.25:9090/collect/collect',
  COLLECT_APP_ID: 'gehua-iboss',
  COLLECT_APP_KEY: '6yqz442885bgtj0wsyjo'
}

// api/index.js 请求文件  
axios.defaults.baseURL = window.config.baseUrl  
axios.defaults.headers = {
  'Content-Type': 'application/json'
}

// config/index配置文件
proxyTable: {
      '/api': {
        target: 'http://10.10.100.99:9090',
        changeOrigin: true,
        pathRewrite: {
          '^/api': '/iboss'
        }
      }
    }
```



####  监听属性watch

```js
var watchExampleVM = new Vue({
  el: '#watch-example',
  data: {
    question: '',
    answer: 'I cannot give you an answer until you ask a question!'
  },
  watch: {
    // 如果 `question` 发生改变，这个函数就会运行
    question: function (newQuestion, oldQuestion) {  //监听函数会传入新值和旧值2个参数
      this.answer = 'Waiting for you to stop typing...'
      this.debouncedGetAnswer()
    }
  },
```



#### 绑定class的一些用法

##### 1.绑计算属性

```html
<!--绑计算属性-->
<!--渲染结果class="active text-danger"-->
<div :class="{classObj}"></div>

```

```js
data: {
    isActive: true,
    error: null
},
computed:{
    classObj(){
        return {
            active: this.isActive && !this.error,
            'text-danger': this.error && this.error.type === 'fatal'
        }
    }
}
```

##### 2.绑数组

```html
<!--渲染结果class="active text-danger"-->
<div :class="[activeClass,errorClass]"></div>
<!--三元表达式动态切换-->
<div :class="[isActive ? activeClass : '', errorClass]"></div>
<!--对象语法切换-->
<div v-bind:class="[{ active: isActive }, errorClass]"></div>

```

```js
data: {
    activeClass: 'active',
    errorClass: 'text-danger'
}
```

##### 3.绑style样式

```html
<div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
```

##### 

#### v-show 和 v-if 区别

`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。

`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。

一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。



#### v-for 和 v-if 一起使用（官方不推荐一起用）

v-for优先级比v-if高



#### 绑定key不要用Index 



#### v-for遍历对象

```html
<!--返回object的所有value值-->
<div v-for="value in object">
	{{value}}
</div>
```

```js
data: {
    object: {
        name: 'david',
        age: 33,
        title: 'xxxx'    
    }
}
```

#### v-for遍历计算属性

```html
<!--遍历返回能被2整除的数组-->
<li v-for="n in evenNumbers">{{ n }}</li>
```

```js
data: {
    numbers: [1,2,3,4,5]
},
computed: {
    evenNumbers(){
        return this.numbers.filter(item => {
            return item % 2 === 0
        })
    }
}
```

#### v-for嵌套遍历（计算属性不适用时）

```html
<ul v-for="set in sets">
    <li v-for="n in even(n)">{{n}}</li>
</ul>
```

```js
data: {
    sets: [[1,2,3],[4,5,6]]
},
methods: {
    even(numbers){
        return numbers.filter(item => {
            return item % 2 === 0
        })
    }
}
```



#### v-on绑定事件

有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 `$event` 把它传入方法：

```html
<button v-on:click="warn('Form cannot be submitted yet.', $event)">
  Submit
</button>
```

```js
// ...
methods: {
  warn: function (message, event) {
    // 现在我们可以访问原生事件对象
    if (event) {
      event.preventDefault()
    }
    alert(message)
  }
}
```

#### 事件修饰符

```html
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>
```



#### 修饰符顺序

使用修饰符时，顺序很重要；因此，用 `v-on:click.prevent.self` 会阻止**所有的点击**(阻止了默认事件，也就阻止了click事件)

而 `v-on:click.self.prevent` 只会阻止对元素自身的点击。(阻止click事件，就不会执行阻止默认事件)



#### v-model

v-model : 双向绑定
一般用于绑定表单输入的内容,限制在<input>、<select>、<textarea>、components中使用

v-model其实是语法糖:
<input v-model="test">本质上是
<input :value="test" @input="test = $event.target.value">   //绑定输入框的value值，@input是对输入事件的监听，再把监听到的值放入value

checkbox v-model="checkedNames"

<input type=checkbox  @change="checkedNames=$event.target.value">

##### v-model修饰符

.lazy   将input的实时更新转换为change事件，即改变完后更新

.number v-model默认是字符串，将绑定值转化为Number类型

.trim  过滤用户输入的首尾空格

##### v-model绑定复选框

```html
<!--把复选框的value值传给了checkedNames-->
<input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
<label for="jack">Jack</label>
<input type="checkbox" id="john" value="John" v-model="checkedNames">
<label for="john">John</label>
<input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
<label for="mike">Mike</label>
<br>
<!--span根据checkbox选择显示对应的复选框value值-->
<span>Checked names: {{ checkedNames }}</span>
```

```js
new Vue({
  el: '...',
  data: {
    checkedNames: []
  }
})
```

##### v-model绑定下拉框

```html
<div>
    <select v-model="selected">
    	<option disabled value="">请选择</option>
        <option>A</option>
        <option>B</option>
        <option>C</option>
    </select>
    <!--显示对应选择的A或B或C-->
    <span>selected: {{selected}}</span>
</div>
```

```js
data: {
    selected: ''
}
```



#### prop静态或动态传值

```html
<!--静态传值 子组件获取一个字符串-->
<my-cpn title="my journey"></my-cpn>

<!--动态传值 获取Item的title属性-->
<my-cpn :title="item.title"></my-cpn>
```

##### 子组件变更prop 

prop是单向数据流，父级更新流动到子组件，反向不行

1.**这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。**在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：

```js
props: ['initialName'],
data: function(){
    return {
        name: this.initialName
    }
}
```

2.**这个 prop 以一种原始的值传入且需要进行转换。**在这种情况下，最好使用这个 prop 的值来定义一个计算属性：

```js
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
```

注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身**将会**影响到父组件的状态。

prop指定类型

```js
props: {
    //基础数值类型
    myNumber: Number,
    xxxList: {
        type: Array,  //数组类型  
        default() {   //数组或对象类型必须从一个函数中返回
            return []
        }
    }， 
    //自定义验证函数
    validator: function(value){  
        return ['success','warning','danger'].indexOf(value) !== -1
    }
}
```



#### 将事件绑定到组件 .native

当组件外包一层根元素时，**监听<input>这类特别元素时** .native会失效，需要使用$listeners，将监听器指向组件中的某个特定元素

```html
<!--当父级调用这个组件并使用.native监听事件时会失效，-->
<base-input v-on:focus.native="onFocus"></base-input>

<!--子组件根元素是label-->
<label>
    {{label}}
	<input v-bind="$attrs" :value="value" @input="$emit('input',$event.target.value)" />
</label>
```

```js
//有了这个 $listeners property，你就可以配合 v-on="$listeners" 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 <input> 的你希望它也可以配合 v-model 工作的组件来说，为这些监听器创建一个类似下述 inputListeners 的计算属性通常是非常有用的：
//<base-input>就是一个透明的包裹器了，不必使用.native监听了
Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  computed: {
    inputListeners: function () {
      var vm = this
      // `Object.assign` 将所有的对象合并为一个新对象
      return Object.assign({},
        // 我们从父级添加所有的监听器
        this.$listeners,
        // 然后我们添加自定义监听器，
        // 或覆写一些监听器的行为
        {
          // 这里确保组件配合 `v-model` 的工作
          input: function (event) {
            vm.$emit('input', event.target.value)
          }
        }
      )
    }
  },
  template: `
    <label>
      {{ label }}
      <input
        v-bind="$attrs"
        v-bind:value="value"
        v-on="inputListeners"
      >
    </label>
  `
})
```



#### v-slot 

vue2.6.0以后 **slot  attribute具名插槽**和**slot scope attribute作用域插槽** 已在vue3中废弃， 使用**v-slot**代替

即`<div slot="header">` 这种写法已废弃

```html
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>

<!--v-slot必须用在<template>标签上(只有后面一种例外)-->
<base-layout>
  <template v-slot:header>
    <h1>Here might be a page title</h1>
  </template>

  <p>A paragraph for the main content.</p>
  <p>And another one.</p>

  <template v-slot:footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>
```

#### 作用域插槽

作用域插槽是绑定数据的插槽，可以获取到父组件传递的参数，将这些参数使用到子组件插槽里

```html
<!--<current-user>组件-->
<span>
  <slot>{{ user.lastName }}</slot>
</span>
<!--父组件想改变渲染的值,这种写法是不通的，父组件无法获取子组件的user-->
<current-user>{{user.firsrName}}</current-user>


<!--正确写法-->
<!--把user当做slot的一个属性绑定上去-->
<span>
    <!--这个叫插槽prop 把user作为值传给父组件-->
    <slot :user="user">{{user.lastName}}</slot>
</span>


<current-user>
    <!--包裹template 使用带值的v-slot来定义插槽名字,就可以通过slot的属性获取到user-->
	<template v-slot:default="slotProps">
    	{{slotProps.user.firstName}}
    </template>
</current-user>

```

#### 作用域插槽2

```vue
<!--创建作用域插槽-->
Vue.component("todo-list",{
    inheritAttrs:false,
    props:{
        todos:[Array,Object]
    },
    template:
    `<ul>
        <li v-for="todo in todos" :key="todo.id" style="display: block;" >
            <slot :data="todo">{{todo.text}}</slot>
        </li>
     </ul>`
	})

<!--使用作用域插槽，通过slot-scope实现-->
<todo-list :todos="todos">
    <template slot-scope="slotProps">
        <span v-if="slotProps.data.isTrue">√</span>
        {{slotProps.data.text}}
    </template>
</todo-list>
```



#### 封装-作用域插槽组件

普通做法：使用$emit层层传递自定义事件，但是组件和业务逻辑耦合度高

使用作用域插槽目的： 组件和业务的剥离

![img](https://img-blog.csdnimg.cn/img_convert/d4e88ac23aa6c4d5f5e037874fecae6d.png)

```vue
//3层组件 columnList--> commodityList--> commodity
//通过作用域插槽将本应该由CommodityList处理的商品卡片点击业务onCommodityClick提升到ColumnList处理
//columnList.vue
<el-row :gutter="20">
        <el-col :span="12" v-for="(column, index) in columnList" :key="index">
            <el-card class="box-card card-column">
                <div slot="header" class="clearfix">
                    <span>{{column.columnName}}</span>
                </div>
                <commodity-list :commodities="column.commodityList">
                    <template slot-scope="scope">
   <!-- 这里只需要给Commodity组件传入数据，响应Commodity组件的clickCommodity事件即可。事件不必携带参数，完全符合父到子的数据流向，而不会发生子组件又给父组件反向发数据的情况 -->
                        <commodity :modityData="scope.row" 		                        						@clickCommodity="onCommodityClick(scope.row)">
                        </commodity>
                    </template>
                </commodity-list>
            </el-card>
        </el-col>
</el-row>


<!-- CommodityList.vue  slot接收来自父组件的商品卡片组件 -->
<el-row :gutter="20">
        <el-col :span="8" v-for="(item, index) in commodities" :key="index" style="margin-top:20px;">
            <slot :row="item"></slot>
        </el-col>
</el-row>


<!--原commodity-list.vue 逻辑-->
<commodity v-for="(item,index) in commodities" @clickCommodity="onCommodityClick"></commodity>
```





#### 独占默认插槽(v-slot可以写在组件标签上)

当被提供的内容**只有默认插槽**时，组件的标签才可以被当作插槽的模板来使用。可以把 `v-slot` 直接用在组件上

**不能和具名插槽混用**，会导致作用域不清楚。混用时依然要写在Template上

```html
<current-user v-slot:default="slotProps">
	{{slotProps.user.firstName}}
</current-user>
```



#### 插槽缩写: v-slot可以缩写成#  

```html
<current-user>
	<template #header>
    	{{user.firstName}}
    </template>
</current-user>
```



#### filters过滤器

过滤器可以用在2个地方：{{ }}内 或 v-bind表达式

```html
<!--1.双花括号内-->
<div>{{number | filterNumber}}</div>

<!--2.v-bind表达式内-->
<div v-bind:time="formatTime"></div>
```



#### 解构赋值

```js
let node = {
    type: 'hahaha',
    name:'david'
}
let {type, name} = node 
console.log(type)  //hahaha
console.log(name) //david

//name重命名为localName
let {type, name: localName} = node
console.log(localName) //david
```



#### 跨域的几种解决方案

```js
//1.原生跨域
var script = document.createElement('script')
//传参给服务器，里面包含了服务器要执行的回调函数
script.src = 'https://www.domain2.com:8080/login?user=admin&callback=getData'
document.head.appendChild(script)
//回调执行函数
function getData(res){
    alert(JSON.stringify(res))
}
//服务端把data传进去
getData({'status': true, 'user': 'admin'})


//2.jquery+jsonp跨域
$.ajax({
    url: 'http://www.domain2.com:8080/login',
    type: 'get',
    dataType: 'jsonp',
    jsonpCallback: 'handleCallback', //回调函数名称 传给后端用
    data: {},
    success: function(response,status,xhr){
        console.log('状态为'+status+,'状态是'+xhr.statusText)
        console.log(response)
    }
})

//3.vue跨域配置代理
module.exports ={
    dev: {
        proxyTable: {
            //把所有的接口统一规范为一个入口，在一定程度上会解决冲突
            '/api': {
                target: 'http://localhost:3000',
                changeOrigin: true //是否允许跨域的配置
                //pathRewrite: {'^/api' : ''} //后面可以使重写的新路径，一般不做更改
            }
        }
    }
}
```



#### BFC机制

合理利用bfc机制可以解决**margin塌陷**，**float导致父元素高度塌陷**等问题

**BFC概念**

每一个BFC区域只包括其子元素，不包括其子元素的子元素。(这1点比较容易理解)

每一个BFC区域都是独立隔绝的,互不影响!(这点不太好理解，但是后续会使用代码验证)

**触发BFC的条件**

·body根元素

·设置浮动，不包括none

·设置定位，absoulte或者fixed

·行内块显示模式，inline-block

·**设置overflow(常用)，即hidden，auto，scroll**

·表格单元格，table-cell

·弹性布局，flex

```html
<!--#HM_bfc1是一块BFC区域，这块区域包含了box2、box3、box4、box5，也就是所有#HM_bfc1的子元素。同时#HM_bfc2也创造了一块BFC区域，包含了box6，box7，box8。注意，第一个box1的BFC，只包括box1的子元素box2345，不包括box678。#HM_bfc2这个BFC同样也仅仅是包括自己的子元素box678。-->
<div class="box1" id="HM_bfc1">
    <div class="box2">div>
    <div class="box3">div>
    <div class="box4">div>
    <div class="box5" id="HM_bfc2">
        <div class="box6">div>
        <div class="box7">div>
        <div class="box8">div>
    </div>
</div>
```



### webpack配置优化

#### build发布时 删除所有console代码

```js
//babel.config.js
const prodPlugin = []
//proccess.env.NODE_ENV 获取当前环境常量
if(proccess.env.NODE_ENV === 'production'){
    prodPlugin.push('transform-remove-console')//发布阶段删除console代码的插件
}
module.exports = {
    presets: ['@vue/app'],
    plugins: [
        [
             'component',
        {
            libraryName: 'element-ui',
            styleLibraryName: 'theme-chalk'
        }
        ],
        ...prodPlugin  //配置要生效的插件
       
    ]
    
}
```

#### 据开发环境配置不同的入口文件main-prod.js / main-dev.js

```js
//vue.config.js
//chainWebpack和configureWebpack是一样的效果
module.exports = {
    chainWebpack: config => {
        //发布模式
        config.when(proccess.env.NODE_ENV === 'production', config => {
			config.entry('app').clear().add('./src/main-prod.js')
            //发布模式把所有依赖包都通过CDN模式引入，压缩发布包大小
            //此时main-prod.js文件内的import文件都可以删除了
            config.set('externals',{//externals加载外部CDN资源
                vue: 'Vue',
                'vue-router': 'VueRouter',
                axios: 'axios',
                lodash: '_',
                echarts: 'echarts',
                nprogress: 'NProgress'
            })
        })
        //开发模式
        config.when(proccess.env.NODE_ENV === 'development', config => {
			config.entry('app').clear().add('./src/main-dev.js')
        })
    }
}
```

```html
<!--public/index.html 发布包文件内引入上面externals配置要引入的依赖包-->
<html>
    <head>
       <!--引入css依赖文件--> 
        <link rel="styleSheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css"></link>
    <!--引入js依赖文件 等等-->
    <scrpit src="https://cdn.staticfile.org/vue/2.5.22/vue.min.js"></scrpit>
    <scrpit src="https://cdn.staticfile.org/vue-router/3.0.1/vue-router.min.js"></scrpit>
    <scrpit src="https://cdn.staticfile.org/lodash.js/1.0.2/lodash.min.js"></scrpit>
    </head>
</html>
```



### Object.assign 合并对象

将源对象（source）的所有可枚举属性，复制到目标对象（target）。

```js
const target = { a: 1 };

const source1 = { b: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}

//实际用法
//将多个对象合并到某个对象
const merge = (target, ...sources) => Object.assign(target, ...sources);

//合并多个对象并返回一个新对象
const merge = (...sources) => Object.assign({}, ...sources);

//将属性x,y添加到对象point类对象实例中
class Point {
  constructor(x, y) {
    Object.assign(this, {x, y});
  }
}

//给对象添加方法
Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});

// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) {
  ···
};
SomeClass.prototype.anotherMethod = function () {
  ···
};
```

### Object.keys()

方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。

```js
var anObj = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.keys(anObj)); // console: ['2', '7', '100']

var arr = ['a', 'b', 'c'];
console.log(Object.keys(arr)); // console: ['0', '1', '2']

var obj = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.keys(obj)); // console: ['0', '1', '2']

// getFoo is a property which isn't enumerable
var myObj = Object.create({}, {
  getFoo: {
    value: function () { return this.foo; }
  }
});
myObj.foo = 1;
console.log(Object.keys(myObj)); // console: ['foo']
```



### Object.values()

返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用[`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in)循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。

```js
var obj = { foo: 'bar', baz: 42 };
console.log(Object.values(obj)); // ['bar', 42]

// array like object
var obj = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.values(obj)); // ['a', 'b', 'c']

// array like object with random key ordering
// when we use numeric keys, the value returned in a numerical order according to the keys
var an_obj = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.values(an_obj)); // ['b', 'c', 'a']

// getFoo is property which isn't enumerable
var my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });
my_obj.foo = 'bar';
console.log(Object.values(my_obj)); // ['bar']

// non-object argument will be coerced to an object
console.log(Object.values('foo')); // ['f', 'o', 'o']
```



### 字符串转数字，数字转字符串快捷方法

```js
//字符串转数字, 字符串-0
let str = '123'
console.log(str - 0) // 123

//数字转字符串，后面+ ''
let str2 = 123
console.log(str2 + '') //'123' 
```



### css常用样式

```css

.cate-name{
  display: inline-block;
  position: relative;
  font-size: 34rpx;
  line-height: 1;
  margin: 32rpx 0rpx 20rpx 0rpx;
}
/*利用after伪元素给文字添加背景色*/
.cate-name::after{ 
  position: absolute;
  top: 0rpx;
  left: 0rpx;
  right: 0rpx;
  content: '';
  z-index: -1;
  bottom: 0rpx;
  border-radius: 50%;
  background: rgba(248, 182, 44, 1);
}

/*阴影样式*/
.card{
  padding: 30rpx 28rpx;
  width: 686rpx;
  box-sizing: border-box;
  box-shadow:0px 4px 6px 0px rgba(0,0,0,0.1); /*关键语句*/
  border-radius:8rpx;
  background: #fff;
  margin: 10rpx auto 26rpx auto;
}
```

### line-height: 1

line-height：1 ，相当于line-height：100%，会根据该元素本身的字体大小设置行高，比如字体大小是15px，行高就是15px

line-height：1.5，相当于line-height：150%；
line-height：0.5，相当于line-height：50%。

### 负margin

![1.gif](https://img.gxlcms.com//Uploads-s/new/2020-06-01-wenti/1537328821879881.gif)

一个static元素是一个没有使用过float的元素。上面的图片展示了一个static的元素使用负边距之后的情况。

当一个static元素在top/left使用负边距时，它把元素向这个特定的方向拉，

但是当你将负边距设置为相对bottom/right时，它并不会把元素向下或右拉，相反，它会把后面的元素往里面拉，从而覆盖自己。

margin为负且盒子static时：

- 若属性为top、left，盒子将被拉进指定的方向;
- 若属性为bottom、right,将后续的元素拖拉进来，覆盖本来的元素。
- 若width没有被设置，设定负margin-left/right会将元素拖向对应的方向，并增加宽度，此时的margin的作用就像padding一样

### filter源码

```js
 Array.prototype.my_filter = function (callback) {
        if (!Array.isArray(this) || !this.length || typeof callback !== 'function') {
            return []
        } else {
            let result = [];
            for (let index = 0; index < this.length; index++) {
                const element = this[index];
                if (callback(element, index, this)) {
                    result.push(element)
                }
            }
            return result
        }
    }

    let arr = [1, 2, 3, 4, 5]
    let res = arr.my_filter((ele, i) => {
        return ele % 2 === 0
   	})
        console.log(res)//[2,4]
```





### break、return区别

1、break：是立即结束循环语句，并跳出循环语句，进行下个语句执行。

2、continue：是停止当前循环语句，并开始一次新的循环。

3、return：只能出现在函数中，用来停止函数。

4、使用的语句环境不一样，break和continue是用在循环或switch语句中，return是用在函数语句中。

### for循环里的可以return跳出循环，forEach里的return只能终止当前循环



### 原型链

①所有**`引用类型`**都有一个`__proto__(隐式原型)`属性，属性值是一个普通的对象 
②所有**`函数`**都有一个`prototype(原型)`属性，属性值是一个普通的对象 
③所有**引用类型**的__proto__属性`指向`它**构造函数**的**prototype**

```js
var a = [1,2,3];
a.__proto__ === Array.prototype; // true
a.constructor === Array //true
Array.prototype.constructor === Array //true
```

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20180620134143385?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9lcm1pbmdu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![img](https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png)



### 设置cookie

```js
//设置cookie
function setCookie(name,value,days){
    var date = new Date();
    date.setTime(date.getTime()+days*24*3600*1000);
    var expire = ';epxires=' + date.toDateString();
    document.cookie = name + '=' + value + expire + ';/path'
}
//常规获取value写法
function getCookie(name){
    var cookieStr = $('#cookieName').val() + '=';
    var cArr = document.cookie.split(';');
    for(var i=0;i<cArr.length;i++){
        var cookie = cArr[i];
        //去掉每个cookie字段前面的空格
        while(cookie.charAt(0)==' '){
            cookie = cookie.substring(1,cookie.length);
        }
        //匹配到要获取的cookie值
        if(cookie.indexOf(cookieStr)==0){
            //截取value
           $('#cookieVal').val(cookie.substring(cookieStr.length,cookie.length))
        }
    }
}

//善语代码
export const setCookie = (name, value, expiredays) => {
	var exdate = new Date();
	exdate.setDate(exdate.getDate() + expiredays);
	document.cookie = name + "=" + escape(value) + ((expiredays == null) ? "" : ";expires=" + exdate.toGMTString()) + ";path=/";
}

export const getCookie = (name) => {
    //正则匹配设置了多个匹配规则，会返回多个匹配项
	var arr, reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)");
    //此处match匹配会返回一个数组，数组第3个是value
	if(arr = document.cookie.match(reg)) {
		return unescape(arr[2]);//第3个就是value
	} else {
		return null;
	}
}
```



### 基于发布订阅模式的事件绑定机制

![img](https://upload-images.jianshu.io/upload_images/910389-4d24c83c29727ec2.png?imageMogr2/auto-orient/strip|imageView2/2/w/741/format/webp)



### vue-provide/inject机制

这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。

provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。

inject 选项应该是：
 一个字符串数组，或
 一个对象，对象的 key 是本地的绑定名，value 是：
 在可用的注入内容中搜索用的 key (字符串或 Symbol)，或
 一个对象，该对象的：
 from 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol)
 default 属性是降级情况下使用的 value

**使用场景：由于vue有$parent属性可以让子组件访问父组件。但孙组件想要访问祖先组件就比较困难。通过provide/inject可以轻松实现跨级访问祖先组件的数据**

```js
// 父组件中返回要传给下级的数据
  provide () {
    return {
      reload: this.reload
    }
  },
 methods: {
    reload () {
      this.isRouterAlive = false
      this.$nextTick(() => {
        this.isRouterAlive = true
      })
    }
  }

//子组件inject调用
//引用vue reload方法
  inject: ['reload'],
  methods: {
    // ...mapActions(['freshList']),
    async successHandle () {
      this.reload()
    }
  }
```



### vuex相关概念

```vue
<script>
export default {
// computed内放state和getters
computed: {
    ...mapState({
      paperlesssSignNo: state => state.operator.signNo,
      operatorData: state => state.operator.data,
      collectionRelationKinds: state => state.collectionRelation.kinds,
      collectionRelationKindIndex: state => state.collectionRelation.kindIndex,
      customerList: state => state.customer.list,
      customerIndex: state => state.customer.index,
      collectionRelationList: state => state.collectionRelation.list,
      collectionRelationIndex: state => state.collectionRelation.index,
      pageSelectTabKey: state => state.page.selectTabKey
    }),
    ...mapGetters({
      ENUMS_GET_NAME,
      ENUMS_GET_KEY_VALUE,
      COLLECTION_RELATION_GET_KINDS
    })
},
// methods内放action和mutation
methods: {
    ...mapMutations({
      COLLECTION_RELATION_SET_KIND_INDEX,
      ORDER_PARAM_SET_INFOS
    }),
    ...mapActions({
      BANK_SIGN_GET_AUTH_CODE,
      BANK_SIGN_UNSIGN,
      BANK_SIGN_SUBMIT_AUTH_CODE,
      BANK_SIGN_QUERY_ENTRUST,
      BANK_SIGN_GET_PRODINSTID
    }),
}
}
</script>
```



state常规用法

用data接收state值不能及时响应更新,用**computed**就可以

```js
//state.js
let state = {
    count: 1,
    name: 'xxx',
    age: 33,
    from:'china',
    sex: 'male'
}
export default state
```



```js
const Counter = {
  template: `<div>{{ count }}</div>
			 <div>{{ dataCount }}</div>`,
    
  //data接收state值是无法实时刷新页面数据的
   data(){
     return {
         dataCount: this.$store.state.count
     } 
  },
    //computed内接收state值才可以及时响应
  computed: {
    count () {
      return this.$store.state.count
    }
  }
}
```

#### mapState

当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 `mapState` 辅助函数帮助我们生成计算属性

```js
// 在单独构建的版本中辅助函数为 Vuex.mapState
import { mapState } from 'vuex'

export default {
  // ...
  computed: mapState({
    // 箭头函数可使代码更简练
    count: state => state.count,

    // 传字符串参数 'count' 等同于 `state => state.count`
    countAlias: 'count',

    // 为了能够使用 `this` 获取局部状态，必须使用常规函数
    countPlusLocalState (state) {
      return state.count + this.localCount
    }
  })
}


```

```js
//当映射的计算属性的名称与 state 的子节点名称相同时，可以给 mapState 传一个字符串数组
computed: mapState([
  // 映射 this.count 为 store.state.count
  'count'
])
```

#### 展开运算符

```js
//mapState 函数返回的是一个对象,可以使用展开运算符与局部计算属性混合使用
computed: {
  localComputed () { /* ... */ },
  // 使用对象展开运算符将此对象混入到外部对象中
  ...mapState({
    // ...
  })
}
```



#### getters

getters相当于store的计算属性，接受state作为第一个参数

```js
const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: '...', done: true },
      { id: 2, text: '...', done: false }
    ]
  },
  getters: {
    doneTodos: state => {
      return state.todos.filter(todo => todo.done)
    }
  }
})
//Getter 会暴露为 `store.getters` 对象，你可以以属性的形式访问这些值：
store.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]

//Getter 可以接受其他 getter 作为第二个参数：
getters: {
   // ...
  doneTodosCount: (state, getters) => {
    return getters.doneTodos.length
  }
}
store.getters.doneTodosCount // -> 1

/*
通过方法访问
你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。
*/
getters: {
  // ...
  getTodoById: (state) => (id) => {
    return state.todos.find(todo => todo.id === id)
  }
}
store.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }
```



##### 延伸：函数柯里化 传额外参数

官方解释:是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，

并且返回接受余下的参数而且返回结果的新函数的技术

```js
//ES5实现
function add(x){
  return function(y){
    return y + x;
  };
}

var addTwo = add(2);
addTwo(3);          // => 5
add(10)(11);        // => 21
//add函数接受x，返回一个函数接受y返回y＋x。如何用箭头函数实现同样功能呢？我们知道：

//箭头函数体是表达式，并且箭头函数隐式返回表达式，所以为了实现高阶函数，我们可以使箭头函数的函数体为另一个箭头函数：
const add = x => y => y + x;
// outer function: x => [inner function, uses x]
// inner function: y => y + x;


//柯里化的作用：
//1.参数复用
// 正常正则验证字符串 reg.test(txt)
// 函数封装后
function check(reg, txt) {
    return reg.test(txt)
}

check(/\d+/g, 'test')       //false
check(/[a-z]+/g, 'test')    //true

// Currying后
function curryingCheck(reg) {
    return function(txt) {
        return reg.test(txt)
    }
}
//将第一个参数reg进行复用，这样别的地方就能够直接调用hasNumber，hasLetter等函数，让参数能够复用，调用起来也更方便。
var hasNumber = curryingCheck(/\d+/g)
var hasLetter = curryingCheck(/[a-z]+/g)

hasNumber('test1')      // true
hasNumber('testtest')   // false
hasLetter('21212')      // false
```



#### `mapGetters` 

**mapGetters映射到组件的computed**

mapGetters辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：

```js
//组件内
import { mapGetters } from 'vuex'   //导入映射函数模块
import cartListItem from './cartListItem'

export default {
  name: 'cartList',
  computed: {
      // 数组形式: 利用辅助映射函数导入vuex--store-getters内的cartList
    ...mapGetters(['cartList']) 
      
    ...mapGetters({
      doneCount: 'doneTodosCount'  // 对象形式: getter方法重命名
  	})
  },
    
 //--store/getters.js
export default {
  cartLength(state){
    return state.cartList.length
  },
  cartList(state){
    return state.cartList
  }
}


// store/index.js
import Vue from 'vue'
import Vuex from 'vuex'
import getters from './getters'   //导入getter模块

// 1.安装插件
Vue.use(Vuex)

// 2.创建store对象
const store = new Vuex.Store({
  state: {
    cartList: ['商品1','商品2','商品3']   //购物车商品列表
  },
  //mutations唯一的目的：修改state中数据的状态
  mutations: {  
    /**
     * mutations内是同步操作，addCart应该放在异步操作
     */
   //mutations唯一目的就是修改state中的数据
    //这里把判断的条件分解成2个事件，保证mutation内每个事件只处理一件事的原则
    addCart(state, payload) {     //1.商品添加到购物车的事件
      payload.checked = true   //商品选中状态  默认为选中
      state.cartList.push(payload)
    },

    addCounter(state, payload) {   //2.商品已存在，数量+1事件    
      payload.count++
    }
  },
  getters ,  //导入被抽离的getters模块
  actions: {
    //****actions内是异步操作
    addCart(context,payload){   //payload 即传过来的商品
      /** 放在promise内，这样调用addCart函数时，可以通过then()获取到resolve内容
       *  方便别人知道你是否完成了这个操作*/ 
      return new Promise((resolve,reject) => {
        let oldProduct = null;
      for(let item of this.state.cartList){ //遍历购物车列表
        if(item.id === payload.id){  //如果有该商品
          oldProduct = item    //则给oldProduct赋值
        }
      }
      //判断oldProduct是否有值
      if(oldProduct){
        context.commit('addCounter', oldProduct) //分发: 调用mutation内的addCounter事件
        resolve('当前商品数量+1')
      }else{
        /**购物车没有该商品，count属性直接在这里定义，payload数量=1，且push到购物车*/
        payload.count = 1
        context.commit('addCart', payload)  //分发: 调用mutation内的addCart事件
        resolve('商品成功添加到购物车')
       }
      })
    }
  }
})
```



#### action

Action 类似于 mutation，不同在于：

- Action 提交的是 mutation，而不是直接变更状态。
- Action 可以包含任意异步操作。

Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 `context.commit` 提交一个 mutation，或者通过 `context.state` 和 `context.getters` 来获取 state 和 getters。

```js
const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment (context) {
      context.commit('increment')
    }
  }
})

actions: {
    //参数解构  解构context对象
    // context对象全部属性{commit, dispatch, state, getters, rootState, rootGetters}
  increment ({ commit }) {
    commit('increment')
  }
}

//actions分发
store.dispatch('incrementAsync', {
  amount: 10
})

//购物车示例，涉及到调用异步 API 和分发多重 mutation
actions: {
           //把入参context 参数解构
  checkout ({ commit, state }, products) {
    // 把当前购物车的物品备份起来
    const savedCartItems = [...state.cart.added]
    // 发出结账请求，然后乐观地清空购物车
    commit(types.CHECKOUT_REQUEST)
    // 购物 API 接受一个成功回调和一个失败回调
    shop.buyProducts(
      products,
      // 成功操作
      () => commit(types.CHECKOUT_SUCCESS),
      // 失败操作
      () => commit(types.CHECKOUT_FAILURE, savedCartItems)
    )
  }
}

```

组合action

```js
//通过包一层promise处理actionA异步操作返回的promise对象
actions: {
  actionA ({ commit }) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        commit('someMutation')
        resolve()
      }, 1000)
    })
  }
}

//外部调用
store.dispatch('actionA').then(() => {
  // ...
})

//另一个action
actions: {
  // ...
  actionB ({ dispatch, commit }) {
    return dispatch('actionA').then(() => {
      commit('someOtherMutation')
    })
  }
}

//利用 async / await (opens new window)，我们可以如下组合 action
//假设 getData() 和 getOtherData() 返回的是 Promise
actions: {
  async actionA ({ commit }) {
    commit('gotData', await getData())
  },
  async actionB ({ dispatch, commit }) {
    await dispatch('actionA') // 等待 actionA 完成
    commit('gotOtherData', await getOtherData())
  }
}
//一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。
```



#### mapActions   

**mapActions映射到methods**

使用 `mapActions` 辅助函数将组件的 methods 映射为 `store.dispatch` 调用

```js
import { mapActions } from 'vuex'

export default {
  // ...
  methods: {
    ...mapActions([
      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`

      // `mapActions` 也支持载荷：
      // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`
      'incrementBy' 
    ]),
    ...mapActions({
      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`
    })
  }
}
```

#### modules

Vuex 允许我们将 store 分割成**模块（module）**。每个模块拥有自己的 state、mutation、action、getter

```js
const moduleA = {
    //注意模块内的state通过函数返回，和data一样
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})

store.state.a // -> moduleA 的状态
store.state.b // -> moduleB 的状态
```

#### 命名空间

默认情况下，模块内部的 action、mutation 和 getter 是注册在**全局命名空间**的——这样使得多个模块能够对同一 mutation 或 action 作出响应。

如果希望你的模块具有更高的封装度和复用性，你可以通过添加 `namespaced: true` 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：

```js
const store = new Vuex.Store({
  modules: {
    account: {
      namespaced: true,

      // 模块内容（module assets）
      state: () => ({ ... }), // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响
      getters: {
        isAdmin () { ... } // -> getters['account/isAdmin']
      },
      actions: {
        login () { ... } // -> dispatch('account/login')
      },
      mutations: {
        login () { ... } // -> commit('account/login')
      },

      // 嵌套模块
      modules: {
        // 继承父模块的命名空间
        myPage: {
          state: () => ({ ... }),
          getters: {
            profile () { ... } // -> getters['account/profile']
          }
        },

        // 进一步嵌套命名空间
        posts: {
          namespaced: true,

          state: () => ({ ... }),
          getters: {
            popular () { ... } // -> getters['account/posts/popular']
          }
        }
      }
    }
  }
})
```



### promise重要测试

```js
function test(){
	return new Promise((resolve,reject) => {
        resolve('333')
    })
}
test() // Promise {<fulfilled>: "333"}
	   //[[PromiseState]]: "fulfilled"
       //[[PromiseResult]]: "333"
await test()  // "333"

test().then(res => {   
    return '888'     //Promise {<fulfilled>: "888"}
})

```





### async/await

async 是一个修饰符，async 定义的函数会**默认的返回一个Promise对象resolve的值**，因此对async函数可以直接进行then操作,返回的值即为then方法的传入函数

如果 async 函数没有返回值，又怎么样呢？很容易想到，它会返回 Promise.resolve(undefined)。

联想一下 Promise 的特点无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。

```js
async function fun0() {
    console.log(1)
    return 1
}
fun0().then( x => { console.log(x) })  //  输出结果 1， 1

async function funp() {
    console.log('Promise')
    return new Promise(function(resolve, reject){
        resolve('Promise')
    })
}

funp().then( x => { console.log(x) })   // 输出promise  promise
```

await 也是一个修饰符，

await 关键字 只能放在 async 函数内部， **await关键字的作用 就是获取 Promise中返回的内容**， **获取的是Promise函数中resolve或者reject的值**
// 如果await 后面并不是一个Promise的返回值，则会**按照同步程序返回值处理**

```js
// 如果await 后面并不是一个Promise的返回值，则会按照同步程序返回值处理,为undefined
const bbb = function(){ return 'string'}

async function funAsy() {
   const a = await 1
   const b = await new Promise((resolve, reject)=>{
        setTimeout(function(){
           resolve('time')
        }, 3000)
   })
   const c = await bbb()
   console.log(a, b, c)
}

funAsy()  //  运行结果是 3秒钟之后 ，输出 1， time , string
```



#### async/await全局执行顺序

```js
//若全局有多个要执行，函数体内await会让出线程，给函数体外执行,进行循环
async function async1() {
        //1
        console.log('start')
    	//2
        await async2()
    	//5 最后执行
        console.log('end')
    }
async function async2() {
    console.log('async2 start')
    console.log('async2 end')
}

async1()
//3,4执行
console.log('script start')
console.log('start') 

//执行顺序
start
async2 start //执行函数体内await
async2 end  //执行函数体内await 

script start //执行函数体外
start   	//执行函数体外
end     	//最后执行函数体内


//例2
async function async1() {
    // 2
    console.log("async1 start");
    await async2();
    // 6
    console.log("async1 end");
}
async function async2() {
    // 3
    console.log("async2");
}
// 1
console.log("script start");

setTimeout(function () {
  console.log("setTimeout");
}, 0);

async1();

new Promise(function (resolve) {
    // 4
    console.log("promise1");
    resolve();
}).then(function () {
    // 7
    console.log("promise2");
});
// 5
console.log("script end"); 

//执行顺序
script start
async1 start
async2
promise1
script end
async1 end
promise2
undefined
setTimeout
```

#### await函数体内.then顺序测试

```js
//测试1
function test1(){
	return new Promise(resolve=>{
        setTimeout(()=>resolve('我是then的数据'),1000)
    })	
}
async function test2(){
    console.log('第一条测试') //1
    await test1().then(res => console.log(res)) //2 
    console.log('第二条测试') //3
}
test2()

//测试2 跟上面执行顺序一样
function test1(){
	return new Promise(resolve=>{
        setTimeout(()=>resolve('我是then的数据'),1000)
    })	
}
async function test2(){
    console.log('第一条测试') //1
    const xx = await test1()   
    console.log(xx)  //2
    console.log('第二条测试') //3
}
test2()

//测试3 多个异步请求在同一函数内的执行顺序
function test1(){
	return new Promise(resolve=>{
        setTimeout(()=>resolve('我是test1的异步数据'),1000)
    })	
}
function test3(){
    return new Promise(resolve=> {
        setTimeout(()=>resolve('我是test3的异步数据'),500)
    })
}
// 结论: 1.加了await 所有代码按顺序执行 
//      2.异步请求不加await，会先执行同步最后执行异步
async function test2(){
    console.log('第一条测试') 
    await test1().then(res => console.log(res)) 
    console.log('第二条测试') 
    await test3().then(res => console.log(res))
    console.log('第三条测试') 
}
test2()


//测试4 不加setTimeout
function test1(){
	return new Promise(resolve=>{
        resolve('test1数据')
    })	
}
function test3(){
    return new Promise(resolve=> {
        resolve('test3数据')
    })
}
// 结论: 1.加了await 所有代码按顺序执行 
//      2.异步请求不加await，会先执行同步，最后执行异步的test1和test3
async function test2(){
    console.log('第一条测试') 
    test1().then(res => console.log(res)) 
    console.log('第二条测试') 
    test3().then(res => console.log(res))
    console.log('第三条测试') 
}
test2()
```



### vue render渲染函数

```js
new Vue({
    el: '#app',
    render: function(h){   //使用render函数 
        return h(App)
    }
    // h实际是createElement这个函数简写,其实等于下面:
    render: function(createElement){
        //用法1：createElement('标签',{标签的属性},['标签的内容'])
        //创建一个<h2>标签，替换了app挂载的内容
        return createElement('h2',{class: 'box'},['hello world'])   
       
        //用法2：传入一个组件对象
        render:function(createElement){
            return createElement(cpn)  //传入一个组件
        }
    }
})

```



高效地更新所有这些节点会是比较困难的，不过所幸你不必手动完成这个工作。你只需要告诉 Vue 你希望页面上的 HTML 是什么，这可以是在一个模板里：

```vue
<h1>{{ blogTitle }}</h1>
```

或者一个渲染函数里：

```js
render: function (createElement) {
  return createElement('h1', this.blogTitle)
}
```

```vue
//重要例子！使用render函数创建组件
<blog-post>
  <template v-slot:header>
    <h1>About Me</h1>
  </template>

  <p>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.</p>

  <template v-slot:footer>
    <p>Copyright 2016 Evan You</p>
  </template>

  <p>If I have some content down here, it will also be included in vm.$slots.default.</p>.
</blog-post>

<scrpit>
Vue.component('blog-post', {
  render: function (createElement) {
    var header = this.$slots.header
    var body   = this.$slots.default
    var footer = this.$slots.footer
    return createElement('div', [
      createElement('header', header),
      createElement('main', body),
      createElement('footer', footer)
    ])
  }
})
</scrpit>
```

#### JSX实例

```vue
//要渲染的模板
<anchored-heading :level="1">
  <span>Hello</span> world!
</anchored-heading>

//render标准写法 (函数声明式)
createElement(
  'anchored-heading', {
    props: {
      level: 1
    }
  }, [
    createElement('span', 'Hello'),
    ' world!'
  ]
)


//要渲染的模板
<anchored-heading :level="1">
  <span>Hello</span> world!
</anchored-heading>


//jsx映射写法
import AnchoredHeading from './AnchoredHeading.vue'
new Vue({
  el: '#demo',
  // h就是createElement简写
  render: function (h) {
    return (
      <AnchoredHeading level={1}>
        <span>Hello</span> world!
      </AnchoredHeading>
    )
  }
})
```

#### RenderDom组件封装

```vue
<script lang="tsx">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'RenderDom',
  props: {
    data: {
      type: Object,
      default: () => {}
    },
    render: {
      type: Function,
      default: () => {}
    }
  },
  render () {
    return this.render(this.data)
  }
})
</script>
```

#### render函数应用$slots实例

父组件对子组件传入插槽

```js
//子组件helloWorld.vue 
import {h} from 'vue'
export default {
    render(){
        return h('div', null, [
            h('h2', null, 'helloworld'),
            // 在这里接收父组件传过来的插槽，用三元运算符判断,同时可以进行Props作用域插槽传参 
            this.$slots.default ? this.$slots.default({name: 'david'}) : h('span', null, '我是插槽默认值')
        ])
    }
}

// 父组件app.vue 对子组件使用插槽
import helloWorld from './helloWorld.vue'
import {h} from 'vue'
export default {
    render(){
        // 穿插槽 第3个参数是一个对象(1个插槽)或数组(多个插槽)
        renturn h(helloWorld, null, {
            // default即默认插槽，对应的是一个函数, 接收一个props参数，其实就是作用域插槽的传参
            // 返回值就是要插入的内容，一个vnode
            default: (props) => h('span', null, `${props.name}我是父组件内容`)
        })
    }
}
```

#### JSX应用$slots实例

```jsx
//子组件helloWorld.vue
export default {
    data(){
        return {
            counter: 0
        }
    }
    render(){
        const increment = () => this.counter++
        const decrement = () => this.counter--
        return (
        	<div>
            	<h2>当前计数: {this.counter}</h2>
                <button onClick={increment}>+1</button>
                <button onClick={decrement}>-1</button>
                {this.$slots.default ? this.$slots.default() : <span>我是默认值</span>}
            </div>
        )
    }
}

// 父组件app.vue
import helloWorld from './helloWorld.vue'
export default {
    render() {
        return (
            <helloWorld>
                <!--这个双括号外层是jsx语法{}，内层是要传的对象{} 并不是mastach语法-->
                {{default: props => <span>我是父组件插入的</span>}}
            </helloWorld>
        )
    }
}
```



#### JSX在组件内绑定自定义事件

```js
//自定义组件内触发自定义事件
context.emit('search')
//父级内接收用
onSearch={ fetchData }
//props有错误提示
on-search={ fetchData } 
//可用写法
{ ...{  onSearch: fetchData } }
```





### 跨域pathRewrite原理

```js
//不配置pathRewrite 请求就被转发到 http://XX.XX.XX.XX:8083 并把相应uri带上。比如：localhost:8080/api/xxx 会被转发到http://XX.XX.XX.XX:8083/api/xxx
dev: {
    // Paths
    assetsSubDirectory: 'static',
    assetsPublicPath: '/',
    proxyTable: { // 代理从指定的target后面开始匹配
      '/api': {   // 访问/api === target + '/api'
        target: 'http://XX.XX.XX.XX:8083', 
        changeOrigin: true,
        pathRewrite: {
          '^/api': '/api'   // 这种接口配置出来  http://XX.XX.XX.XX:8083/api/login
          '^/api': '/'      // 这种接口配置出来  http://XX.XX.XX.XX:8083/login
        }
      }
    }
  }
```



### isNaN用法

isNaN() 函数用于检查其参数是否是非数字值。

如果参数值为 NaN 或字符串、对象、undefined等非数字值则返回 true, 否则返回 false。



### ??用法

```js
let message: string|null = null
const content = message ?? '我是默认值'
//等价于条件运算符
const content = message ? message : '我是默认值'
```



### vue全局注册过滤器filters

```js
//过滤器文件 common.js
/* 格式化：钱/分转元 */
let formatMoneyOfF2Y = value => {
  if (isNaN(value)) {
    return value
  }
  return value / 100
}

/* 格式化：保留几位小数 */
let formatFixed = (value, num) => {
  if (isNaN(value)) {
    return value
  }
  return Number(value).toFixed(num)
}

/* 格式化：日期 */
let formatDate = (value, pattern) => {
  if (isEmpty(value)) {
    return value
  }
  return moment(value).format(pattern)
}

export {
	formatMoneyOfF2Y,
    formatFixed,
    formatDate
}


//主文件 main.js
import * as filters from './filters/common.js'

Object.keys(filters).forEach(key => {
  Vue.filter(key, filters[key])
})
```

### vue-cli 3.0配置环境

1.根目录创建环境配置文件

.env.production

.env.development

```js
// .env.production
NODE_ENV: 'production',
VUE_APP_TITLE: 'production'

// .env.development
NODE_ENV: 'development',
VUE_APP_TITLE: 'development'
```

2.创建index.js 导出用

```js
const modeUrlObj = {
    //正式环境
    'production': {
        baseURL: 'xxxx',
        upLoadBaseURL: 'xxx',
    },
    // 本地环境
    'development': {
        baseURL: 'xxxx',
        upLoadBaseURL: 'xxx'
    },
    // 测试环境
    'test': {
        baseURL: 'xxxx',
        upLoadBaseURL: 'xxx'
    }
}
export default modeUrlObj[process.env.VUE_APP_TITLE] //根据环境动态导出其中的变量
```

3.package.json配置文件 添加命令 --mode development || production

```json
"scripts": {
    "dev": "vue-cli-service serve --mode development",
    "build": "vue-cli-service build --mode production"
  }
```

4.使用

```js
import config from './index.js'
import axios from 'axios'
const instance = axios.create({
    baseURL: config.baseURL
})
```



### router相关概念

#### route可配置属性

```js
const routes = [
    {
        path: '/home',
        name: 'home', //路由名，可根据路由名进行跳转
        component: () => import('../views/home.vue'),
        meta: { //元数据，也叫自定义数据 可在路由对象$route.meta 或 导航守卫内取到，
        	name: 'david',
            age: 33
    }
    }
]
```

#### import懒加载

其实就是在build时对文件进行分包，懒加载的文件会打包成chunk.xxx.js

```js
// import是webpack的方法，返回一个promise对象 可使用语法:import('./xxx').then()
const routes = [
    										// magic comment魔法注释 给分包自定义名
    {path: '/home', component: () => import(/* webpackChunkName: "home-chunk "*/'../views/home.vue')}
]
```



#### 动态路径匹配

```js
const User = {
  template: '<div>User {{ $route.params.id }}</div>'
}


const router = new VueRouter({
  routes: [
    // 动态路径参数 以冒号开头
    { path: '/user/:id', component: User }
  ]
})


```

```vue
<!--使用动态路径匹配-->
<router-link :to="/user/ + 'id'"></router-link>
<!--to也可以绑定对象 使用name属性时 对应route必须要配置name属性-->
<router-link :to="{name: 'home', params: {name: 'david'}}"></router-link>
<router-link :to="{path: '/home', query:{name: 'david'}}"></router-link>
```

#### 不存在路径的默认页匹配

```js
{  //当没有匹配到对应的路由时，默认显示该页面
    path: '/:pathMatch(.*)',
    component: () => import('../views/notFound.vue')
}
```

#### 子路由children

```js
{
    path: 'home',
    component: () => import('../views/home.vue'),
   	children: [ // home页配置子路由
        {path: 'children1', component: import('../views/children1.vue')},
        {path: 'children2', component: import('../views/children2.vue')},
    ]
}
// home页记得配置<router-view/>占位符显示子路由
```

#### 路由传参、取参

```js
// 编程式导航 通过query传参
this.$router.push({
    path: '/home',
    query: { // 查询字符串传参: /home?name=david 
        name: 'david'
    }
})
// 通过params传参
this.$router.push({
    name: 'home', //route须配置name
    params: {  // 动态路径传参: /home/david
        name: 'david',
    }
})
// 取参
{{$route.query.name}}
```

#### router-link的作用域插槽

```vue
<!--1.href: 跳转的链接 2.route对象 3.navigate跳转函数 -->
<!--custom表示自定义样式，取消router-link默认的a标签样式-->
<router-link to="/home" v-slot="props" custom>
    <!--router-link默认插槽-->
	<button @click="props.navigate">{{props.href}}</button>
</router-link>
```

#### 动态组件component+动画效果

```vue
<router-view v-slot="props">
    <!--动画组件包裹 实现组件切换的动画效果-->
	<transition name="anime">
        <!--作用域插槽会传过来一个component，表示当前组件-->
    	<component :is="props.component"></component>
    </transition>
</router-view>

<style>
	.anime-enter-from,
    .anime-leave-to{
        opacity: 0;
    }
    .anime-enter-from,
    .anime-leave-to{
        opacity: 1;
    }
    .anime-enter-active,
    .anime-leave-active{
        trasition: opacity 1s ease;
    }
</style>
```

#### 添加动态路由核心方法addRoute

```js
const categoryRoute = {
    path: '/category',
    component: () => import('../views/category.vue')
}
const router = createRouter({
    routes,
    history: createWebHistory()
})
// 添加顶层路由
router.addRoute(categoryRoute)
// 添加二级路由
router.addRoute('home', categoryRoute)
```

#### 导航守卫

导航守卫函数很多，最常用的是前置守卫beforeEach, 其他方法使用上都是雷同的

```js
/**
 router4.0开始不推荐使用第3个参数next, 通过函数返回值控制跳转
 返回值:
 1. return false不导航 
 2. 返回undefined或者无返回值，默认导航
 3. 返回字符串， 跳转到相应路径
 4. 对象：{path: '/login', query:{...}}
*/
router.beforeEach((to, from)=> {
    if(to.path !== '/login'){
        let token = localStorage.getItem('token')
        if(!token){
            return '/login'
        }
    }
})
```



#### 善语-动态路由（难点）

```js
 // store层/user模块  定义创建动态路由的方法generateRoutes
actions: {
    generateRoutes: function(context, str) {
      return new Promise((resolve, reject) => {
        const menu = [];
        /*判断本地缓存是否有菜单数据*/
        let rolelist = getSessionStorage('rolelist');
        let routerlist = null;
        if (rolelist) {
          /*本地缓存有数据，直接获取缓存里的数据*/
          let auth = getSessionStorage('authlist');
          if (!auth) {
            let authlist = {}
            // 创建路由路径表的方法
            createdAuth(auth, authlist);
            setSessionStorage('authlist', authlist);
          }
          let list = cearedRoute(rolelist);
          routerlist = menu.concat(list, errpage);
          context.commit("setState", {
            key: 'roles',
            val: rolelist
          });
          resolve(routerlist);
        } else {
          /*本地缓存没有数据，去掉菜单接口*/
          getRolelist().then(res => {
              // 核心方法 创建路由组件
              let list = cearedRoute(res);
              routerlist = menu.concat(list, errpage);
              setSessionStorage('rolelist', res);
              let authlist = {}
              createdAuth(res, authlist);
              setSessionStorage('authlist', authlist);
              context.commit("setState", {
                key: 'roles',
                val: rolelist
              });
              resolve(routerlist);
            })
            .catch(error => {
              reject(error);
            });
        }
      })
    }

  }

import Main from '@/views/layout/main'


/*把数据列表生成vue路由*/
function cearedRoute(list, flag) {
  let routelist = [];
  for (let i = 0; i < list.length; i++) {
    let item = list[i];
    if (item.is_route == 1) {
      // 构造路由组件
      let obj = {
        path: item.path,
        meta: {
          title: item.name
        },
        name: createAlias(item.path),
        component: item.parent_id===0? Main:loadView(item.path)
      }
      /*判断是否重定向*/
      if(item.redirect_name&&typeof(item.redirect_name)!='undefined'&&item.redirect_name!=''){
        obj['redirect']=item.redirect_name;
      }
      /*判断子路径是否是数组*/
      if (Object.prototype.toString.call(item.children) == '[object Array]' && item.children.length > 0) {
        let num = null;
        if (flag != null) {
          num = flag;
          num++;
        } else {
          num = 0;
        }
        let child = cearedRoute(item.children, num);
        if (num >= 1) {
          let temp = routelist.concat(child);
          routelist = temp;
        } else {
          obj.children = child;
        }
      }
      routelist.unshift(obj);
    }else if(item.is_route == 2){
      let obj = {
        path: item.path,
        meta: {
          title: item.name
        },
        name: createAlias(item.path),
        component: loadView(item.path)
      }
       routelist.unshift(obj);
    }
  }
  return routelist;
}

/*生成别名*/
function createAlias(str){
   return str.replace(/\//g,'_');
}

/*引入对应的组件文件*/
function loadView(view)
{
  /*将后台传过来的组件地址改成小写*/
  view=view.toLowerCase();
  /*判断第一个是不是斜杠，如果不是加上斜杠*/
  if(view.substr(0,1)!='/'){
    view+='/'+view;
  }
  /*路由懒加载，如果报错需要下载 syntax-dynamic-import 本系统使用了Babel*/
  return () => import(`@/views${view}`);
}

export {
  cearedRoute
}


// permission.js 调用加载动态路由的方法 在main.js内引入该方法
router.beforeEach(async (to, from, next) => {
  const isLogin = getCookie('isLogin');
  if (to.meta.title) {
    let title='';
    let shop_name=getCookie('shop_name');
    if(shop_name&&typeof(shop_name)!='undefined'){
      document.title = to.meta.title + '-'+shop_name;
    }else{
      document.title = to.meta.title + '-商城管理系统';
    }
  }
   //判断是否登录
  if (isLogin) {
    NProgress.start();
    let hasRoles = store.state.user.roles && store.state.user.roles.length > 0;
    if (hasRoles) {
      next();
      NProgress.done();
    } else {
      try {
        //参数暂时无效
        const roles = Math.random();
        const accessRoutes = await store.dispatch('user/generateRoutes', roles);
        resetRouter();
        router.addRoutes(accessRoutes);
        next({ ...to,
          replace: true
        });
      } catch (error) {
        next('/login');
      }
      NProgress.done();
    }
  } else {
    if (whiteList.indexOf(to.path.toLowerCase()) !== -1) {
      next();
      NProgress.done();
    } else {
      next('/login');
    }
  }
})
```



### img标签引入静态图片资源时要使用require方法

```vue
<div class="wrapper-item" v-for="(item,index) in wrappers" :key="index">
    <img :src="item.img" alt="" style="width: 292px; height: 480px;">
</div>

wrappers: [
        { img: require('../assets/p1.png') },
        { img: require('../assets/p2.png') },
        { img: require('../assets/p3.png') },
        { img: require('../assets/p4.png') }
      ]
    }
```



### elementui自定义样式

1.修改组件样式不影响全局

```css
//使用 >>> 进行样式穿透
.grid-content >>> .el-dialog {
  width: 1092px;
  height: 638px;
}
.grid-content >>> .el-dialog__body {
  padding: 0;
}
.grid-content >>> .el-dialog__header {
  padding: 0;
}
```

2.配置全局样式

```css
.el-pagination span {
  color: #656565;
  width: 50px;
  border: 1px solid #EAEAEA;
  height: 34px;
  line-height: 34px;
  box-sizing: border-box;
 }
.el-pagination.is-background .btn-next, .el-pagination.is-background .btn-prev, .el-pagination.is-background .el-pager li {
  margin: 0 5px;
  background-color: #fff;
  /* color: #606266; */
  border: 1px solid #ccc;
  color: #999;
  border-radius: 4px;
  min-width: 40px;
  height: 40px;
  line-height: 40px;
  font-size: 24px;
  /* border-radius: 2px; */
}
.el-pagination.is-background .el-pager li:not(.disabled).active {
  background-color: #f68b1f;;
  color: #FFF;
}
```



### 函数内的函数需要return才能拿到返回值

```js
// 对david()函数来说，他需要有一个return才能有返回值
function david(val){
    if(val == 1){
    //关键!!对执行函数加了return 才能在外部函数执行时拿到返回值
    return t1() 
}else{
    //关键!!对执行函数加了return 才能在外部函数执行时拿到返回值
    return t2()
	}
}

function t1(){
    console.log('t1哈哈哈')
    return true
}

function t2(){
    console.log('t2嘿嘿嘿')
    return false
}
//外部函数执行
david(1) //true 能拿到内部函数的返回值
```





### Mock用法

mock get方法传参: 1.接口，2.请求方法，3.响应数据

请求方法是get时，可以省略

**Mock.mock( rurl, rtype, template )**

```js
//1. 正常get请求
get() {
  axios.get('/user/login')
    .then(res => console.log(res))
    .catch(err => console.log(err))
}
//对应mock
import Mock from 'mockjs'

// get  默认请求方法为get，第二个参数可不写  Mock.mock( rurl, rtype, template )
Mock.mock('/user/login','get', {
  "status": 200,
  "data": {
    "id|1-9999": 0,
    "username": "@cname",
    "age|1-100": 0,
    "email": "@email",
  }
})


//2. 携带params的get请求
get() {
  axios.get('/user/login', {
    params: {
      id: 1
    }
  }
  )
    .then(res => console.log(res))
    .catch(err => console.log(err))
}

// get + params  例如 /user/login?id=1  用正则过滤掉
Mock.mock(RegExp("/user/login" + ".*"), 'get', {
  "status": 200,
  "data": {
    "id|1-9999": 0,
    "username": "@cname",
    "age|1-100": 0,
    "email": "@email",
  }
})


//3. post请求
post() {
  axios.post('/products/params', {
    id: 0,
    price: 4399
  })
    .then(res => console.log('res响应成功',res))
    .catch(err => console.log(err))
}
// post-mock
// options是mock接收到的post参数
Mock.mock('/products/params', 'post', function (options) {
  console.log('mock接收到到参数为：', options)
  if (options.body === '{"id":0,"price":4399}') {
    return {
      status: 200,
      products: 'iphone4S'
    }
  }
})


// 4.post 增加数据操作
axios.post('/params/list', {
    product: 'iphone5',
    id: 4
  })
    .then(res => console.log(res))
    .catch(err => console.log(err))

// mock 增加数据
const paramsList = [
  { product: 'iphone3G', id: 1 },
  { product: 'iphone4', id: 2 },
  { product: 'iphone4S', id: 3 },
]

Mock.mock('/params/list', 'post', options => {
  let body = JSON.parse(options.body) // 获取请求参数
  let id = parseInt(body.id)
  let flag = true

  for (let item of paramsList) {
    if (item.id === id) flag = false // 判断id是否已经存在
  }
  // 如果id不存在
  if (flag) {
    paramsList.push(
      {
        product: body.product,
        id
      }
    )
    return {
      paramsList,
      status: 200,
      msg: '添加成功'
    }
  }
  // 如果id已存在
  return {
    status: 400,
    msg: '添加失败，id已存在'
  }
})
```



电网项目mock配置

```js
// 两个mock模拟接口数据
// 1. mock/project/addProject.js
export default {
  url: '/dndcm-project/dndcm-project/project/createProject',
  method: 'post',
  response: {
    success: true,
    code: '99990000',
    message: '操作成功',
    data: true
  }
}
// 2. mock/project/detailProject.js
export default {
  url: '/dndcm-project/dndcm-project/projectCategory/queryDetail',
  method: 'post',
  response: {
    success: true,
    code: '99990000',
    message: '操作成功',
    data: {
      categoryInstruction: '123123',
      categoryName: 'qui sed sit',
      chargeLeader: -20294645,
      createId: -8717333,
      deployId: -15048698,
      id: 44047940,
      parentId: 1,
      showYn: 1,
      status: 1,
      updateId: -5032834
    }
  }
}

// 统一导出:mock/project/index.js
import addProject from './addProject'
import treeProjectCategory from './treeProjectCategory'
import detailProjectCategory from './detailProjectCategory'

export default [
  addProject,
  treeProjectCategory,
  detailProjectCategory,
]


// mock主文件：mock/index.js
import Mock from 'mockjs'
import MockCommon from './common'
import MockProject from './project'
import MockStream from './stream'

// 解构所有导入的数组，即模拟数据
const mockArray = [
  ...MockCommon,
  ...MockProject,
  ...MockStream
]

if (JSON.parse(process.env.VUE_APP_OPEN_MOCK)) {
  for (const mockItem of mockArray) {
    Mock.mock(process.env.VUE_APP_BASE_URL + mockItem.url, mockItem.method, mockItem.response)
  }
}

```



### ''展开收起''按钮小技巧

```vue
<!--stretchNum=3 始终渲染前3条数据，当index>3时，根据点击展开按钮，取反collapse状态是否渲染更多-->
v-show="index < config.stretchNum || collapse"
```



### scss 相关

####  &符号意义()

本质就是父元素的占位符

```scss
//不使用&占位符，编译后的问题
.text a {
  color: blue;
  :hover { color: red }
}

//编译成css后 
.text a {
  color: blue;
}
// 注意:hover前产生了空格, 变成了所有a后代的hover效果
.text a :hover {
  color: red;
}
```

这个时候就可以使用&父选择器标识符，它的作用就相当于一个父选择器的占位符。可以实现class为text的所有后代a标签的元素，当鼠标悬浮时，字体颜色都会变为红色。

```scss
.text a {
  color: blue;
  &:hover { color: red }
}

//上面的代码编译的时候，会将&替换为父选择器a，编译后的css代码如下:
.text a {
  color: blue;
}
.text a:hover { //变成想要的效果 a:hover
  color: red;
}
```



```scss
//&父选择器标识符并不仅仅用于链接伪类选择器，看如下scss代码实例:
//&会替换成嵌套外层的父选择器
#content aside {
  color: red;
  body.ie & { color: green }
}
//编译为css代码如下:
#content aside {color: red};
body.ie #content aside { color: green }


//&会层层传递出去
#main {
  color: black;
  a {
    font-weight: bold;
    &:hover { color: red; }
  }
}

//编译为
#main {
  color: black; }
  #main a {
    font-weight: bold; }
	//&会层层传递出去
    #main a:hover {
      color: red; }
```

　　

```scss
//& 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如
#main {
  color: black;
  &-sidebar { border: 1px solid; }
}
//编译为css
#main {
  color: black; 
}
#main-sidebar {
    border: 1px solid; 
}

//& 用在嵌套的scss代码里，来引用父元素
.dashboard {
  &-container {
    margin: 30px;
  }
  &-text {
    font-size: 30px;
    line-height: 46px;
  }
}
//编译为css 原本在scss的嵌套结构被展平了
.dashboard-container {
  margin: 30px; }
.dashboard-text {
  font-size: 30px;
  line-height: 46px; }


```



#### @mixin/@include 

```scss
//定义一个名为important-text混入
@mixin important-text {
  color: red;
  font-size: 25px;
  font-weight: bold;
  border: 1px solid blue;
}

//使用混入
.danger {
  @include important-text;
  background-color: green;
}

//混入中也可包含混入
@mixin special-text {
  @include important-text;
  @include link;
  @include special-border;
}

//混入传递变量
/* 混入接收两个参数 */
@mixin bordered($color, $width) {
  border: $width solid $color;
}

.myArticle {
  @include bordered(blue, 1px);  // 调用混入，并传递两个参数
}

.myNotes {
  @include bordered(red, 2px); // 调用混入，并传递两个参数
}
```



### 统一导出(模块导出规范)

相关功能模块文件夹内新建一个Index.js文件 用于统一导出的出口

```js
/*	
目录结构: 
api/
	api.common.js
	api.project.js
	api.stream.js
	index.js
*/
// index.js 统一出口文件 导入所有相关模块接口，并导出
export { default as ApiCommon } from './api.common' 
export { default as ApiProject } from './api.project' 
export { default as ApiStream } from './api.stream' 

// 要使用的地方 路径直接写/api即可， 无需写成/api/api.common
import { ApiCommon } from '@/api'
```



### $emit(update:xxx)子组件通知父组件更新写法

子组件通知父组件更新

普通写法:

```vue
<!--父组件-->
<!--父组件需要传一个绑定值（message）同时需要设置一个更新触发函数（func）给子组件修改绑定值的时候调用-->。
<parent :message="bar" @update:message="func">

<!--js定义函数-->
func(val){
    this.bar = val
 }
<!--子组件触发更新-->
func2(){
    this.$emit('update:message',valc)
}
```

.sync简化写法，父组件不需要定义更新触发函数

```vue
<!--父组件-->
<comp :message.sync="bar"></comp>

<!--子组件-->
this.$emit('update:message',valc)
```



### 工具类

把传入的对象转化成字符串形式

```js
const json2url = (obj: any) => {
  let result: any[] = []
  for (let key in obj) {
    if (!isN(obj[key])) {
      result.push(key + '=' + encodeURI(obj[key]))
    }
  }
  return (result.length ? '?' : '') + result.join('&') // ?name=david&age=19 这种字符串
}
```

### 不定参数(...args)

**三个点(...)在es6中，有两个含义:**

- 用在形参中， 表示传递给他的参数集合， 类似于arguments, 叫不定参数. 语法格式:  在形参面前加三个点( ... )
- 用在数组前面，可以把数组的值全部打散，展开，叫展开运算符. 语法格式:  在数组面前加三个点( ... )

```js
// ...values取代了以前arguments的作用
function add(...values){
    console.log(values) //[10,20,30]
    let sum = 0
    for(let i=0,len=values.length; i<len; i++){
        sum += values[i]
    }
    return sum
}

var res = add(10,20,30) // 60
```



### axios拦截对象和响应对象实例

```js
// 请求拦截对象config
config = {
    adapter: ƒ xhrAdapter(config)
    arguments: [Exception: TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them at Function.r (<anonymous>:1:83)]
    caller: [Exception: TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them at Function.r (<anonymous>:1:83)]
    length: 1
    name: "xhrAdapter"
    prototype:
    constructor: ƒ xhrAdapter(config)
    [[Prototype]]: Object
    [[FunctionLocation]]: xhr.js:12
    [[Prototype]]: ƒ ()
    [[Scopes]]: Scopes[3]
    baseURL: "/api"
    data: "{}"
    headers:
    Accept: "application/json, text/plain, */*"
    Content-Type: "application/json;charset=utf-8"
    accessToken: "d5de8c51f5d342af0dde453effd41442054994cf43bd63ca5ec5b2a7987604f5"
    [[Prototype]]: Object
    maxBodyLength: -1
    maxContentLength: -1
    method: "post"
    timeout: 0
    transformRequest: [ƒ]
    transformResponse: [ƒ]
    url: "/user/area/tree"
    validateStatus: ƒ validateStatus(status)
    xsrfCookieName: "XSRF-TOKEN"
    xsrfHeaderName: "X-XSRF-TOKEN"
}


// 响应对象response 其中的config属性就是请求的config对象
// 常用属性config, data, status
response = {
	config: {
        url: '/user/area/tree', 
        method: 'post', 
        data: '{}', 
        headers: {
            Accept: "application/json, text/plain, */*"
			Content-Type: "application/json;charset=utf-8"
			accessToken: "d5de8c51f5d342af0dde453effd41442054994cf43bd63ca5
        }, 
        baseURL: '/api', 
        url: "/user/area/tree"
    },
    // 接口返回的数据都在data里
    data: {code: '000000', message: '成功', data: Array(35)}
    headers: {access-control-allow-origin: '*', connection: 'close', content-type: 'application/json;charset=UTF-8', date: 'Mon, 13 Sep 2021 09:12:03 GMT', transfer-encoding: 'chunked'}
    request: XMLHttpRequest {readyState: 4, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, onreadystatechange: ƒ, …}
    status: 200
    statusText: "OK"    	
}
```



### new FileReader()

主要涉及在前端处理图片上传时候回显、接收后端文件

1.FileReader : 读取文件内容

readAsText() 读取文本文件，(可以使用Txt打开的文件)
readAsBinaryString(): 读取任意类型的文件，返回二进制字符串

readAsDataURL(): 方法可以将读取到的文件编码成DataURL ，可以将资料(例如图片、excel文件)内嵌在网页之中

2.FileReader 提供一个完整的事件模型，用来捕获读取文件的状态
onabort:读取文件断片时触发
onerror:读取文件错误时触发
onload:文件读取成功时触发
onloadend:文件读取完毕之后，不管成功还是失败触发
onloadstart: 开始读取文件时触发
onprogress:读取文件过程中触发

```html
<!--使用Data URL加载图片资源-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blob Test</title>
  <script>
    function handleFile(e) {
      var file = e.files[0];
      var fileReader = new FileReader();
      var img = document.getElementByTagName("img")[0];
      fileReader.onload = function(e) {
        img.src = e.target.result;
      }
      fileReader.readAsDataURL(file);
    }
  </script>
</head>
 
<body> 
  <input type="file" accept="image/*" onchange="handleFile(this)" />
  </br>
  <img style="width:200px;height:200px;">
</body>
  
</html>
```

```html
<!--使用Blob URL 回显图片-->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Blob Test</title>
  <script>
    function handleFile(e) {
      var file = e.files[0];
      var blob = URL.createObjectURL(file);
      var img = document.getElementByTagName("img")[0];
      img.src = blob;
      img.onload = function(e) {
        URL.revokeObjectURL(this.src); //释放createObjectURL创建得对象
      }
    }
  </script>
</head>

<body>
  <input type="flie" accept="image/*" onchange="handleFile(this)" />
  <br/>
  <img style="width:200px;height:200px;">
</body>

</html>
```



```js
function add(f) {
			// console.log(f.files[0].type)    //图片格式
			// console.log(f.files[0].size)    //图片大小做判断
			// 解析预览
			let reader = new FileReader()
			reader.readAsDataURL(f.files[0])
			reader.onload = function () {
			  // console.log( reader.result)  //base64格式的图片
			  myimg.src=reader.result
			}
			//上传时候也是传的f.files[0]文件。
	}

// 上传图片回显实例 jsx写法
{ label: '图标', prop:'icon', colSpan: 24, render: (data: any) => {
      const fileUploadChange = (file: any) => {
        let reader = new FileReader()
        reader.readAsDataURL(file.raw)
        reader.onload = function () {
          data.formData.icon = reader.result
        }
      }
      let dom = <i class="el-icon-plus avatar-upload-icon"></i>
      if (data.formData.icon) {
        dom = <img src={data.formData.icon} class="avatar"></img>
      }
      return (
        <el-upload
          class="avatar-upload"
          on-change={fileUploadChange}
          auto-upload={false}
          show-file-list={false}>
          {dom}
        </el-upload>
      )
    }, },
```

### blob对象

blob就是类似文件对象的二进制数据

可以像操作File对象一样操作Blob对象，实际上，**File继承自Blob**

构造: new Blob([blobparts], options)

参数：**blobparts** : 数组类型 数组中每项连在一起构成blob数据

**options**: 可选项 字典格式类型 

可指定: 

1. **type**   默认值为`""`，代表被放入到blob中的数组内容的MIME类型

2. **endings**   默认值为"transparent"，用于指定包含行结束符`\n`的字符串如何被写入

Blob([blobparts1, blobparts2], options)

```js
// 通过new Blob() 构造一个Blob实例
// 入参
const blob = new Blob()
```

#### Blob URL

Blob URL是blob协议的URL    格式：`blob:http://xxx`

通过`URL.createObjectURL(blob)`创建

通常作为文件的下载地址和作为图片资源地址

```typescript
const convertRes2Blob = (response: AxiosResponse) => {
  // 获取文件名
  const filename = response.config['filename']
  // 将二进制流转为blob
  const blob = new Blob([response.data], { type: 'application/octet-stream' })
  const blobURL = window.URL.createObjectURL(blob)
  const tempLink = document.createElement('a')
  tempLink.style.display = 'none'
  tempLink.href = blobURL
  tempLink.setAttribute('download', decodeURI(filename))
  if (typeof tempLink.download === 'undefined') {
    tempLink.setAttribute('target', '_blank')
  }
  document.body.appendChild(tempLink)
  tempLink.click()
  document.body.removeChild(tempLink)
  // 释放blob URL地址
  window.URL.revokeObjectURL(blobURL)
}



//文本转语音实例
audioAPI.getShortAudio({
    config: {
      format: 'mp3',
      sampleRate: 16000,
      pitch: 0,
      volume: 0,
      speed: -250,
      digitMode: 0,
      puncMode: false
    },
    text: text // 要播报的内容
  }, null, data => {
    console.log(data)
    loadingInstance.close()
    // 1.接口返回blob类型文件，转化为blobURL
    const url = URL.createObjectURL(data.data)
    // 2.传入转化后的url,创建audio实例
    self.n = new Audio(url)
    self.n.play()
  })
```

#### Blob URL和Data URL区别

1.Blob URL得长度一般比较短，但Data URL因为直接存储图片base64编码后得数据，往往很长。当显示大图片时，使用Blob URL更优。

2.Blob URL可以方便的使用XMLHttpRequest获取源数据

3.**Blob URL只能在当前应用内部使用**，把Blob URL复制到浏览器的地址栏中，是无法获取数据的。Data URL相比之下，就有很好的移植性，你可以在任意浏览器使用。

除了可以用作图片资源的网络地址，Blob URL也可以用作其他资源的网络地址，例如html文件、json文件等，为了保证浏览器能正确的解析Blob URL返回的文件类型，需要在创建Blob对象时指定相应的type：

```js
var data = "<div style='color:red;'This is a blob</div>";
var blob = new Blob([data], {type: 'text/html'}); // 'application/json'
var blobUrl = URL.createObjectURL(blob);
```

### File对象

File指本地文件系统中的文件。File对象提供有关文件的信息，并允许网页中的 JavaScript 访问其内容。

File是一个具有名字同时可能也有一个修改日期的Blob。可以从一个由 <input type="file"/> 元素组成的 files 数组中，或者从一个由与 drop 事件的 Event 对象关联的 DataTransfer 对象组成的 files 数组中，取得一个用户选择的文件。

可以通过 FormData 对象或者将 File 传入 XMLHttpRequest.send() 来将一个文件的内容上传到服务器，除此之外 File 对象本身不支持别的操作。可以使用 FileReader 来读一个 File（或者任意 Blob）的内容。

```js
// bits：ArrayBuffer，ArrayBufferView，Blob，或者 DOMString 对象的 Array — 或者任何这些对象的组合
// name: 文件名称或文件路径
// options: 可选配置属性 {type: 文件中的内容的 MIME 类型, lastModified: 文件最后修改时间}
var myFile = new File(bits, name[, options]);

// 示例
var file = new File(["foo"], "foo.txt", {
  type: "text/plain",
});
```





### 时间格式化库 dayjs

npm install dayjs



### $event

#### 场景1：获取原生DOM事件的事件对象

在DOM事件的回调函数中传入参数`$event`，可以获取到该事件的事件对象

#### vue监听方法时加不加括号区别

@click=handler($event)  加了括号需要手动传入原生事件对象$event, 不传会报undefined

@click="handler"  不加括号 默认第一个参数是$event

加与不加括号的区别在于事件对象参数 event 的处理。不加括号时，函数第一个参数为 event，加了括号后，需要手动传入 $event 才能获得事件对象。

```vue
<template>
<button @click="getData($event)">按钮</button>
</template>

<script>
export default {
    setup() {
        const getData = (e) => {
            console.log(e)
        }
        return {
            getData
        }
    }
}
</script>
```

 



#### 场景2：事件注册所传的参数(子组件向父组件传值)

在子组件中通过`$emit`注册事件，将数据作为参数传入，在父组件中通过`$event`接收

```vue
<!-- 父组件 -->
<template>
<Hello @hello="showData($event)" />
<h4>{{data}}</h4>
</template>

<script>
import Hello from '@/components/Hello.vue'
import {
    ref
} from 'vue'
export default {
    components: {
        Hello
    },
    setup() {
        const data = ref(null)
        const showData = (e) => {
            data.value = e
        }
        return {
            showData,
            data
        }
    }
}
</script>

<!-- 子组件 -->
<template>
<button @click="$emit('hello', 'hello')">Hello</button>
<!-- $emit()的第一个参数是定义的事件名，第二个参数是要传入的数据 -->
</template>

<script>
export default {

}
</script>
```



### 动态路由注册

后端返回路由表

```js
{
  "data": {
    "router": [
      {
        "path": "",
        "redirect": "/home",
      },
      {
        "path": "/home",
        "component": "Home",
        "name": "Home",
        "meta": {
          "title": "首页",
          "icon": "example"
        },
        "children": [
          {
            "path": "/xitong",
            "name": "xitong",
            "component": "xitong/xitong",
            "meta": {
              "title": "系统",
              "icon": "table"
            }
          }
        ]
      },
      {
        "path": "*",
        "redirect": "/404",
        "hidden": true
      }
    ]
  }
}
```

注意其中的component字段，他是字符串，我们需要把这个字符串转化为我们前端定义的组件

```js

function filterRouter(routers) { // 遍历后台传来的路由字符串，转换为组件对象
    const accessedRouters = routers.filter(route => {
        if (route.component) {
            if (route.component === 'Home') { // Home组件特殊处理
                route.component = Home
            } else {
                route.component = _import(route.component)
            }
        }
        if (route.children && route.children.length) {
            route.children = filterRouter(route.children)
        }
        return true // filter方法执行到最后返回true 既符合条件的route
    })
    return accessedRouters
}

//这个函数的主要作用就是把后台传过来的字符串型的component转化为真正的组件
function _import (file) {
    return () => import('@/components/views/' + file + '.vue')
}
```



### Mock配置相关

```js
// vue_cli项目 配电网
// 在.env.devlopment文件内配置: VUE_APP_OPEN_MOCK = true 
import Mock from 'mockjs'
import MockCommon from './common'
import MockProject from './project'
import MockStream from './stream'

const mockArray = [
  ...MockCommon,
  ...MockProject,
  ...MockStream
]

// vue_cli利用VUE_APP_OPEN_MOCK配置文件进行mock开关设置
if (JSON.parse(process.env.VUE_APP_OPEN_MOCK)) {
  for (const mockItem of mockArray) {
    Mock.mock(process.env.VUE_APP_BASE_URL + mockItem.url, mockItem.method, mockItem.response)
  }
}

// vite项目 湖南中台 mock.js
import { MockMethod } from 'vite-plugin-mock'  //MockMethod是mock插件
import commonMock from './modules/common/index'
import applicationMock from './modules/application/index'

export default [
  ...commonMock,
  ...applicationMock,
  ...categoryMock,
] as MockMethod[]   


// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import vueJsx from '@vitejs/plugin-vue-jsx'
import { viteMockServe } from 'vite-plugin-mock' //控制台显示mock请求的插件
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  base: './',
  plugins: [vue(), vueJsx(), viteMockServe({
    localEnabled: false // 模拟数据开关
  })],
  resolve: { 
    alias: {
      '~': path.resolve(__dirname, './'),
      '@': path.resolve(__dirname, 'src')
    }
  },
  server:{
    proxy:{
      '/api': {
        target: 'http://10.1.192.38:18084/', // 杭州测试环境网关
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  }
})

```

### 浏览器线程概念

　js是单线程的，但是浏览器是多线程的，多个线程相互配合以保持同步，浏览器下的线程有

- JavaScript引擎线程，用于解析JavaScript代码 
- GUI渲染线程，（它与javaScript线程是互斥的）
- 事件线程(onclick,onchange,…)
- 定时器线程(setTimeout, setInterval)
- 异步http线程(ajax)，负责数据请求
- EventLoop轮询处理线程，事件被触发时该线程会把事件添加到待处理队列的队尾

### JS的事件循环和任务队列

**事件循环(event loop):** 同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入任务队列。主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop (事件循环)。

在事件循环中，每进行一次循环操作称为tick，通过阅读规范可知，每一次 tick 的任务处理模型是比较复杂的，其关键的步骤可以总结如下：

1.在此次 tick 中选择最先进入队列的任务( [oldest task](https://www.zhihu.com/search?q=oldest+task&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A87684858}) )，如果有则执行(一次)

2.检查是否存在 Microtasks ，如果存在则不停地执行，直至清空Microtask Queue

3.更新 render

4.主线程重复执行上述步骤

注：如此循环就形成了event loop，其中，每轮执行**一个宏任务**和**所有的微任务**

**任务队列(task queue):** 所有的任务分为**同步任务**和**异步任务**，任务进入执行栈后，同步任务直接进入主线程执行，异步任务会被放入**微任务队列或宏任务队列**中挂起

异步任务又分为**微任务microTask**和**宏任务macroTask**

宏任务主要包含：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)

微任务主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)

#### async / await 执行问题

```js
async function async1() {
  await async2()
  console.log('async1 end')
}
async function async2() {
  console.log('async2 end')
}
async1()

// 等价ES5写法
new Promise((resolve, reject) => {
  async2() 
  ...
}).then(() => {
 // 执行async1()函数await之后的语句
  console.log('async1 end')
})
```

**async**将你的函数返回值转换为promise对象，不需要显式地返回promise对象，async关键字自动将函数的返回值变为promise对象

**await** 只能在async函数内部使用，等待的是右侧[表达式结果]，如果右侧是一个函数，等待的是右侧的函数返回值, 若右侧不是函数则直接是右侧的表达式。await在等待时会让出线程阻塞后面的执行。await的执行顺序为从右到左，会阻塞后面的代码执行，但并不是直接阻塞await的表达式。

await之后如果不是promise，await会阻塞后面的代码，会先执行async外面的同步代码，等外面的同步代码执行完成在执行async中的代码。

如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。

 **async 函数中，遇到 await 会跳出当前函数，并让出线程，再将await后面的代码放到 微任务（microtask）队列中。**



### DOM0级和DOM2级事件处理程序区别

DOM0级

分为2个：一是在标签内写onclick事件

　　　　  二是在JS写onclick = function（）{}函数

**DOM0级相同的事件只能绑定一个，后一个会覆盖前一个事件**

DOM2级

只有一个：监听方法，有两个方法用来添加和移除事件处理程序：addEventListener()和removeEventListener()。

**DOM2级可以同时绑定几个事件（相同或不同），然后顺序执行，不会覆盖。**

它们都有三个参数：第一个参数是事件名（如click）；

　　　　　　　　　第二个参数是事件处理程序函数；

　　　　　　　　  第三个参数如果是true则表示在捕获阶段调用，为false表示在冒泡阶段调用。

```html
<!--dom0级事件处理程序，绑定的函数后面要加括号，因为其本质是一个字符串，执行时解析字符串中的函数-->
<!--写法1： 绑定在html上-->
<button id="btn1" onclick="demo()">按钮</button>
<script>
    //写法2：写在js中
	document.getElementById('btn1').onclick = function(){
        demo()
    }
</script>

<!--dom2级事件处理程序, addEventListener
	函数名的本质是指针，指向函数地址，绑定函数名，不需要加括号(带参数函数，需包裹匿名函数)
-->
<script>
	document.getElementById('btn1').addEventListener('click', demo, false)
</script>
```

#### 原生事件对象event

```html
<button id="btn1" onclick="demo(this)">按钮</button>
<button id="btn2" onclick="demo3(event)">按钮2</button>
<button id="btn3">按钮3</button>
<script>
    // dom0级绑定写法1：这个参数source就是htmlElement元素,也就是event.target
	function demo(source){
        console.log(source) // 获得source就是this, 当前元素对象
    }
    function demo3(e){
        console.log(e)  //获得事件对象event
    }
    // dom0级绑定写法2： 默认传入事件对象e
    document.getElementById('btn3').onclick = function(e){
        console.log(e)
        console.log(this)
    }
</script>
```



### decodeURI和decodeURIComponent区别

encodeURI/decodeURI对特殊字符(/ * # &)没有编码解码能力, 在返回查询体时容易被截断导致错误

```js
// encodeURI
let codeVal = encodeURI('202112#abc')
let url = 'http://www.baidu.com?code=' + codeVal
console.log(url) // http://www.baidu.com?code=202112#abc
// 使用location.search获取查询体，不能编码特殊字符，导致#被截断
location.search // ?code=202112
decodeURI('?code=202112')  // ?code=202112 错误的返回，因为#后的参数没有返回

// encodeURIComponent
var codeVal = encodeURIComponent('20180711#abc');
var url = 'http://www.baidu.com?code=' + codeVal;
// 使用encodeURIComponent编码 特殊字符#不会被截断
console.log(url)   // "http://www.baidu.com?code=20180711%23abc"
location.search // ?code=20180711%23abc
decodeURIComponent('?code=20180711%23abc') // "?code=20180711#abc"
```

### flex布局混淆点

```
flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto
flex属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)

flex-grow: 项目的放大比例，默认为0，如果存在剩余空间，不放大
flex-shrink: 项目的缩小比例，默认为1，如果空间不足，会适当缩小
flex-basis: 在分配空间之前，项目的主轴空间，相当于我们设置的width

```

flex: 1 === flex: 1 1 0%  

flex: auto === flex: 1 1 auto

auto 表示项目本身的大小, **如果设置为 auto, 那么这三个盒子就会按照自己内容的多少来等比例的放大和缩小**, 所以出现了上图中三个盒子不一样大的情况



### vscode关闭es-lint

文件-首选项-设置搜索"eslint.enable"  关闭



### ES11可选链 操作符 ?.

```js
//语法
obj?.prop
obj?.[expr]
arr?.[index]
func?.(args)
//使用方括号与属性名的形式来访问属性时
let nestedProp = obj?.['prop' + 'Name'];
// 访问数组
let arrayItem = arr?.[42];
//调用函数
adventurer.someNonExistentMethod?.()
```

### 执行上下文和堆栈

递归调用是如何工作的。为此，我们会先看看函数底层的工作原理。

有关正在运行的函数的执行过程的相关信息被存储在其 **执行上下文** 中。

[执行上下文](https://tc39.github.io/ecma262/#sec-execution-contexts) 是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置，当前的变量，`this` 的值（此处我们不使用它），以及其它的一些内部细节。

一个函数调用仅具有一个与其相关联的执行上下文。

当一个函数进行嵌套调用时，将发生以下的事儿：

- 当前函数被暂停；
- 与它关联的执行上下文被一个叫做 **执行上下文堆栈** 的特殊数据结构保存；
- 执行嵌套调用；
- 嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从停止的位置恢复外部函数。

```js
// 递归例子
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
      // 递归函数会创建新的执行上下文，并记录到堆栈顶部
      // 当这个调用结束时，会被弹出堆栈，并继续执行下去
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) );



// 任何递归都可以用循环来重写，通常循环变体更有效，循环算法更节省内存：
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```



![image-20220121170117082](C:\Users\yoki\AppData\Roaming\Typora\typora-user-images\image-20220121170117082.png)



### 关于img父容器的高度会比img的高度多几像素的问题

基线问题，div是块级标签，img是行内块元素，在块元素里默认有3px或者4px空白（其实就是和文本的基线对齐不管有没有文本）

解决方案： 1.设置图片 display:block  2.设置父容器:display: flex  3.设置图片vertical-align: top



### 文档注释插件

vscode安装 document this

快捷键：选中方法ctrl+alt+D 连按两次



### class类中的super关键词

作用：

super用于访问父对象上的函数

语法：

1. super([arguments]) // 访问父对象上的构造函数
2. super.functionOnParent([arguments]) //访问对象上的方法

#### 1.  super作为函数调用时

```js
// 1. super 作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次 super() 函数。
class A {}
class B extends A {
  constructor() {
    super(); //类似函数的call， 相当于执行了A的constructor，并且让方法中的this指向B的实例
  }
}
// super 作为函数调用时，内部的 this 指的是子类实例
class A {
  constructor() {
    this.show();
  }
}
class B extends A {
  constructor() {
    super();
  }
  show(){
    console.log('实例');
  }
  static show(){
    console.log('子类');
  }
}
new B() 　//输出 '实例' ，new B 时触发了 B 的构造函数，所以触发了 super 方法，即触发了父类 A 的构造函数，此时的 this.show 的 this 指的是子类 

```

####  2.1 super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。	

```js
//super在普通方法中（即非静态方法）及此时的 this 关键字指向
class A {
  p() {
    return 2;
  }
}
class B extends A {
  constructor() {
    super();
    console.log(super.p()); // 2  此时的super指向父类原型对象，即 A.prototype
  }
}
let b = new B();　　//2


//由于在普通方法中的 super 指向父类的原型对象，所以如果父类上的方法或属性是定义在实例上的，就无法通过 super 调用的。如下所示：
class A {
  constructor() {  //在构造函数上定义的属性和方法相当于定义在父类实例上的，而不是原型对象上
    this.p = 2;
  }
}
class B extends A {
  get m() {
    return super.p;
  }
}
let b = new B();
console.log(b.m) // undefined


//在子类普通方法中通过 super 调用父类的方法时，方法内部的 this 指向的是当前的子类实例。
class A {
  constructor() {
    this.x = 1;
  }
  print() {
    console.log(this.x);
  }
}
class B extends A {
  constructor() {
    super();
    this.x = 2;
　　 super.y = 123;　　//如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。
  }
  m() {
    super.print();
  }
}
let b = new B();
b.m() // 2
console.log(b.y);  //123
```

#### 2.2 super在静态方法中及此时的 this 关键字指向

```js
//super作为对象，用在静态方法之中，这时 super 将直接指向父类，而不是父类的原型对象。
class Parent {
  static myMethod(msg) {
    console.log('static', msg);
  }
  myMethod(msg) {
    console.log('instance', msg);
  }
}
class Child extends Parent {
  static myMethod(msg) {
    super.myMethod(msg);
  }
  myMethod(msg) {
    super.myMethod(msg);
  }
}
Child.myMethod(1); // static 1
var child = new Child();
child.myMethod(2); // instance 2



//在子类的静态方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类，而不是子类的实例。
class A {
  constructor() {
    this.x = 1;
  }
  static print() {
    console.log(this.x);
  }
}
class B extends A {
  constructor() {
    super();
    this.x = 2;
  }
  static m() {
    super.print();
  }
}
B.x = 3;
B.m() // 3
```



### class类的静态属性和静态方法 static

如果在一个方法前加上[static](https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020)关键字，就表示该方法不会被**实例**继承，而是直接通过类来调用，这就称为“静态方法”

静态方法只能写在class内，constructor外。通过static关键字声明

静态属性通过 类名.属性名 = 属性值 声明

```js
//静态属性与静态方法(ES6明确规定，Class内部只有静态方法，没有静态属性 )
            
//1.不会被类实例所拥有的属性与方法,只是类自身拥有
//2.只能通过类调用

//通过static关键字声明一个静态方法

class Car{
    constructor(){
        Car.totalCar += 1;
        this.speed = 0;
    }

    speedUp(){
        this.speed += 1;
    }

    static repair(car){
        if(!car.speed){
            car.speed = 0;
        }

        console.log(car);
    }
}

//静态方法只能通过类去访问,不能通过实例去访问的
Car.repair({
    color:'#f00'
});
//静态方法跟普通方法可以重名


//静态属性只能通过 类名.属性名 = 属性值;
//静态属性可以增加一些配置项等等
Car.totalCar = 0;  //记录生成了多少个Car对象
//直接挂在类上面,跟程序的耦合性降低
Car.config = {
    wheel:4,
    color:'#000'
}

//直接方法静态属性： 类名.属性名
new Car()
console.log(Car.totalCar);
```

### 为什么不能在data中使用this

因为此时的 data 初始化正在进行，即在取值步骤（参考上面初始化的解释），还未进行代理和监听（此时 newId 未代理到 this 上），所以 this.newId 等于 undefined

https://blog.csdn.net/u012557814/article/details/120963056



### replace 第二个参数$1, $2..切割正则

```js
//把 "Doe, John" 转换为 "John Doe" 的形式：
var str = "Doe, John";
str.replace(/(\w+)\s*, \s*(\w+)/, "$2 $1");
//说明：$1,$2上就是按顺序对应小括号里面的小正则 捕获到的内容。 
```

 



### 正向代理和反向代理

正向代理

隐藏了真实请求的客户端，客户端的请求通过代理服务器，服务端不知道真实的客户端是谁，某些科学上网工具就是正向代理服务器，比如访问google.com 就可以通过正向代理，让代理请求，再把请求返回给我

反向代理

反向代理隐藏了真实的服务器，当请求baidu.com时，背后可能是N个服务器为我们服务，但具体是哪一台并不知道，baidu.com就是我们的反向代理服务器，反向代理把请求转发到真实的服务器，nginx就是一个反向代理服务器，用来做负载均衡

![image-20220311102725898](C:\Users\yoki\AppData\Roaming\Typora\typora-user-images\image-20220311102725898.png)

两者的区别在于代理的对象不一样：**正向代理**代理的对象是客户端，**反向代理**代理的对象是服务端